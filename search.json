[{"title":"【学习记录】Mysql","url":"/2023/04/30/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91Mysql/","content":"在计算机中的软件层面而言，数据的来源始终是一个个文件，而我们想用到这些数据，就得按照文件所支持的格式去读取，比如txt、excel或者其它。\nmysql是由瑞典MySQL AB公司开发，目前属于 Oracle 公司的，一个关系型数据库管理系统，它管理数据的本质也是把数据存到了它所规定格式的文件中，并提供一系列的规则（指令集），让使用者可以操作这些数据。一般我们在开发中提到mysql，都是指使用某种编程语言或某个GUI程序去使用mysql来管理数据。有时候也要注意，Structured Query Language - SQL是关系型数据库的标准查询语言。\nMySQL详细学习教程（建议收藏）-CSDN博客\n关于mysql还有其他有趣的信息，比如：\nMySQL 是开源的，所以你不需要支付额外的费用。MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。MySQL 使用标准的 SQL 数据语言形式。MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C C++ Python Java Perl PHP Eiffel Ruby Tcl 等。MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统\n","categories":["学习记录"],"tags":["mysql"]},{"title":"【学习记录】Typescript","url":"/2023/05/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91Typescript/","content":"前言\nTS是什么？\nTypescript是Javascript的超集，简称TS。（甚至可以说所有合法的js代码就是ts）\n\n在完全兼容js的基础上，添加了类型支持\nps:用过js就知道没有类型检查给开发带来的负面影响有多么不可忽视\n\nTS的优势？\n\n类型系统、类型推断机制、静态检查、全局代码提示，提升开发效率，还方便重构\n支持最新ECMAScript语法，走在技术前沿\n\n\n如何获取TS？\n\nnpm i -g typescript\n\n由于ts编译器推广的范围有限，主流仍是以js为准，如下：\n\n\n\n\nTS–&gt;”Hello World!”?\n\n创建文件hello.ts，内容：console.log(&#39;Hello World!&#39;);\n方法一：\n将ts编译为js：tsc hello.ts\n执行js：node hello.js\n\n\n方法二：\n安装ts-node包：npm i -g ts-node\n使用ts-node运行ts：ts-node hello.ts\n\n\n\n\n\n\n类型类型注解let age: number = 18\n类似冒号后跟类型名的形式，就是类型注解。typescript是强类型，不同于python。\n常用基础类型JS已有类型：number/string/boolean/null/undefined/symbol/object\n// JS已有的基础类型let age: number = 12// 数组类型（推荐第一种、第三种）let nums: number[] = [1,2,3]let strs: Array&lt;string&gt; = [&#x27;a&#x27;,&#x27;b&#x27;]\n\n\n\nTS新增类型：联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any等\n\n联合类型，在TS中用 | 表示\n// | 在TS中叫做 联合类型，let mixs: (number|string)[] = [&#x27;a&#x27;,1,&#x27;b&#x27;] // 用法一：表示数组中的元素可以是number或string类型let mix2: number | string[] = 1 // 用法二：表示mix2可以是number或者是string数组类型\n\n类型别名（自定义类型）,在TS中用type表示\ntype MyType = (number|string)[]let aVar: MyType = [1,&#x27;a&#x27;]\n\n函数类型（可以理解为函数参数和返回值的类型）\nfunction add(num1: number, num2: number): number &#123;    return num1 + num2&#125;// 稍微复杂的情景：匿名函数+函数表达式const add: (num1: number, num2: number) =&gt; number = (num1, num2) =&gt; &#123; return num1 + num2 &#125;// 可以理解为const add: (类型) = () =&gt; &#123;&#125;// 没有返回值：voidfunction hello(): void &#123; console.log(&#x27;hello！&#x27;) &#125;\n\n\n可选参数（可传可不传），在TS中用?表示\nfunction mySlice(start?: number, end?: number): void &#123;    console.log(&#x27;start:&#x27;, start, &#x27;end:&#x27;, end)&#125;// 可选参数应放在参数列表末尾，所有必传参数之后\n\n\n对象类型\nlet person: &#123; name: string, age: number, sayHi: ()=&gt;void, greet(name:string):void &#125; = &#123;    name: &#x27;lhd&#x27;,    age: 23,    sayHi() &#123; console.log(&#x27;Hi! I\\&#x27;m lhd.&#x27;) &#125;,    greet(name)&#123;console.log(`Hi, my $&#123;name&#125;.`)&#125;&#125;// 可以理解为 let person: (类型) = &#123;&#125;type Person = &#123;     name: string,     age: number,     sayHi: () =&gt; void,     greet(name: string): void &#125;let me:Person = &#123;    name: &#x27;lhd&#x27;,    age: 23,    sayHi() &#123; console.log(&#x27;Hi! I\\&#x27;m lhd.&#x27;) &#125;,    greet(name) &#123; console.log(`Hi, my $&#123;name&#125;.`) &#125;&#125;\n\n分隔符\n  // 当参数被多行分隔的话，可以省略末尾的分隔符(;或者,)let person: &#123;     name: string    age: number    sayHi: () =&gt; void    greet(name: string): void &#125; = &#123;    name: &#x27;lhd&#x27;,    age: 23,    sayHi() &#123; console.log(&#x27;Hi! I\\&#x27;m lhd.&#x27;) &#125;,    greet(name) &#123; console.log(`Hi, my $&#123;name&#125;.`) &#125;&#125;\n\n对象可选属性，用?表示\nlet person: &#123;     name?: string // 被标记为可选    age: number     sayHi?(): void // 被标记为可选    greet(name:string):void &#125; = &#123;    name: &#x27;lhd&#x27;,    age: 23,    //sayHi() &#123; console.log(&#x27;Hi! I\\&#x27;m lhd.&#x27;) &#125;,    greet(name)&#123;console.log(`Hi, my $&#123;name&#125;.`)&#125;&#125;\n\n\n接口（多用于复用的场景）\ninterface IPerson &#123;    name: string    age: number    sayHi(): void&#125;// 复用let me: IPerson=&#123;    name:&#x27;lhd&#x27;,    age:12,    sayHi()&#123;&#125;&#125;\n\n\n与类型别名的区别\n相同点：都可以给对象指定类型\n不同点：接口只能为 对象  指定类型；类型别名可以为 任意类型  指定别名\n\n接口继承（在TS中用extends表示）\ninterface Point2D &#123; x: number; y: number &#125;interface Point3D &#123; x: number; y: number; z: number &#125;// 等效于如下：interface Point2D &#123; x: number; y: number &#125;interface Point3D extends Point2D &#123; z: number &#125;\n\n\n元组（确切知道元素个数和类型的特例数组）\nlet position: [number, number] = [12,4]\n\n类型推论TS类型推论机制会帮助推断 没有明确声明类型且立即初始化值的 变量的类型\n比如在VSCode中，将鼠标放在没有明确声明类型的变量上，就可以看到如下效果：\n\nTS类型推论机制会帮助推断 没有明确声明函数返回值类型的 函数的返回值类型\n\n类型断言当只能获取一个范围较为宽泛的类但又想调用某个不在该类中的属性或方法，往往是失败的。\n这时就要使用类型断言指定更加具体的类型，在TS中用as表示，也可以用&lt;&gt;表示\n// 推荐第一种const aLink = document.getElementById(&#x27;link&#x27;) as HTMLAnchorElementconst aLink = &lt;HTMLAnchorElement&gt;document.getElementById(&#x27;link&#x27;)aLink.href // 调用某个属性\n\n\n\n字面量类型仔细看如下两个变量的类型：\n\n\n在这个例子当中\n由let声明的变量str1是 可变的，可以为任意字符串，所以为string\n由const声明的变量str2是 不可变的，所以类型为它本身，即ss。类似这样的类型，在TS中被称为 字面量类型\n\n使用模式\n配合联合类型一起使用\n\n使用场景\n表示一组明确可选的值列表\nfunction changeDirection(direction: &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;) &#123;    console.log(direction)&#125;\n\n枚举类型枚举的功能类似 字面量类型+联合类型组合 的功能，可以表示一组明确的可选值，在TS中用enum表示\nenum Direction &#123; Up, Down, Left, Right &#125;function changeDirection(direction: Direction) &#123;    console.log(direction)&#125;\n\n\n在TS中用.访问枚举类型的成员\nconsole.log(Direction.Up)\n\n枚举的值 默认是从0开始的自增自然数，也可以在声明时手动赋值\nenum Direction &#123; Up = 2, Down = 4, Left = 6, Right = &quot;right&quot; &#125;\n\n数字枚举的赋值顺序默认是 自增的\n枚举的值都为数字的枚举被称为 数字枚举；同理由 字符串枚举，但它没有自增长行为。\n一个数字、字符串混合枚举的例子如下：\n\n\n枚举的特性和原理：不仅用作类型，还提供值，是为数不多的非JS类型拓展之一\n\n\n综上，还是更推荐字面量类型+联合类型组合的方式，更简洁、直观、高效\nfunction changeDirection(direction: &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;) &#123;    console.log(direction)&#125;\n\n\n\nany类型原则：不推荐使用any！这会让TypeScript变为AnyScript（失去TS类型保护的优势）\nlet obj: any = &#123;x:0&#125;obj.bar=100obj()\n\n以上操作不会有任何类型错误提示，即使可能存在错误\n除此之外，还要注意隐式声明any的情景：\n// 声明变量不提供类型和默认值let a// 函数参数不加类型function add(n1,n2)&#123;return n1+n2&#125;\n\ntypeof运算符ts-typeof：js只是打印类型（打印的结果本身类型是string），ts中则是返回类型注解，本身也可以用来类型注解\n高级类型 classclass的基本使用：类似直接把变量和函数写在class yourName &#123;...&#125;就可以了\nclass的构造函数：要注意的四点就是声明必须且只有constructor，且不能有自定义的函数返回值注解，用this访问自己，成员初始化后才能用构造函数访问和赋值（重要）\nclass的方法：不需要由function声明，但函数类型注解的使用跟普通函数一样\nclass Car &#123;    brand:string        constructor(brand:string)&#123;        this.brand = brand    &#125;        get price()&#123;        return 1000    &#125;    printBrand():void&#123;        console.log(this.brand)    &#125;&#125;const c = new Car(&quot;红旗&quot;)console.log(c.price)c.printBrand()\n\nclass 继承class-继承：使用extends关键字, 用于继承父类的所有属性和方法\nclass Animal&#123;    move()&#123;console.log(&#x27;Moving!&#x27;)&#125;&#125;class Dog extends Animal&#123;    bark()&#123;console.log(&#x27;汪汪汪&#x27;)&#125;&#125;\n\nclass 实现接口\nTypeScript中的接口（interface）是一种定义对象结构的方法，它允许您规定对象应具有哪些属性和方法，以及它们的类型。接口在编译时进行类型检查，但不会生成任何实际的JavaScript代码。使用接口可以帮助您确保代码遵循预期的结构和约束，从而提高代码的可读性和健壮性。\n\nclass-实现接口：使用implements让class实现接口，前提是接口必须提供所有属性和方法，*同时类必须实现接口所有的***属性和方法（重要）\ninterface Singable &#123;    sing(): void&#125;class Person implements Singable &#123;    sing() &#123;        console.log(&#x27;Yi ya yi ya yi~&#x27;)    &#125;&#125;\n\n\n\nclass 可见性修饰符class-可见性修饰符：使用public、protected、private放在属性或者方法前，表示对于class外的代码是否可见；默认是public，可以省略；三者对应的生效范围分别是：实例、类、子类；类、子类；类\nclass 其它修饰符class-其它修饰符：readonly（只读修饰符），表示该属性是只读的，不能修饰方法；额外需要注意的是，需要手动指定注解（不指定的话，会被推论成它的值本身）\n类型兼容性类型兼容性：常见的类型系统有两种Structure Type System（结构化类型系统）、Nominal Type System（标明类型系统）。TS用的是前者，也被称为“鸭子类型” 类型兼容可以体现在，接受三个参数的函数，可以只传入1个参数；相同结构但不同的类，可以互相作为对方实例化时的注解；等等\n对象类型的兼容对于对象类型，A的成员至少与B相同，则B兼容A（成员多的可以赋值给少的）\nclass Point &#123; x: number; y: number &#125;class Point3D &#123; x: number; y: number; z: number &#125;const p: Point = new Point3D()\n\n\n\n接口类型的兼容对于接口（类似interface Point{x:number,y:number}），同上\ninterface Point &#123; x: number; y: number &#125;interface Point2D &#123; x: number; y: number &#125;interface Point3D &#123; x: number; y: number; z: number &#125;let p1: Point = &#123; x: 1, y: 2 &#125;let p2: Point2D = &#123; x: 11, y: 22 &#125;let p3: Point3D = &#123; x: 111, y: 222, z: 333 &#125;p1 = p2p2 = p3\n\n\n\n函数类型的兼容\n参数个数兼容：参数少的可以赋值给多的（看上去与之前的相反）\ntype F1 = (a: number) =&gt; voidtype F2 = (a: number, b: number) =&gt; voidlet f1: F1 = (x) =&gt; &#123; console.log(`number $&#123;x&#125;`) &#125;let f2: F2 = f1f2(3,4) // output: number 3\n\n\n\n函数参数类型兼容：相同位置的参数类型要相同（原始类型）或兼容（对象类型），（判断兼容的技巧：把对象拆开，把每个属性看做一个个参数，然后基于参数个数兼容）\ninterface Point2D &#123; x: number; y: number &#125;interface Point3D &#123; x: number; y: number; z: number &#125;type F1 = (p: Point2D) =&gt; voidtype F2 = (p: Point3D) =&gt; voidlet f1: F1 = (p) =&gt; &#123; console.log(`x: $&#123;p.x&#125;, y: $&#123;p.y&#125;`) &#125;let f2: F2 = f1f2(&#123; x: 3, y: 4, z: 5 &#125;) // output: x: 3, y: 4\n\n\n\n返回值类型兼容：如果返回值是原始类型，此时两个类型要相同；如果返回值是对象类型，则成员多的可以赋值给成员少的\n type F1 = () =&gt; stringtype F2 = () =&gt; stringtype F3 = () =&gt; &#123; name: string, age: number &#125;type F4 = () =&gt; &#123; name: string &#125;let f1: F1 = () =&gt; &#123; return &quot;f1&quot; &#125;let f2: F2 = f1let f3: F3 = () =&gt; &#123; return &#123; name: &quot;f3 name&quot;, age: 3 &#125; &#125;let f4: F4 = f3\n\n综上，有关函数参数相关的，少的可以赋给多的；有关对象和接口的，多的可以赋给少的。\n（ps：有点像 方法属性可以冗余，但参数不能溢出）\n交叉类型在TS中用&amp;表示，功能类似于接口继承（extends），用于组合多个类型为一个类型（常用于对象类型）\ninterface Person &#123; name: string &#125;interface Contact &#123; phone: string &#125;type PersonDetail = Person &amp; Contactlet obj: PersonDetail = &#123;    name: &#x27;jack&#x27;,    phone: &#x27;188...&#x27;&#125;\n\n这样，新类型PersonDetail就同时具有Person 和 Contact的所有属性和方法了\n和接口继承extends的区别：\n相同点：都可以实现对象类型的组合\n不同点：对于同名属性时，处理类型冲突的方式不一样\n\n对于继承extends这样会报错；而对于交叉类型，效果如下：\n\ninterface A &#123;    fn: (value: number) =&gt; string&#125;interface B &#123;    fn: (value: string) =&gt; string&#125;type C = A &amp; Blet c: C = &#123;    fn(value: number | string) &#123;        return &#x27;&#x27;    &#125;&#125;\n\n泛型泛型，是可以在保证类型安全（即 不丢失类型信息）前提下，让函数等与多种类型一起工作，从而实现复用，常用于：函数、接口、class中\n调用泛型函数function id&lt;Type&gt;(value: Type): Type &#123; return value &#125;// 手动指定`&lt;&gt;`中的类型const num = id&lt;number&gt;(10)const str = id&lt;string&gt;(&#x27;a&#x27;)// 省略&lt;类型&gt;（需要注意可能被推断为*字面量类型*）const num = id(10)const str = id(&#x27;a&#x27;)\n\n\n\n\n\n类型变量如例子中的Type，它是一种特殊类型的变量，它处理类型而不是值\n该变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）\n因为Type时类型，因此可以将其作为函数参数和返回值的类型，同时也代表参数和返回值具有相同的类型\n类型变量Type，可以是任意合法的变量名称\n泛型约束默认情况下，泛型函数的类型变量Type可以代表多个类型，这导致无法访问任何属性，例子中，Type可以代表任意类型，无法保证一定存在length属性，所以会报错。\n\n解决该问题，有两种方法：\n1.指定更加具体的类型\nfunction id&lt;Type&gt;(value: Type[]): Type []&#123;     console.log(value.length)    return value &#125;\n\n2.添加约束\n// 创建描述约束的接口，该接口要求提供length属性interface ILength &#123; length: number &#125;// 通过 extends 关键字使用接口，为泛型（类型变量） 添加约束// 表示，传入的类型必须具有length属性function id&lt;Type extends ILength&gt;(value: Type): Type &#123;    console.log(value.length)    return value&#125;\n\n\n\n多个变量类型 + 变量间的约束泛型的类型变量可以有多个，并且类型变量之间还可以约束（比如，第二个类型变量受第一个类型变量约束）\nfunction getProp&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) &#123;    return obj[key]&#125;let person = &#123; name: &#x27;jack&#x27;, age: 18 &#125;getProp(person, &#x27;name&#x27;)\n\n代码示例解释：\n\n添加了第二个类型变量Key，两个类型变量之间使用,分隔\nkeyof关键字接受一个对象类型，生成其键名称（可能是字符串或数字）的联合类型\nKey后面接extends表示受keyof Type的约束\n\n泛型接口在接口名称的后面添加&lt;类型变量&gt;，那么这个接口就变成了泛型接口\n接口的类型变量，接口中的所有成员都可以使用\n使用泛型接口时，需要显式指定具体的类型\ninterface IdFunc&lt;Type&gt; &#123;    id: (value: Type) =&gt; Type    ids: () =&gt; Type[]&#125;let obj: IdFunc&lt;number&gt; = &#123;    id(value) &#123; return value &#125;,    ids() &#123; return [1, 3, 5] &#125;&#125;\n\n\n\n数组是泛型接口：\nlib.es5.d.ts\n\n泛型类class也可以配合泛型来使用，类似于接口，在class后面添加&lt;类型变量&gt;，那么这个类就变成了泛型类\nclass GenericClass&lt;Type&gt;&#123;    defaultValue: Type    showValue: () =&gt; Type = () =&gt; &#123;        console.log(this.defaultValue)        return this.defaultValue    &#125;    constructor(x: Type) &#123;        this.defaultValue = x    &#125;&#125;const myClass = new GenericClass&lt;number&gt;(1)myClass.defaultValue = 1myClass.showValue()\n\n泛型工具类型TS中内置了常用的工具类型，简化了TS中的一些常见操作，它们都是基于泛型实现的\n\nPartial&lt;Type&gt;用来构造（创建）一个类型，将Type的所有属性设置为可选\ninterface Props &#123;    id: string    children: number[]&#125;type PartialProps = Partial&lt;Props&gt;\n\n\n\nReadonly&lt;Type&gt;用来构造（创建）一个类型，将Type的所有属性设置为readonly（只读）\ninterface Props &#123;    id: string    children: number[]&#125;type ReadonlyProps = Readonly&lt;Props&gt;\n\n\n\nPick&lt;Type, Keys&gt;从Type中选择一组属性来构造新类型（Keys只能是Type中存在的属性）\ninterface Props &#123;    id: string    children: number[]    other: string&#125;type PicklyProps = Pick&lt;Props, &#x27;id&#x27; | &#x27;other&#x27;&gt;\n\n\n\nRecord&lt;Keys, Type&gt;构造一个对象类型，属性键为Keys，属性类型为Type）\ntype RecordObj = Record&lt;&#x27;name&#x27; | &#x27;nickname&#x27;, string&gt;let obj: RecordObj = &#123;    name: &#x27;my name&#x27;,    nickname: &#x27;my nickname&#x27;&#125;\n\n索引签名类型当无法确定对象中有哪些属性（或者说对象中可以出现任意多个属性），此时，就用到索引签名类型了\ninterface AnyObject &#123;    [Key: string]: number&#125;let obj: AnyObject = &#123;    a: 1,    b: 2&#125;\n\n使用[key: string]表示索引签名，用来约束该接口中允许出现的属性名称类型。表示只要是string类型的属性名称，都可以出现在对象中\n这样，对象obj中就可以出现任意多个属性\nkey只是一个占位符，可以换成任意合法的变量名称\n数组中可以出现任意多个元素，在Array中的定义中也可以看到使用了索引签名类型\n\n映射类型基于旧类型创建新类型（对象类型），减少重复，提高开发效率。映射类型本质是基于索引签名类型的，所以也使用了[]\n注意：映射类型只能在类型别名中使用，不能在接口中使用\n1.基于 联合类型 创建 对象类型\ntype PropKeys = &#x27;x&#x27; | &#x27;y&#x27; | &#x27;z&#x27;type Type1 = &#123; x: number; y: number; z: number &#125;// 使用 映射 减少重复，效果和Type1相同type Type2 = &#123; [Key in PropKeys]: number &#125;\n\n\n\n2.基于 对象类型 创建 对象类型\n\n3.泛型工具类型 也是基于映射类型实现的\n\n​\t这就涉及 索引查询（访问）类型：[]访问的属性必须存在于被查询的类型中，否则报错，下面是几个例子\n\n\n\nTS中的两种文件类型.ts是implementation代码实现文件，.d.ts是declaration类型声明文件\n\n文件格式为.ts\n\n既可以包含 类型，也可以包含 可执行代码\n可以被编译成 .js文件，然后执行代码\n用途：编写程序代码的地方\n\n\n文件格式为.d.ts\n\n只可以包含 类型，不可以出现 可执行代码\n不会被编译成 .js文件，仅仅提供类型信息\n用途：为JS提供类型信息\n\n\n\n类型声明文件项目使用到的JS第三方库几乎都有相应的TS类型，是因为有类型声明文件用来为已存在的JS库提供类型信息\n下载一个JS第三方库，在其目录下的.d.ts结尾的就是类型声明文件\n\n使用已有的类型声明文件\n\n内置类型声明文件：TS为JS运行时可用的所有标准化内置API都提供了声明文件，例如lib.es5.d.ts\n\n第三方库类型声明文件：\n几乎所有常见的第三方库都有相应的类型声明文件，当下载一个第三方库的包时，可以在包的目录中发现index.d.ts（packages.json中的typings会指定加载哪个声明文件）\n第二种方式，由DefinitelyTyped提供（是一个github上的库，用来提供高质量TypeScript类型声明）。可以通过npm/yarn来下载该仓库提供的TS类型声明包，这些包的名称格式为：@types/*，下载安装后，TS也会自动加载该类型声明包\n\n\n​\n\n\n\t\n编写自己的类型声明文件\n项目内共享类型：如果多个.ts文件中都用到同一个类型，此时可以创建.d.ts文件提供该类型，实现类型共享\n\n\n创建index.d.ts类型声明文件\n创建需要共享的类型，并使用export导出\n在需要使用的共享类型的.ts文件中，通过import导入\n\n// index.d.tstype Props = &#123; x: number; y: number &#125;export &#123;Props&#125;// main.tsimport &#123; Props &#125; from &quot;.&quot;;let p: Props = &#123;    x: 1,    y: 2&#125;\n\n\n\n\n为已有JS文件提供类型声明\n\n​\t在将JS项目迁移到TS项目中时，为了让已有的.js文件由类型声明，或者自己开发了一个库分享给别人使用。但是需要注意的是，和上面的情景不一样，类型声明文件的编写于模块化方式相关。JS模块化的发展可谓百家争鸣（AMD、CommonJS、UMD、ESModule等），所以导致TS在支持所有模块化的基础上，其声明文件的相关内容又多又杂\n机制说明：\n\nTS项目中也可以使用.js文件\n\n在导入.js文件时，TS会自动加载与.js同名的.d.ts文件，以提供类型变量\n\n\ndeclare关键字：用于类型声明，为其他地方（比如，.js文件）已存在的变量声明类型，而不是创建一个新的变量\n\n对于type、interface等这些明确就是TS类型的（只能在TS中使用），可以省略declare关键字\n对于let、function等具有双重含义（在JS、TS中都能用），应该使用declare关键字，明确类型\n\n// main.jslet count = 10function add(x, y) &#123;    return x + y&#125;const formatPoint = point =&gt; &#123;    console.log(point)&#125;// main.d.tsdeclare let count: numberdeclare function add(x: number, y: number): numberinterface Point &#123;    x: number    y: number&#125;declare let point: Pointdeclare const formatPoint: (point: Point) =&gt; void// 注意：类型提供好以后，需要使用 模块化方案 中提供的//      模块化语法，来导出声明好的类型，然后，才能在//      其它的 .ts 文件中使用// 以下时ES6的模块化语法export &#123; count, add, Point, point, formatPoint &#125;\n\n\n\n\n\n","categories":["学习记录"],"tags":["Typescript"]},{"title":"【学习记录】django","url":"/2022/11/23/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91django/","content":"概要Django 是用 Python 开发的一个免费开源的 Web 框架，几乎囊括了 Web 应用的方方面面，可以用于快速搭建高性能、优雅的网站。\nDjango 提供了许多网站后台开发经常用到的模块，使开发者能够专注于业务部分\nMTV和MVCWeb 开发领域还有另外一个非常著名的设计模式——MVC（Modle-View-Controller）\nDjango 的设计模式，也就是 MTV（Modle-Template-View），在 Django 是有 Controller 层的，只不过它由框架本身来实现，所以我们不用关心它\nORMObject Realtional Mapping（对象关系映射），基于关系型数据库的程序技术。\nORM使用类和对象来操作关系型数据库（MySql、Oracle等），避免了直接使用sql语句，底层用映射机制实现的（到一定水平我再去看看）\n映射机制：\n\n把类映射为数据库中的表\n把类的实例映射为数据库的表的数据行\n把类的属性映射为数据库的表的字段\n\n表模型为Model，继承自django.db.models的Model类，所有和表相关的操作，都是继承这个类字段类型用类似xxxField来描述\nDjango提供了基本的CURD（增删改查）和其他API来对数据库表进行操作\nauth模块Django提供的 auth 模块能够快速的实现用户模块的基本功能\n\n实现并维护了用户与用户组的增加、删除、更改功能；\n实现了用户权限与用户组权限的增加、删除、更改；\n实现了可以自定义用户权限与用户组权限功能。\n还提供了权限验证等功能以及一些常用的方法\n\nAdmin后台管理系统让不懂编程的人也能快速上手维护后台，配置人员权限\n视图函数（View）\n在 Django 中，视图函数是一个 Python 函数或者类\n视图函数首先接受来自浏览器或者客户端的请求，并最终返回响应\n\nfrom django.http import HttpResponsedef Hello_my_django(request):    return HttpResponse(&#x27;&lt;html&gt;&lt;body&gt;Hello my Django&lt;/body&gt;&lt;/html&gt;&#x27;)\n从以上我们可以了解视图函数工作的关键三点：\n\nHttpResponse，是一种视图响应的类型\nrequest，Django 规定了，视图函数至少有一个参数，第一个参数必须是 request\nreturn，视图函数要返回响应内容，这里的响应内容是我们用 HTML 标签编写的，把它作为 HttpResponse 的对象返回给浏览器\n\n模板系统（Template）从上一小节代码中，可以看到竟然将html的代码放到了程序里，势必会有高度耦合、难以维护的隐患，而模板系统就是将视图函数和html代码解耦的\n在tamplates文件夹（一个项目同级目录，Django会自动识别）下新建hello.html，编写如下代码：\n\n视图函数调用模板，并进行“模板传参”\nfrom django.shortcuts import render      def hello_my_django(request):    return render(request,&quot;hello.html&quot;,&#123;&quot;vaule&quot;:&quot;hello my Django&quot;&#125;)\n另一种是render方法，封装在django.shortcuts中，也很方便\nURLURL 的语法格式为：protocol://[username:password@]hostname[:port]/path[?query][#fragment]\n示例：https://www.baidu.com/movie/movieshow?id=234&amp;number=1314#name\n从中可以了解到URL基本语法，当然还有类似%code机制处理特殊字符的知识，可令开一篇文章总结\n路由系统Django通过ROOT_URLCONF构建URL和视图函数的映射关系，在urls.py路由配置文件中配置url\nurls.py 文件中定义了一个 urlpatterns 的列表，它是由 url( ) 实例对象组成的列表，Django 中 url 的定义就是在这个列表完成的\nfrom django.conf.urls import urlurlpatterns=[url(r &#x27;^admin/&#x27;,admin.site.urls), # 后台 Admin 管理系统的路由就定义在了列表第一个位置...]\nurl(regex,view,name=None)说明：\n\nregex，匹配请求路径，用正则表达式表示（其用法很丰富，可以单独开一篇博客总结）\nview，指定 regex 匹配路径所对应的视图函数的名称\nname，是给 url 地址起个别名，在模板反向解析的时候使用\n\nhttps://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Django/Introduction有张图不错，可以很清晰看出MTV模式\n中间件中间件是介于 request 与 response 之间的一道处理过程，相对比较轻量级\n我们可以通过中间件来修改请求，例如，被传送到视图函数中的 HttpRequest 对象，也可以修改视图函数返回的 HttpResponse 对象\n中间件作为一个可插拔的组件对外提供服务，每个中间件都负责完成一些特定的功能\n所有中间件都是默认激活的状态。当然你可以通过代码注释，将某个中间件关闭\nCache缓存系统Django 提供了一个健壮的缓存系统，可以保存动态页面，这样就不必每次都把相同的请求进行重复计算。\n并且 Django 还提供了不同级别的缓存粒度，可以缓存特定视图的输出，或者只缓存某些特定的片段，比如网站自动跳出的咨询栏等，或者也可以缓存整个站点\nMemcached 是 Django 支持的最快、最高效的分布式高效缓存系统，它是一种完全基于内存的缓存服务器\n至此，当新建一个Django项目后，以上内容就是默认提供的了，而不用自己再去一个个搭建\n搭建Djang开发环境\npython 解释器\nMySql数据库（Django自带SQLite数据库，但由于是轻量级的，不太建议用在企业级应用）\n包管理器 python -m pip install -U pip\npycharm IDE（得找个破解的专业版）\nDjango（注意和python的版本关系），使用pip安装\n\nDjango创建第一个项目pip install djangocd your_dirmkdir your_dir2cd your_dir2django-admin startproject mytestsitecd mytestsitepython manager.py runserver进入http://127.0.0.1:8000，至此你看到了一个由django打造的示例网站\n概述我们再来捋一捋django它的整个主要逻辑：\nMTV分别代表模型、模板和视图，分别负责数据库、网页整体框架和动态数据更新\n除此之外\n\nurl路由表负责将客户端的请求连接到相应的视图\napp应用负责划分功能逻辑上的模块（比如同一网站的博客、wiki、主页等等）\n每个应用需要分配指定url，而且还需要在工程中注册\n每次更改模型后都需要执行migrate相关命令\n\n安装djangodjango是可以以pip的方式安装的，但不能就此认为它的结构很简单\n安装好后，除了sitepackage下的源码，还有↓python安装目录/Scripts/django-admin.exe它提供了一系列的指令集，帮助我们从创建django项目等等\ndjango的项目也较为复杂，不是flask那种，一个python文件就可以了，所以了解django项目的基本结构很必要\nmyProject|--manage.py      【项目管理、启动项目、创建app、数据管理等】【一般不要手动修改】【但很常用】|--myProject   |--__init__.py    |--settings.py 【项目配置】            【会经常手动修改】【很常用】   |--urls.py     【url和函数的对应关系】 【会经常手动修改】【很常用】   |--asgi.py     【接受网络请求】        【一般不要手动修改】   |--wsgi.py     【接受网络请求】        【一般不要手动修改】\n\n\n\n除此之外，django中app的概念也是很重要的，进入到我的django目录下执行python manage.py startapp myapp，会生成一个app，它的基本结构也是很重要的\nmyProject|--manage.py |--myProject   |--...(折叠)|--myApp   |--__init__.py   |--admin.py        【一般不要手动修改】django默认提供的admin后台管理   |--apps.py         【一般不要手动修改】app启动类   |--migrations      【一般不要手动修改】数据库的变更记录      |--__init__.py   |--models.py       【频繁修改】【**重要**】对数据库的操作   |--tests.py        【不常用】单元测试   |--views.py        【**重要**】函数\n\n从以上的基本结构中，不难看出，需要开发自己的功能，则需要：\n\n创建app\n注册app\n编写views（自定义的视图函数）\n绑定url\n\n快速实践\n 新建一个django项目\n 新建一个app\n 新建一个template\n\n\nsettings.py中的可以设置template的路径\n默认是按照app的注册顺序，依次到他们的文件夹下找template html文件\n在app文件下新建templates文件夹，下面写自己的html文件\n\n\n 新建静态资源的存储位置（app文件夹下新建static文件夹）\n之所以这样做，得看settings.py中设置的静态文件的路径具体是什么，默认的/static/\n\ndjango的模板语言的语法def my_views_func(request):\treturn render(request,&quot;xxx.html&quot;,&#123;&quot;key1&quot;:&#x27;value1&#x27;,&#125;) 这样就可以将数据传给模板\n\n\n\n\n由此可看出，django中通过client -- urls.py -- views.py -- （含模板语言的）templates -- （完全纯粹的）html -- client这样的流程来给用户展示网页\ndjango的相应和请求请求-request 是客户端的发来的所有数据，发送数据的方式分为GET和POST\n在django语法的判断中，是要大写的request.method == &quot;GET&quot;request.method == &quot;POST&quot;\n\n响应-response 则是服务端返回给客户端的所有东西\nHttpResponse(&quot;xxx字符串&quot;)    # 返回字符串render(request，&quot;xxx.html&quot;)  # 返回渲染后的htmlredirect(&quot;xxx-url&quot;)          # 返回一个重定向网址：告诉客户端你该去访问另一个地方了\n\n\ndjango操作数据库操作数据库，使用pymysql对于所有python程序都是可行的，django也不例外，但是django提供了orm框架使我们更方便的去操作数据库由于最新版本的django对pymysql存在底层编码的bug，所以还需要安装mysqlclient\npip install mysqlclient\n\n在当前mysql服务中创建好我们的数据库后\ncreate database web_demo_django default charset utf8 collate utf8_general_ci;\n\n在settings.py设置我们的数据库\nDATABASES = &#123;      &#x27;default&#x27;: &#123;          &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,          &#x27;NAME&#x27;: &#x27;web_demo_django&#x27;,          &#x27;USER&#x27;: &#x27;root&#x27;,          &#x27;PASSWORD&#x27;: &#x27;123456&#x27;,          &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,          &#x27;PORT&#x27;: 3306      &#125;  &#125;\n\n创建表，在models.py写一个类—-和数据库表对应，比如建立一张表UserInfo\nfrom django.db import modelsclass UserInfo(models.Model):      name = models.CharField(max_length=32)      password = models.CharField(max_length=64)      age = models.IntegerField()\n然后，在项目的根目录依次执行两个命令↓：\npython manage.py makemigrationspython manage.py migrate\n如果是第一次执行，django会将当前注册的所有app它们默认有的表也一起创建了\n之后如果对这些与数据表对应的类进行新建、修改、注释、删除等操作，都需要再次执行↑  这两个指令\n之后如果要对表操作，需要先把对应的类import之后，再根据django的语法去执行，下面是几个基本的语法示例\nfrom myApp.models import UserInfo# 1.新增数据UserInfo.objects.create(name=&#x27;xxx&#x27;,password=&#x27;xxx&#x27;,age=&#x27;xxx&#x27;)# 2.删除数据UserInfo.objects.filter(id=4).delete()# 3.获取数据data_obj_list = UserInfo.objects.all() # data_obj是QuerySet类型for data_obj in data_obj_list:\tprint(data_obj.name,data_obj.password,data_obj.password)# 4.更新数据UserInfo.objects.filter(id=4).update(name=&#x27;xxxx&#x27;)\n\n\ndjango的路由在urls.py 配置路由：url和函数的关系\n在views.py，写（视图）函数，编写业务逻辑，可以在urls.py与某个url相关联\ndjango的模板templates目录，编写html模板（django的模板语法，继承，\ndjango的ModelForm和Form组件\n自动生成HTMl标签（默认属性可以自行修改）\n支持数据进行校验\n支持保存到数据库（ModelForm）\n支持错误信息\n\ndjango的Cookie和Session将用户的登录信息保存起来\ndjango的中间件基于 process_request，实现用户认证\nORM操作models.User.objects.filter(id=&quot;xxx&quot;)\n\ndjango的组件系统–Formqueryset = models.UserInfo.objects.all() # UserInfo表的外键department_id是department表的idquery_object.get_gender_display() # 直接拿限定范围的字段对应的值query_object.department.title # 直接拿所外联的表中对应的值\n\n数据处理设计思路参考\n\n用户提交数据没有校验\n用户输入的错误，页面应该有错误提示\n页面上，每一个字段都需要我们在前后端手动重新写一遍\n关联的数据，需要一个一个手动去获取并循环展示在页面因此，学会用组件Form，可以事半功倍\n\nForm# ---------views.pyfrom django.forms import Form  from django import formsclass UserForm(Form):      user_name = forms.CharField(widget=forms.TextInput)def user_add(request):\tform = UserForm()\treturn render(request,&#x27;user_add.html&#x27;,&#123;&quot;form&quot;:form&#125;)\n\n\nModelForm# ---------views.pyfrom django.forms import ModelFormfrom django import formsclass MyForm(ModelForm):      xx = forms.CharField(&quot;xxx&quot;)        class Meta:          model = app01.models.UserInfo          fields = [&quot;name&quot;, &quot;password&quot;, &quot;age&quot;]# ---------models.pyclass UserInfo(models.Model):      &quot;&quot;&quot;员工表&quot;&quot;&quot;\txx = forms.CharField(&quot;xxx&quot;)  # \n\n修改源码增加需求粒度# ---------models.pyclass Department(models.Model):      &quot;&quot;&quot;部门表&quot;&quot;&quot;      title = models.CharField(verbose_name=&quot;标题&quot;, max_length=32)  \t# 前端显示的时候，类的输出打印    def __str__(self):          return self.title# ---------views.pyclass UserModelForm(forms.ModelForm):      class Meta:          model = models.UserInfo          fields = [&quot;name&quot;, &quot;password&quot;, &quot;age&quot;, &quot;department&quot;]  \t# 遍历所有插件，都增加一个属性class:form-control    def __init__(self, *args, **kwargs):          super().__init__(*args, **kwargs)            for name, field in self.fields.items():              print(name, field)              field.widget.attrs = &#123;&quot;class&quot;: &quot;form-control&quot;&#125;def user_model_form_add(request):    if request.method == &quot;GET&quot;:        form = UserModelForm()        return render(request, &quot;user_model_form_add.html&quot;, &#123;&quot;form&quot;: form&#125;)    form = UserModelForm(data=request.POST)    if form.is_valid():        form.save()        return redirect(&quot;/user/show/&quot;)    else:        return render(request, &quot;user_model_form_add.html&quot;, &#123;&quot;form&quot;: form&#125;) # 发生错误时，把用户数据返回，同时form中也有错误返回\n\n\ndjango的静态资源管理系统–Media\n# ---------------urls.pyfrom django.urls import path,re_path  from django.views.static import serve  from django.conf import settingsre_path(r&#x27;^media/(?P&lt;path&gt;.*)$&#x27;, serve, &#123;&#x27;document_root&#x27;: settings.MEDIA_ROOT&#125;, name=&quot;media&quot;),# ---------------settings.pyimport osMEDIA_ROOT = os.path.join(BASE_DIR, &quot;media&quot;)  MEDIA_URL = &quot;/media/&quot;\n手动上传：手动去声明file对象，拿到file对象，任意处理（具体文件操作还是手动）\nform组件：有表单验证，拿到file对象，任意处理（具体文件操作还是手动）\nModelForm组件：有表单验证，file对象自动保存，同名自动处理\n\n要求配置media文件夹\n定义model时，声明类型为FileField，填写upload_to参数\n\n","categories":["学习记录"],"tags":["django"]},{"title":"【入门】docker","url":"/2023/05/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91docker/","content":"Docker不是一项新技术，而是虚拟化技术发展中的一个产物，Docker是容器化技术中较为主流的一个方案，同时也是一种轻量级的虚拟化。 \nDocker中主要的三个概念分别是dockerfile image container，了解这三者的工作机制就能掌握Docker大部分知识。如果只是简单的（不严谨的）类比的话，可以将dockerfile理解为源代码，image是由源代码编译而来的可执行文件，container就是可执行文件运行起来的进程。所以，只有足够了解自己开发的项目的工作流程和需求，你才能编写出明确的dockerfile，从而流畅优雅地使用docker。\n至于网络上有种说法，build once, run everywhere，这是不准确的的。docker的底层是建立在linux kernel提供的诸多特性上的，在非linux平台上工作时更是如此。所以只要我们的项目不涉及docker底层的工作机制，那么也可以相对来说是，build once, run everywhere。反之出现问题，大抵可以归咎于docker没有做好对各个操作系统的兼容性。\n","categories":["学习记录"],"tags":["docker"]},{"title":"【学习记录】git","url":"/2022/11/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91git/","content":"简介git是一个开源的分布式版本控制系统Distributed Version Control System - DVCS），用于敏捷高效地处理任何大小的项目，是Linux Torvalds为了帮助管理Linux内核开发的一个开放源码的版本控制系统，来源颇有趣味，建议上网查看版本控制工具简介\n一般我们学git，主要是学如何使用git的各个指令来管理自己的文档的各个版本，以及在团队协作中如何同步。\n安装gitgit目前支持Linux/Unix、Solaris、Mac和Windows平台上运行，git各平台安装包下载地址\ngit工作逻辑在分布式版本控制中，git处理最基本的就是一个版本节点，也就是git commit所提交的东西。大部分指令都是围绕这个展开的，比如分支的处理。这里推荐阅读Git 原理详解及实用指南 - 扔物线 - 掘金小册 (juejin.cn)\ngit指令和常见问题解决这里就不重复记录git的各种指令，推荐阅读前端 - 三年 Git 使用心得 &amp; 常见问题整理 - 民工哥技术之路 - SegmentFault 思否\ngit原理探究对于git本身是如何实现的以及关键机制的讨论，推荐Pro Git 简体中文版 (iissnan.com)\n","categories":["学习记录"],"tags":["git"]},{"title":"【学习记录】svn","url":"/2022/11/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91svn/","content":"SVN(Apache Subversion)是一个开源的版本控制系统，TortoiseSVN是subversion版本控制系统的一个免费开源客户端，可以超越时间地管理文件和目录。下载该软件到电脑上（以windows系统为例），快速上手的步骤有如下几个：\n拉取Repository到本地\n在你的工作目录空白处，右键选择SVN Checkout\n填写版本库的位置URL\n填写Checkout Directory，指向你的工作目录\n按下OK按钮（综上，您就能在一个已经存在的SVN Server上面checkout其中的数据，只需要正确的SVN URL和检出目录，以及相应的权限即可）\n\n新增档案｜目录到Repository\n分add和commit两个操作\n前者是在本地新建文件｜目录后，右键Checkout直接点击OK，这时文件会被添加到本地的存储空间，只是处于就绪状态。\n右键空白处，选择SVN commit，在出现的窗口中勾选你想要的正式放到repository到文件｜目录，并填写说明即可\n注：由于中央式的版本管理只有中央仓库一个仓库，所以commit直接将改动提交到了中央仓库\n\n更新文件｜目录\n空白处右键选择SVN Update 或者 选中文件｜目录右键选择TortoiseSVN-&gt;Update to reversion\n\n复制文件｜目录的分支 branch\n在trunk目录空白处（或者选中trunk目录）右键选择Tortoise SVN-&gt;Branch/Tag\n选择分支的目标路径，按下OK\n再到原来工作目录下空白处，右键选择SVN Update，就可以看到新增的分支内容了\n\n合并\n在branch分支中增｜删｜改了之后，要merge回trunk目录中，在**trunk**目录空白处，右键选择TortoiseSVN-&gt;Merge，填写参数点击确定即可\n\n制作Tag｜Release所谓Tag或者Release就是一个特别的版本，但在SVN的概念里也只是一个目录而已，所以操作和新增branch大致相同\n\n新建目录（要特别一些，比如xx/tags/v1.0或者xx/release/v1.0）\n在trunk目录空白处，右键选择Tortoise SVN-&gt;Branch/Tag，填写路径，同时勾选“切换工作副本至新分支&#x2F;标记”，点击OK\n到新路径下，SVN Update后就可以看到内容了\n\n进一步了解svn的使用和工作机制，可以看如下几个博客：\nSVN详细使用教程 - 知乎 (zhihu.com)\n从入门到精通：详解SVN版本控制系统的使用方法 - 知乎 (zhihu.com)\n文章二：分支管理策略 - “分支战争：优雅地使用SVN分支” - 知乎 (zhihu.com)\n","categories":["学习记录"],"tags":["svn"]},{"title":"【学习记录】《JavaScript权威指南》","url":"/2023/06/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E3%80%8AJavascript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/","content":"hello,javascript!1995年，javaScript作为网景的Netscape Navigator 2的脚本语言问世（当时java正火，取名蹭蹭热度）。网景的成功促使微软在其后不久发布了IE3，其中包含自己名为JScript的javaScript实现。混乱随之而来，故于1997年javaScript1.1作为提案提交给了欧洲计算机制造商协会（**Ecma），并由第39技术委员会（TC39）花费数月打造了一套脚本语言标准**ECMA-262，被称为ECMAScript\nJavaScript是一门高级、动态、解释型编程语言，不仅在web世界发挥着巨大的作用，如今也具有了后端开发的功能。严格来说，JavaScirpt由ECMAScript、DOM、BOM三部分组成，各主流浏览器也对这三部分有不同程度的支持，也正是如此，才有如今活跃的JavaScript技术氛围。\n词法结构编程语言的词法结构是一套基本规则，规定了如何使用这门语言编写程序，它是一门语言最低级的语法，规定了变量如何命名、注释的定界符，以及如何分隔程序的语句，等等。\nJavaScript程序的文本JavaScript特点：\n\n区分大小写\n忽略程序记号（token）之间的空格、大多情况也忽略换行符（JavaScript除了常规空格\\u0020，其将制表符、各种ASCII控制符和Unicode间隔识别为空格；同时将换行符、回车符和回车&#x2F;换行序列识别为行终止符。）\n\n注释// 单行注释/* 也是注释 *//* * 这是多行注释 * 每行（除了首尾行）的开头额外的*只是为了美观 */\n\n字面量定义：直接出现在程序中的数据值，如下\n12        // 数值字面量&quot;hello&quot;   // 字符串字面量true      // 布尔字面量null      // 无对象\n\n标识符和保留字标识符就是一个名字，一般用于命名变量、属性、函数等等。JavaScript标识符必须以字母、下划线（_）或美元符号开头，后续字符可以是字母、数字、下划线或美元符号。\n保留字是为语言自身使用的，不能作为常规标识符使用。\nUnicodeJavaScript程序是使用Unicode字符集编写的，因此在字符串和注释中可以使用任意Unicode字符。\nUnicode转义序列JavaScript定义了转义序列，可以仅使用ASCII字符来表示Unicode字符。规定转义序列以\\u开头，后面跟4位十六进制或包含在一对花括号内的1~6位十六位进制。\n理论上，转义字符可以出现在程序的任意位置，只不过要注意两点，一是不推荐用在标识符中，二是用在注释里是不会被解释为Unicode的\nUnicode归一化：Unicode本身允许多种编码方式标识同一个字符，但这样会导致看上去相同，但是更为底层的对应的二进制编码不同，从而导致JavaScript认为这两个字符不同，这就可能会导致异常。Unicode标准为所有字符定义了首选编码并规定了归一化例程，用于把文本转换为适合比较的规范形式。\n可选的分号JavaScript使用;分隔语句。使用时需要注意，若没有分隔符，一条语句的末尾可能是下一条语句的开头，同理反之亦然。\n省略分隔符的情况：\n\n两条语句分别写在两行\n程序末尾接下来的记号是右花括号\n\nJavaScript只有在下一个非空格字符无法被解释为当前语句的一部分时才把换行符当作分号。也要注意( [ / + -都可能会被解释为之前语句的一部分。\n类型、值和变量计算机程序通过操作值或文本来工作，编程语言中这些可以表示和操作的的值被称为类型，而一门语言支持的类型集也是这门语言最基本的特征。\n概述和定义JavaScript的类型可以分为：\n\n原始类型：数值、字符串、布尔值、null、undefined、&#96;symbol\n\n对象类型：任何不是原始类型的值\n\n\nJavaScript的对象类型是可修改的mutable，原始类型的是不可修改的immutable\n数值JavaScript使用IEEE 754标准定义的64位浮点格式（一种二进制表示法）表示数值。\n全称数值字面量number literal，分整数字面量、浮点字面量\n123              //=&gt; 1230xff             //=&gt; 255 (15*(16**1) + 16*(16**0))0o377            //=&gt; 255 (3*(8**2) + 7*(8**1) + 7*(8**0))0b10101          //=&gt;21 (1*(2**4) + 0 + 1*(2**2) + 0 + 1*(2**0))3.14             //=&gt; 3.14.33              //=&gt; 0.336.02e23          //=&gt; 6.02 x 10^231.43E-12         //=&gt; 1.43 x 10^(-12)//分隔符（下划线）的使用，将字面量分隔以容易看清let number = 1_000_000_000let bytes = 0x3a_38_9flet bits = 0b0001_1101_0111let fraction = 0.123_345_353   // 每隔三位分隔一次只是约定俗成NaN              //=&gt; Not a number 非数值Infinity         //=&gt; 无穷值 （上溢出）-0               //=&gt; 负零值 比最小可表示数值 更为 接近0 （下溢出）0                //=&gt; 常规的0/* * 负零值和正零值（严格）相等，即 0 === -0 为 true，除了作为除数使用，几乎无法区分这两个值 * NaN与任何值比较都不相等，包括它自己 * 不能通过 x === NaN 的方式判断是否为NaN * Number.isNaN() 可以用于判断数值是否为NaN，也适用于参数为NaN（返回True） */let x = .3 - .2;let y = .3 - .2;x === y;         //=&gt; false JavaScript中也存在这种问题，所以尽量避免去比较类似的情况/*  * 在字面量后跟小写字母n，表示BigInt字面量(ES2020新增)  * 默认基数是10，可以通过前缀来表示其他进制 */1234n            0b111111n0o723n           1000n / 330n     //=&gt; 3n 只有 / 运算会舍弃余数并向下取商，其它运算和常规JavaScript类似1000n + 123      //   JavaScript不允许BigInt操作数和常规JavaScript操作数混用，0 === 0n         //=&gt; false 但比较远运算符例外\n\n文本JavaScript中表示文本的类型是String，即字符串。字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。字符串的length属性是它包含的16位值的个数。\n/* * 有些超出16位范围的Unicode字符（surrogate pair “代理对”），就需要长度为2的JavaScript字符串来表示了 * 以此类推，JavaScript字符串的操作方法，一般操作的都是16位值，而不是字符 */`abc`&quot;abc&quot;&#x27;abc&#x27;        //   JavaScript中单引号、双引号和反引号(ES6新增)，都可以用来包含字符串字面量             //   JavaScript将换行符、回车和回车 `/`换行序列识别为行终止符let name = &quot;handong&quot;;let s = `hi! $&#123;name&#125;`;/* * 模板字面量  * $&#123;表达式&#125;  /String.raw`\\n`.length  //=&gt; 2 非常特殊的情况下，反引号`可以充当函数括号/* * 一对斜杠之间的文本构成正则表达式字面量（RegExp） * 这对斜杠的第二个后面还可以跟一个或多个字母，用于修改模式的含义 *//^HTML/;      //   匹配字符串开头的字母HTML\n\n布尔值这个类型只有两个值：ture和false\n/* * JavaScript中的任何值都可以转换为布尔值，或者当成布尔值使用，称为假性值falsy、真性值truthy * false: undefined null 0 -0 NaN 空字符串 * true: 除了false的所有其他值 * 唯一的API: toString() 将自己转换为字符串&quot;true&quot;或&quot;false&quot; */\n\nnull和undefinednull是一个语言关键字，可以看成该特殊类型的唯一成员，是一种特殊对象，用于表示一个值不存在。undefined也表示值不存在（更深层次的不存在），可以说，变量的值未初始化时就是undefined，也视为该特殊类型的唯一成员\n符号符号 是ES6新增的原始类型，符号没有字面量语法，只能通过Symbol()函数创建，其接受一个字符串参数，返回一个唯一的符号值\n实践中，通常作为一种语言拓展机制，之后再了解\n对象/* * 全局对象： * 全局对象的属性是全局性定义的标识符，可以在JavaScript程序的任何地方使用 * JavaScript解释器启动后（或每次浏览器加载页面），都会创建一个新的全局对象并初始化一组属性 * ES2020最终定义了globalThis来作为引用全局对象的标准方式 *  * 对象有时候被称为引用类型（reference type），以区别于JavaScript的原始类型 * 对象值就是引用，对象的比较就是按引用比较的，引用同一个底层对象才视为相等 */ \n\n类型转换/* * JavaScript会根据需要把你提供的值转为布尔值，但有时也会转换为字符串、数字或NaN * | 你提供的值 | 转换为字符串 | 转换为数值 | 转换为布尔值 | * 更多内容见《JavaScript权威指南 李松峰译 原书第七版》p44 *  * == 会在比较之前按需进行类型转换，但绝不会将操作数转换为布尔值  * 可以用函数显示转换，比如Boolean() Number() String() 等等 *  * 对象转换为原始类型：p49（比较繁琐和细节）  */\n\n变量的声明与赋值/* * JavaScript的标识符的命名：首字母必须以字母、`_`或`$`开头，后续字符可以是字母、数字、下划线或美元符号 * 常量用`const`声明，变量用`let`声明 * const 必须在声明时初始化常量，前后续不可更改（否则引起TypeError） *  * 解构赋值：let [x,y] = [1,2];  //=&gt; x = 1, y = 2  *          两侧的变量和值数量不等时，要么被忽略，要么被设置为undefined *          左侧的变量列表中，可以包含额外的逗号，以跳过右侧的某些值 *          把右侧未使用或剩余的收集，就在左侧的最后一变量名前加上三个点... *          支持嵌套解构 *          右侧值的类型数组、字符串、对象都适用 *          当右侧为对象时，左侧的变量名则会自动和对象的属性名对应（否则被设置为undefined）。当然，这样就局限了变量的命名，所以可以在属性名后加上冒号，填写自定义的变量名 *           */ const &#123;cos: myCos, sin: mySin&#125; = Math; //=&gt;const myCos = Math.cos, mySin = Math.sin;\n\n表达式与操作符主表达式（primary expression）定义：独立存在，不再包含更简单的表达式的表达式\n1.23&quot;abc&quot;/^some/      // 字面量truefalsenullthis         // 保留字isumundefined    // 变量、常量、全局对象属性的引用\n\n对象和数组初始化程序也属于表达式，但不是主表达式\n[][1,3][[1,2],[3,,3]]let a = &#123;x:1,y:3&#125;let b = &#123;&#125;// 这些初始化程序，有时也称 数组字面量、对象字面量\n\n函数定义表达式let f = function(x)&#123;return x*x;&#125;;    // 关键字function 参数列表 函数体 （匿名函数例外）\n\n属性访问表达式/*  * expression . identifier * expression [ identifier ] * 句点 中括号 前面的表达式都会先求值，若为null | undefined，则抛出TypeError */x.posarr[0]dic[&quot;name&quot;]    /* * ES2020 新增两种属性访问表达式 * expression ?.  identifier * expression ?.[ identifier ] * 这两种表达式，当前面的表达式为null | undefined 时，返回undefined */\n\n调用表达式/*  * expression([args,,,])    中括号部分为可选内容 * 括号前面的表达式都会先求值，若不为函数（包括null undefined的情况），则抛出TypeError * 要么为函数体return的值，要么为undefined */f(3)Math.max(5,9,10);/* * ES2020 新增条件式调用表达式 * expression ?.() * 仅当 前面的表达式为null | undefined 时，不执行函数，返回undefined */\n\n对象创建表达式new Object()new Pos(3,3)    // 自动执行对象的构造函数来初始化\n\n操作符具体表格见《JavaScript权威指南–李松峰译–书第七版》p66左值：一个可以合法地出现在赋值表达式左侧的表达式JavaScript中，变量、对象属性和数组元素都是“左值”\n算术表达式//《JavaScript权威指南--李松峰译--书第七版》p70// 相关细节很多，建议看书\n\n关系表达式/* 严格相等 === * 两个值类型不同                               =&gt; false * 两个值都为null，或都为undefined              =&gt; true * 两个值中有NaN(1或2个)                        =&gt; false * 两个值都是数值且值相等                       =&gt; true * 0 = -0                                      =&gt; true * 两个值都是字符串且相同位置的16位值完全相同    =&gt; true * 两个值都是引用的同一对象、数组或函数          =&gt; true *  * 不满足的严格相等的， !== 就为true *//* * 基于类型转换的相等 == * 如果两个值的 类型不同，它会尝试做类型转换 * 如果两个值的 类型相同（本来就相同 或 转换后相同），它会按照严格相等来进行比较 * 类型转换细则(下面的?表示代指，无意义)： *     特殊：null == undefined   =&gt; true *  *     ?  == 字符串   --&gt;  ? == 数值 *     ?  == true     --&gt;  ? == 1 *     ?  == false    --&gt;  ? == 0 *     ?  == 对象     --&gt;  ? == 原始值 *  * 关于对象如何转换为原始值： *     JavaScript会尝试使用对象内的toString()方法，或者使用valueOf()方法 *     通常一般的对象都会优先使用valueOf()，但Date类是例外，它优先执行toString() *     前者失败（或不存在该方法）后，再考虑toString() | valueOf() *  * 不满足基于类型转换的相等的， != 就为true *//* * 比较操作符 * 只能比较数值和字符串（若不是则会进行转换，再比较 *  * JavaScript字符串是16位整数值的序列，而字符串比较是比较两个字符串的数值序列 * Unicode定义的数值编码顺序会受不同地区和特定语言使用的传统 校正顺序（collation order）匹配 * 不同地区比如不同国家 * 特定语言，比如ASCII，它的 大写字母的数值 排在 小写字母前（这样的话 Z &gt; a 反而成立） * 可以考虑String.localeCompare() *  * = 和 &lt;= 不依赖于之前的等于比较符，仅代表 &gt; 或 &lt; 相反情况的 *//* * in 操作符 * in期待左侧是可以转换成字符串的任何值，右侧是对象 */let data = [1,3]&quot;0&quot; in data        //=&gt; truelet pos = &#123;x:1,y:2&#125;x in pos           //=&gt; true/* * instanceof 操作符 * 左侧操作数为对象，右侧操作数是对象类的标识 * 当左侧的对象 是 右侧类 的 实例 时，返回true，否则为false *  */ let d = Date() d instanceof Date    //=&gt; true\n\n逻辑表达式/* * &amp;&amp; * 总是返回真值或假值（注意，这个范围很大） * 它不要求左右两侧操作数为布尔值（比如真/假性值），也并不总是返回true或false *  * 当左侧操作数为假值，右侧操作数不会被求值，返回左侧的操作数的值 * 当左侧操作数为真值，返回右侧操作数 *  * || 同上（相反） */ &quot;a&quot; &amp;&amp; &quot;b&quot;    //=&gt; &quot;b&quot; &quot;a&quot; &amp;&amp; 0      //=&gt; 0 /* * ! 逻辑非 * 总是返回布尔值：true或false */\n\n赋值表达式a = 1         // 普遍情况a = b = c = 1 // 连续赋值的简写/* * 拼接操作符 * += -= **= 等等 * 唯一不同的是，拼接后，左操作数只会被求值一次，而原来会被求值两次 * 这可能会带来负效应 */ a[i++] += 1        a[i++]  = a[i++] + 1 \n\neval操作符（也是函数）：相关细节见p84\n其它操作符：\n/*  * 条件操作符：  * ?:  * expr1 ? expr2 : expr3 * expr1 为true时，返回expr3，否则返回expr3 */ let s = &quot;hi,&quot; + (name ? name : &quot;there&quot;)/*  * 先定义（first-defined）操作符 * ES2020新增，正式名为缺值合并（nullish coalescing）操作符 * ?? * expr1 ?? expr2 * 只有在expr1 为null或undefined时 才会返回第二个操作数 */ /*  * typeof 操作符，总是返回如下值 *     &quot;undefined&quot;  *     &quot;object&quot; *     &quot;boolean&quot; *     &quot;number&quot; *     &quot;bigint&quot; *     &quot;string&quot; *     &quot;symbol&quot; *     &quot;function&quot; */ typeof null    //=&gt; &quot;object&quot;: 所以要区分对象和null，需要显式测试/* * delete 操作符 * 删除对象属性（包括数组元素），将属性设置为undefined的同时，该属性也不存在了 */ let a=[1,3,3] delete a[2]    // 删除数组最后一个元素 a.length       //=&gt; 3:长度不变/* * await 操作符 * ES2017新增，期待一个Promise对象作为唯一操作数 * 只能出现在已经通过async关键字声明为异步的函数中 *//* * void 操作符 * 它可以放在任意类型的操作数前面，求值这个操作数，返回undefined */ let i = 0; const f = () =&gt; void i++; f();    //=&gt; undefined i       //=&gt; 1/* * , 逗号操作符 * 求值左侧操作数然后丢弃，再求值右侧操作数并返回 */\n\n语句JavaScript程序就是一系列语句，以分号分隔\n表达式语句定义：有副效应的表达式\ni++;      // 赋值表达式myFun();  // 调用表达式\n\n复合语句和空语句i++,j++,c++;    // 复合语句&#123;  i++;  j++;  c++;          // 语句块，也是复合语句&#125;;               // 空语句\n\n条件语句if(expr) \tstatement;    // expr为真值，则执行statement；反之// 可选// else if (expr2) &#123;statement1;statement2;&#125;// else &#123;statement3;statement4;&#125;switch(expr)&#123;\tstatement;\t// 可选\t// case expr1:\t//     statement2;\t//     break;\t// default:\t//     statement3;\t//     break;&#125;                 // 其中case的使用，是以===来判断相等的，这个例子里是比较expr===expr1\n\n循环语句while(expr)&#123;\tstatement;&#125;do\tstatement;while(expr)for(init; test; increment)\tstatement;// ES6新增 for/of 专门用于可迭代对象（与for关键字完全不同）let myArr = [1,3,4,5,];for(let element of myArr)\tstatement;                  // 数组属于可迭代对象let myStr = &quot;abcdefg&quot;;          // 字符串是按 码点 迭代的，而不是16位值let myObj = &#123;x:1,y:2,z:3&#125;;      // 对象默认不可迭代\t\t\t\t\t\t\t    // 需要用Object.keys()、Object.values()或Object.entries()let mySet = new Set([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]);let myMap = new Map([[1,&quot;one&quot;],[2,&quot;two&quot;]]);// ES2018新增 异步迭代器 和 异步迭代器的for/await循环async function myFun(str)&#123;\tfor await(let s in str)&#123;\t\tconsole.log(s);\t&#125;&#125;// for/in循环 适用于任意对象，循环指定对象的属性名for(variable in object)\tstatement;/* * javascript首先对object求值，若为null 或 undefined则会跳过循环，执行下文语句 * 但并不会枚举对象中的所有属性，比如符号类的不可枚举等等 */\n\n跳转语句/* * 常见的continue break return throw yield  * 它们都具有跳转功能，让JavaScript解释器跳转到新的代码位置 */// 语句标签，给语句起个名字，可以在程序的其它地方通过这个名字引用它// 标签 和 变量与函数 不在同一个命名空间identifier: statement;// break 只在循环和switch中使用，达到跳出的作用，// break 后可以接语句标签，达到跳出后，跳转到该语句标签的作用// return 只在函数体中使用，返回的值作为函数的值，若没有则为undefined// yield 之用在ES6新增的生成器函数中// 它非常类似return，详见第12章（迭代器和生成器）// throw 抛出异常，可用try/catch/finally捕获// try/catch/finally JavaScript的异常处理机制try&#123;&#125; catch(e)&#123;// ES2019 可以省略 (e)&#125;finally&#123;&#125;\n\n其他语句// with 用于创建临时作用域// 基本被废弃，不推荐使用with(object)\tstatement;// debugger 像一个断点，执行时JavaScript会停止，我们可以查看调用栈等信息&#x27;use strict&#x27;    // 属于 指令（和语句很相近）\t\t\t\t// 具体作用见p115\n\n声明（看起来很像语句，一并介绍）\n/* * const let var function class import export 这些关键严格来讲都是声明 */const     // 声明常量let       // 声明变量var       // ES6之前唯一的声明变量方式function  // 用于定义函数/* * class 用于创建一个新类 * 注意，类不会被“提升”，不能在类被声明之前使用它 */class myClass&#123;\tconstructor(init1)&#123;this.init1=init1&#125;  // 构造函数\tstatement;&#125;/* * import  * 每一个js文件都是一个模块，之间完全无关， * import可以将其他模块的值导入，从而可以使用其他模块的值 *  * export * 每一个js文件中的值都是 私有的，除非被显式导出，否则其他模块无法导入 */// index.jsimport &#123;xx,yy&#125; from &#x27;./xyz.js&#x27;// xyz.jsconst xx = 1;const yy = 2;export &#123;xx,yy&#125;;\n\n对象对象是一个 属性的无序集合，每个属性都有名字和值 和 三个属性特性（property attribute）\n\n可写（writable）\n可枚举（enumerable）\n可配置（configurable）\n\n创建对象let myDict = &#123;&#125;                         // 通过字面量创建 let o = new Object()                    // 通过new关键字创建/* * 几乎所有对象都有 原型，但只有少数对象有prototype属性。 * 正是这些有prototype属性的对象为所有其他对象定义了 原型 * Object.prototype是为数不多的没有原型的对象 */let o1 = Object.create(&#123;x:1,y:2,z:3&#125;)   // 通过Object.create()创建\n\n查询和设置属性o.propertyo.[&quot;property&quot;]   // 要求方括号中是字符串或可以转换成字符串的值/* * JavaScript的对象可以视为 关联数组，可以动态添加属性 *//* * JavaScript的对象支持继承，参考“原型链”的概念 * 同时，JavaScript只在查询时会用到原型链，而设置属性时不影响原型链 */let myName = class?.student?.name    // 访问属性时，                                     // 对象为null或undefined时，报错TypeError                                     // 属性不存在时，返回undefined                                                                          // 同理，设置属性时，                                     // 对象为null或undefined时，报错TypeError                                     // 以及对象不允许添加新属性时，也会报错                                     // 还有其他较复杂的情况，参考p128\n\n删除属性// delete 情况同上 见p128\n\n测试属性in hasOwnProperty()propertyIsEnumerable()!= undefined                    // 都可以用来判断某对象是否含有某属性\n\n枚举类型for/inObject.keys() + for/ofObject.getOwnPropertyNames()Object.getOwnPropertySymbols()Object.ownKeys()                // 都可以用来枚举对象的属性\n\n拓展对象// 方式一：手动设置属性// 方式二：ES6新增 Object.assign()\n\n序列化对象(serialization)定义：把对象转为字符串，之后可以从中恢复对象的过程\nJSON.stringify()  // 序列化JSON.parse()      // 恢复                  // JSON是Javascript语法的子集，有些对象是不支持的\n\n对象方法toString()valueOf()toLocaleString()toJson()           // 可以由JavaScript本身提供，也可以自己去重写或新增\n\n对象字面量拓展语法（ES6新增）\n// 属性名和变量名一样，可以简写let x=1,y=2let o = &#123;x,y&#125;   // o.x=1 o.y=2// 计算的属性名 动态的计算出属性名 以下是一个通过代码来设置版本的例子const PROPERTY_NAME=&quot;version&quot;function computePropertyName(s)&#123;return s + &quot; &quot; + PROPERTY_NAME&#125;let o = &#123;\t[PROPERTY_NAME]:0.1,\t[computePropertyName(&quot;dev&quot;)]:0.2&#125;\n\n符号作为属性名// 接上，该拓展语法也可用于符号类属性const extensionProperty = Symbol(&quot;my extension symbol property&quot;);let o = &#123;\t[extensionProperty]: &#123;/*你的数据*/&#125;&#125;o[extensionProperty].x = /*你的值*/ // 这样的话，这种属性就不会和当前的任何属性冲突了\n\n拓展操作符// ... 三个点，当用于字面的对象时，可以起到这样的作用，所以称为“拓展操作符”// 但放在其它场景的作用会完全不同let o1 = &#123;x:1,y:2&#125;let o2 = &#123;z:3,p:5&#125;let o3 = &#123;...o1, ...o2&#125; //=&gt; o3 = &#123;x:1,y:2,z:3,p:5&#125;// 注意性能，单次拓展属性O(n)，循环则是O(n^2) !!!\n\n简写方法（属性）let o = &#123;\tarea: function()&#123;return 0;&#125;, // 简写 area()&#123;return 0;&#125;&#125;o.area() //=&gt; 0// 支持符号、计算的属性名const extensionProperty = Symbol(&quot;my extension symbol property&quot;);let o2 = &#123;\t[extensionProperty]()&#123;/*你的函数体*/&#125;,&#125;\n\n属性的获取和设置方法（ES5引入，ES6支持字面量拓展）：\n/* * JavaScript还支持为对象定义 访问器属性（accessor property） * 这种属性不是值，而是多个访问器方法 * 获取方法：getter * 设置方法：setter *  * 当访问一个对象的属性时，就会调用对应的获取方法；对应的，设置属性值，调用设置方法 * 若没有设置方法，则该属性不可写；对应的，若没有读取方法，则该属性不可读；都有，则可读写 *  * 只需要在属性前加上set 或 get，然后跟定义方法属性一样 * 支持符号和计算的属性名 */let o = &#123;\tx:1,\t\tget p1()&#123;return this.x&#125;,\tset p1(x)&#123;this.x = x;&#125;,\tget p2()&#123;/**/&#125;,\t// 可以有多个，也可以没有&#125;;o.p1      //=&gt; 1o.p1(5)   //=&gt; o.p1 = 5\n\n数组数组可以看成特殊的对象，只不过属性名刚好是整数，也正是该特性让其访问起来效率比一般的对象更高ES6推出了定型数组（typed Array），要求固定长度和固定数值元素类型。它性能极高，支持二进制可访问字节级的数据\n创建数组/* * 数组字面量 * 逗号之间没有元素，就是稀疏数组，访问该位置返回undefined * 可以嵌套 * 元素类型可以不一样，甚至可以是表达式 */let a = [1,,,3,]/* * 对可迭代对象使用...拓展符(ES6新增) * 用来包含另一个数组（字符串或集合等可迭代对象）的所有元素 * 实质是使用for/of，迭代元素并创建（浅）副本 *  *  (忽略该数组最后一个元素后的逗号）当包含[1,2,]或[1,2]效果是一样的 */let b = [5,...a,7]      // =&gt; b = [5,1,,,3,7]let c = [...new Set([...&quot;hahaha&quot;])]  // =&gt; c = [&#x27;h&#x27;,&#x27;a&#x27;]：包含了字符串、集合以及去重等示例/* * Array()构造函数 */let d = new Array()let e = new Array(10)       // 指定长度为10的数组（此时，甚至索引0,1,2等都没有定义）let f = new Array(&quot;1&quot;,&quot;2&quot;,&quot;a&quot;,1,4)let g = new Array(...&quot;abc&quot;) // =&gt; g = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]/* * 工厂方法Array.of() */let h = Array.of(1)         // =&gt; h = [1]:\t\t\t\t\t\t    // 弥补了Array()不能创建只含有一个数值元素的数组的缺陷\t\t\t\t\t\t    // 其余功能和Array()构造函数一样/* * 工厂方法Array.from() * 第一个参数：可迭代对象 或 类数组对象 *     当为可迭代对象时，同... *     当为类数组对象（有length属性，每个属性的键也是整数），作用是创建真正的数组副本 * 第二个参数：函数 *     把前者的每一元素传给这个函数，函数的返回值为新数组的元素 *     （推荐在构建数组时就处理好，而不是用这个函数） */\t\t\t\t\t\t    let i = Array.from(h)       // =&gt; i = [1] \n\n读写数组元素/* * 使用 [] 访问数组元素，方括号左侧是数组的引用，方括号中是非负整数 *  * 数组是一种特殊的对象，用方括号访问数组元素和用方括号访问对象属性是类似的 * JavaScript会把数组索引（整数）转为字符串，作为属性名 * 数组所有索引都是属性名，但只有介于0~2^32-2之间的整数属性名才是索引 * 可以给数组新建不属于索引范围内的属性名，比如a[-10]=9 =&gt; &#123;&quot;-10&quot;:9&#125; *  * 数组长度由JavaScript内部自动维护，只对索引有效，其他属性名不会被统计在内 */let a = [...&quot;abc&quot;]a[1]                  // =&gt; &#x27;b&#x27;a[1] = 3a[1]                  // =&gt; 3\n\n稀疏数组/* * 即使中间含有多个undefined元素，长度仍以最高索引为准 */let a = [,]         // =&gt; a没有元素，但a.length=1，且此时索引都没有被定义 0 in a = falselet b = [undefined] // =&gt; a有一个元素undefined，且a.length=1，索引被定义了 0 in b = true\n\n数组长度/* * 任何情况，数组索引都不会大于或等于数组长度 * 可以修改数组length属性： *     要么删除所有等于或大于length的索引对应的数组元素 *     要么在末尾增加一堆的undefined */\n\n增加&#x2F;删除数组元素/* * 主要注意，是否会修改length，以及元素的值和索引的变化 */let a = []a[0] = 1         // =&gt; a = [1]                 //    a.length=1a.push(&quot;a&quot;,&quot;b&quot;)  // =&gt; a = [1,&#x27;a&#x27;,&#x27;b&#x27;]                 //    a.length=3a.pop()          // =&gt; 返回&#x27;b&#x27;                 //    a=[1,&#x27;a&#x27;]                 //    a.length=2a.unshift(&quot;c&quot;)   // =&gt; a = [&#x27;c&#x27;,1,&#x27;a&#x27;]                 //    a.length=3a.shift()        // =&gt; 返回&#x27;c&#x27;                 //    a=[1,&#x27;a&#x27;]                 //    a.length=2 delete a[1]     // 删除索引2（也意味着删除了数组元素）                 // a=[1,undefined]                 // a.length=2 不影响数组长度\n\n迭代数组let arr = [...&quot;abc&quot;];/* * for/of * forEach() * 除了用法不一致，两者对稀疏数组的处理不一样： *     前者对稀疏数组无感，若不存在便会得到undefined，后者则不会对undefined调用函数 */for(let i of arr) console.log(i);// 数组提供的一种用于自身迭代的函数式方法：forEach// 它接收一个函数作为参数，数组的每一个元素都会调用这个函数arr.forEach(i =&gt; &#123;console.log(i);&#125;)、// 老式的for循环 for(let i=0, len=arr.length; i&lt;len; i++)&#123;/*循环体*/&#125;\n\n多维数组JavaScript不支持真正的多维数组，只能通过数组的数组来模拟。\nlet t = new Array(10)// 循环建立二维数组for(let i = 0; i &lt; t.length; i++)&#123;    t[i] = new Array(10)&#125;// 循环赋值数组for(let i = 0; i &lt; t.length; i++)&#123;    for(let j = 0; j &lt; t[i].length; j++)&#123;        t[i][j]=i*j    &#125;&#125;// 访问二维数组t[1][5] // =&gt; 5\n\n数组方法操作数组的基本语法，主要涉及Array类定义的方法，不同点在于有的方法会修改调用他们的数组，有的则返回新数组或者只是引用。\n迭代器方法迭代器方法是一类方法的总称，这类方法用于迭代数组元素，按顺序把数组的每个元素传给调用者提供的方法，对数组元素进行操作。\n该类方法的特点是都接收一个函数作为第一个参数，对数组的每个元素（稀疏数组中不存在的元素除外）都调用这个函数，该函数被调用时会被传入三个参数，分别为数组元素的值、数组元素的索引和数组本身。\n（不常用）该类方法可选接收第二个参数，作为第一个参数传入的函数的内部this值。\nlet data = [1,2,3,4,5], sum=0// forEach()// 唯一要注意的是该方法没有提供终止迭代的方式data.forEach(value =&gt; &#123;sum+=value&#125;) // =&gt; sum==15// map()// 返回作为第一个参数的函数的返回值构成的数组。对于稀疏数组，则同样返回稀疏数组data.map(x=&gt;x*x) // =&gt; [1,4,9,16,25]// filter()// 返回调用它的数组的子数组。传入的第一个参数必须是一个断言函数，返回断言为true的值组成的数组// 返回的始终是稠密数组，即跳过缺失元素data.filter(x=&gt;x&lt;3) // =&gt; [1,2]// find()// 同样传入一个断言函数，在找到第一个断言为true的元素后返回 匹配的元素 并停止迭代，若没找到则返回undefineddata.find(x=&gt;x===3) // =&gt; 3// findIndex()// 同样传入一个断言函数，在找到第一个断言为true的元素后返回 元素的索引 并停止迭代，若没找到则返回-1data.findIndex(x=&gt;x===3) // =&gt; 2// every() 和 some()// 被称为 数组断言方法，相当于离散数学中的集合的 全称量词 / 存在量词。同样传入一个断言函数，整个方法的返回结果为true 或 falsedata.every(x=&gt;x&gt;0) // =&gt; true// reduce() 和 reduceRight()// 将第一个参数传入的函数用于归并数组元素，第二个参数则传入初始值（若为指定，则默认以数组第一个遍历的元素作为初始值）。// 两者不同点是两者遍历方向相反（前者从前往后）// 这两个方法与之前的不同点是，第一个参数传入的函数它的第一个参数是目前为止归并操作累积的结果，第二、第三、第四个参数才是数组值、数组索引和数组本身data.reduce((x,y)=&gt;&#123;x+y&#125;,0) // =&gt; 15data.reduceRight((x,y)=&gt;&#123;x+y&#125;) // =&gt; 15\n\n打平数组ES2019中，flat()方法用于创建并返回一个新数组，这个新数组包含调用它的数组的相同的元素，只不过其中任何本身也是数组的元素会被“打平”填充到返回的数组（空数组打平后是没有元素的）\n[1,[2,3]].flat() // =&gt; [1,2,3][1,[2,[3]]].flat() // =&gt; [1, 2, [3]]\n\n\n\nflatMap()也有”打平“数组的功能，且同时拥有map()的功能，可以看成将map()返回的数组自动“打平”的效果\n[-2, -1, 1 ,2].flatMap(x=&gt;x&lt;0 ? [] : x) // =&gt; [1, 2]\n\n\n\n添加数组concat()方法创建并返回一个新数组，新数组包含调用concat()方法的数组的元素和传入的数组元素，默认打平\n[1,2,3].concat([4,5],[[6]]) // =&gt; [1,2,3,4,5,[6]]\n\n\n\n栈和队列操作let data=[1,2,3]// 栈操作data.push(4,5) // data==[1,2,3,4,5]data.pop() // =&gt; 5，此时data==[1,2,3,4]data.unshift(0) // data==[0,1,2,3,4]data.shift() // =&gt; 0，此时data==[1,2,3,4]\n\n注意，unshift shift效率不高，不过unshift会一次性把参数放到数组开头，比如[].unshift(1,2,3) // =&gt; [1,2,3]\n处理连续区域这类方法用于处理连续区域，也叫处理子数组、数组“切片”，比如提取、替换、剪切和复制切片\n// slice()// 接收两个参数，作为切片的起止索引，返回的切片数组结果包含起始索引，但不包含终止索引。// 若只传入一个参数，则默认包含起始位置到数组末尾的所有元素// 可以传入负数[1,2,3,4].slice(0,1) // =&gt; [1]// splice()// 用于删除或增加元素，修改调用该方法的数组，返回值则是删除元素的数组， 若没有删除元素则返回空数组// 接收两个参数，第一个参数作为操作的起点索引，第二个参数作为从数组中切割出的元素个数（如果省略，则默认删除所有到数组末尾的元素）// 这两个参数后，接收任意多个参数，作为 插入 到起始索引的元素。特点是插入数组本身，不会打平let a = [1,2,3]a.splice(1,1) // a==[1,3]a.splice(1,0,&quot;2&quot;,&quot;4&quot;) // a==[1,2,4,3]a.splice(1,0,[11]) // a==[1,[11],2,4,3]// fill()// 用于将数组中切片位置设置为指定的值，修改并返回调用该方法的数组// 接收三个参数，第一个是要设置的值，第二个是起始索引（可选，默认从0开始），第三个是终止索引（可选，默认是数组末尾）let a = [1,2,3,4]a.fill(0) // a==[0,0,0,0]// copyWithin()// 用于把数组中切片复制到数组中的新位置，修改调用该方法的数组，返回修改后的数组。特点是数组长度不会改变// 接收三个参数，第一个是粘贴位置的起始索引，第二个是复制切片的起始索引（默认为0），第三个是复制切片的终止索引（默认为数组长度）// 后切片中的元素（不包含终止索引）就会从粘贴的初始索引处，顺序覆盖原数组let a = [1,2,3,4]a.copyWithin(1) // =&gt; a==[1,1,2,3]\n\n\n\n数组索引和排序方法// indexOf() 和 lastIndexOf()// 用于从数组中搜索指定的值，并返回第一个找到的元素的索引。两者搜索顺序不一样，前者是从前往后// 接收两个参数，第一个参数是要搜索的元素（使用===来判断），第二个参数是搜索的起始位置索引（支持负数索引）let a = [1,2,3]a.indexOf(1) // =&gt; 0// includes()// 用于判断数组是否包含要搜索的值，返回true或false。可以检测是否包含NaN// sort()// 用于就地排序数组，返回排序后的数组// （可选）接收一个函数作为参数，该函数接收两个参数，代表被排序的数组元素。该函数的返回值代表这两个参数的相对位置，第一个参数在第二个参数前面，则应该返回一个小于0的数值，反之。若等于0则代表此时相等或顺序不重要// 如果不传任何参数，则按照字母顺序进行排序// 未被定义的数组元素会放到数组末尾let a = [3, 2, 1, 4]a.sort((a,b)=&gt;&#123;a-b&#125;) // a==[1,2,3,4]\n\n\n\n数组到字符串的转换// join()// 把数组中的所有元素转换为字符串，然后拼接起来并返回结果字符串。// 接收一个可选参数，作为拼接的分隔字符let a = [1,2,3]a.join(&quot; &quot;) // =&gt; &quot;1 2 3&quot;// toString()，此时相当于没有参数的join()// toLocaleString，是toString()的本地版本\n\n\n\n静态数组函数Array.isArray()用于确定一个未知值是不是数组，返回值为true / false\nArray.isArray([]) // =&gt; true\n\n\n\n类数组对象事实上，只要对象有一个数值属性length，而且有相应的非负整数属性，那么完全可以视同为数组。所以很多时候，虽然不能在类数组对象上直接调用数组方法（可以用Function.call()间接调用），但我们可以真正的数组算法来遍历类数组对象。\n作为数组的字符串除了使用charAt()访问个别字符，也可通过方括号语法\nlet s = &quot;abc&quot;s[1] // =&gt; &quot;b&quot;\n\n\n\n函数函数可分为形参和函数体，同时JavaScript中的函数是对象，可以把自己赋值给变量，传给其他函数，也可以在函数上设置属性，甚至调用函数的方法。\n定义函数函数声明组成：function (参数列表) &#123; /*函数体*/ &#125;\n函数声明的本质是声明了一个变量（即函数的名字），然后把函数对象赋值给这个变量。而且函数声明语句会被“提升”到包含脚本、函数或代码块的顶部   \n以下是三种特殊情况：\n\n类似name:value对象字面量语法\n\nlet c = &#123;    f: function()&#123;return 0;&#125;&#125;// 简写let c = &#123;    f()&#123;return 0;&#125;&#125;\n\n\nget和set定义的特殊获取和设置方法\n\nlet p = &#123;    x: 1;        get val() &#123; return this.x&#125;\tset val(value) &#123;  this.x = value&#125;&#125;\n\n\n函数表达式，将函数赋给另一个变量\n\nconst square = function(x)&#123;return x*x;&#125;;\n\n\n\n\n\n函数表达式这种情况，函数名是可选的。\n//带函数名--适用于需要使用到函数的情况，比如递归const f = function fact(x)&#123;if(x&lt;=1)return 1;else return x*fact(x-1);&#125;;// 可以不带函数名const square = function(x)&#123;return x*x;&#125;;//直接作为参数[3,2,1].sort(function(a,b)&#123;return a-1;&#125;)//定义并立即调用let sq = (function(x)&#123;return x*x;&#125;(10))\n\n箭头函数定义：使用箭头=&gt;分隔函数的参数和函数体，因为箭头函数是表达式而不是语句，所以不用使用function关键字，也不用函数名。\n重点：箭头函数从定义自己的环境中继承this关键字的值，以及它没有prototype属性\n// 比较标准完整的例子const sum = (x,y)=&gt;&#123;return x+y;&#125;;// 简写 / 特殊情况// 函数体仅包含一个return语句，则可以将函数体写成一个表达式，它的值将被返回。若表达式同时是一个对象字面量，则需要放在圆括号()中，不然解释器会默认把花括号解释为函数体const sum = (x,y)=&gt;x+y;const f = x=&gt;(&#123;value: x&#125;);// 参数只有一个，可以省略括号()const f = x =&gt; x*2;// 没有参数，则必须要用括号()const c = () =&gt; 0\n\n嵌套函数JavaScript支持在函数中嵌套函数，被嵌套的函数可以访问包含自己的函数的参数和变量\n调用函数构成函数体的代码只在被调用时执行，被调用的情况一般分为5种：函数、方法、构造函数、call() apply()和隐式调用\n函数调用函数是通过调用表达式被作为函数或方法调用的。\n方法调用方法也是函数，只不过它保存为对象的属性而已，通过属性访问表达式被调用。\n重点：方法调用的上下文是方法所归属的对象，可以通过this关键字引用这个对象。任何用作方法的函数实际上都会隐式收到一个参数，即调用它的对象。\n\n方法调用链：这是一种编程风格，即规定所写的方法若没有自己的返回值，则考虑让它们都返回this，那么基于这个方法调用的返回值还可以继续调用其他方法，这样就会表现为一系列方法调用。\n\nthis是一个关键字，不能被赋值，也不具有变量那样的作用域机制。除了箭头函数，嵌套函数是不会继承包含函数的this值，这在对象方法的嵌套函数中表现得尤为明显，下面举个例子：\nlet o = &#123;    m: function()&#123;        let selft = this;        this === o; // =&gt; true，即this是对象o        f();                function f()&#123;            this === o; // =&gt; false 可以看出是不会继承这个方法的调用上下文的this值的            self === o; // =&gt; true        &#125;    &#125;&#125;\n\n以上这个例子是javascript的历史缺陷之一，解决办法之一是将此嵌套函数用箭头函数代替，只不过需要注意将函数声明手动提升到调用之前。另一个解决办法是调用嵌套函数的bind()方法。\n构造函数调用 如果函数或方法调用前面加了一个关键字new，那么它就是构造函数调用。\n若构造函数没有参数列表，则在调用时可以省略圆括号let o = new obj();等价于let o = new obj;\n构造函数调用会返回一个新的空对象，并用作函数的调用上下文，即便看起来像方法调用。换句话说，new o.m()表达式中，o不会用做调用上下文。\n构造函数中若显式地使用return语句返回某个对象，则该对象就会变成调用表达式的值，否则默认返回初始化的新对象。\n间接调用javascript中的函数本身也是对象，是具有方法的。其中call() apply()方法可以用来间接调用函数，这两个函数允许指定调用时的this值，在理论上支持将任意函数作为任意对象的方法来调用。\n隐式函数调用有一些JavaScript语言特性看起来不像函数调用，但实际上会导致某些函数被调用。通常这些特性导致bug也会更加难以排查。\n比如获取方法和设置方法、对象的toString()方法、标签模板字面量等等\n函数实参与形参可选形参与默认值当调用函数时传入的实参个数大于形参时，额外的参数默认为undefined。也可以在函数定义时的参数列表中手动指定默认值。比较有意思的情况，参数列表中可以使用前面的参数的值来定义后面参数的默认值。\n剩余形参与可变长度实参列表剩余形参前面有三个点...，且必须是函数声明中的最后一个参数，不能被定义默认值，其类型始终是一个数组，用作接收比形参多的任意数量的实参。这样的函数也被称为变长函数\nfunction max(first=-Infinity, ...rest)&#123;    let maxV = first;    for(let n of rest)&#123;        if(n &gt; maxV)&#123;            maxV = n;        &#125;    &#125;    return maxV;&#125;\n\n\n\nArguments对象在剩余实参之前，变长函数的实现是靠标识符arguments引用该次调用的Arguments类数组对象，它允许通过数值取得传给函数的参数值\nfunction max(x)&#123;    let maxV = -Infinity;    for(let i = 0; i &lt; arguments.length; i++)&#123;        if(arguments[i] &gt; maxV)&#123;            maxV = arguments[i];        &#125;    &#125;    return maxV;&#125;\n\n\n\n在函数调用中使用拓展操作符和之前讲的剩余形参中的拓展操作符不同，我们在调用函数时也可以是使用拓展操作符...，用作展开数组\nlet nums = [1,3,5,6]Math.min(...nums)\n\n\n\n把函数实参解构为形参当我们调用函数时，传入的实参列表都会被赋给函数定义时所声明的形参，这个初始化赋值阶段和变量赋值类似，故也可以用到解构赋值\nfunction addVec([x1,y1], [x2,y2])&#123;    return [x1+x2, y1+y2];&#125;addVec([1,1],[3,3])  \n\n\n\n参数类型JavaScript方法的参数没有预定义的类型，在调用传参时也没有类型检查，切会按需执行任意的类型转换。当然，可以自行接入语言拓展来引入类型检查能力，或者自己在函数体内写类型检查的代码和处理逻辑。\n函数作为值在JavaScript中，函数不仅是语法，也是值，可以被赋值给变量、保存为对象的属性或者数组的元素。它不是原始值，而是一种特殊的对象，可以定义自己的属性，用于保存函数运行时产生的数据。\n函数作为命名空间在函数体内声明的变量在函数外部不可见，因此可以在函数内部定义变量，并将此作为临时的命名空间。\n通过立即调用函数表达式，甚至函数名都可以省略，例子：\n(function()&#123;/*函数体*/&#125;())\n\n上式最外层的圆括号一定要加，否则会被解释为函数声明语句。\n闭包JavaScript使用词法作用域，即函数执行时使用的时定义函数时生效的变量作用域，而不是调用函数时生效的变量作用域。为此，JavaScript函数对象不仅要包括函数体，也要包括对函数定义所在作用域的引用。这种函数对象与作用域（即一组变量绑定）组合起来解析函数变量的机制，在计算机科学文献中被称作闭包。\n严格来讲，所有JavaScript函数都是闭包，但是多数函数的调用与定义都在同一作用域内，所以对于这类情况，闭包的存在无关紧要。值得关注的情况是，函数定义与调用的作用域是不同的时候，比如一个函数返回了其内部包含的嵌套函数。这种情况下，牢记词法作用域的基本规则：Javascript函数是使用定义它们的作用域来执行的。\n其次，就是每次调用函数都会创建一个新作用域（与之前函数调用时创建的的作用域相互独立），同时包含新的作用域中的变量，可以理解为创建了不同的函数对象，它们的作用域是互相独立的。举个例子：\nfunction f()&#123;    let n = 0;    return &#123;count:()=&gt;n++&#125;&#125;let m = f(), n = f();m.count() // =&gt; 0n.count() // =&gt; 0\n\n\n\n再者需要注意，同一个作用域的多个嵌套函数是可以共享变量的。但是要注意什么时候不应该共享，比如使用var定义变量而不是let const来定义变量，会导致意想不到的结果。\nfunction f()&#123;    let fs=[];    for(var i = 0; i &lt; 10; i++)&#123;        fs[i]=()=&gt;i;    &#125;    return fs;&#125;let fs = f();fs[5]() // =&gt; 10 结果不是5，是因为通过var声明的变量在整个函数作用域内都有定义。若改成let来声明i则问题立马解决\n\n再牢记一点：与闭包关联的作用域是“活的”。嵌套函数不会创建作用域的私有副本或截取变量绑定的静态快照。\n最后，写闭包时如需操作this值，需要在返回闭包前使用箭头函数或bind()，或者把外部的this值手动赋值给闭包中的某个变量。\n函数属性、方法和构造函数JavaScript函数是对象，typeof返回值为function，可以通过Function()构造函数来创建新函数对象。\nlength属性函数有一个length属性（只读），表示函数的元数（在函数参数列表中声明的形参个数）。剩余形参不包括在内。\nname属性函数有一个name属性（只读），表示定义函数时使用的名字，对于未命名函数，则表示第一次创建这个函数时赋给该函数的变量名或属性名。\nprototype属性除了箭头函数，所有函数都有一个prototype属性，这个属性引用一个被称为原型对象的对象。\ncall()和apply()方法这两个方法允许间接调用一个函数，它们的第一个参数都是函数的调用上下文，在函数体内会变成this关键字的值，通常都是传入要在其上调用这个函数的对象。\n箭头函数例外，箭头的this值不能通过call() apply()方法重写，如果硬调用的话，那第一个参数实际上会被忽略（当然，其他参数不会被忽略）\n这两个方法的后续参数都会传给被调用的函数，不同地方是，传给apply()方法的参数要以数组的形式提供，而call()则不用这样做\nf.call(o,1,2)f.apply(o,[1,2])\n\n\n\nbind()方法bind()方法的主要目的是把函数绑定到对象，并返回一个新函数。如果调用这个新函数，就会像被绑定的对象的方法一样调用原始函数，且传给这个新函数的所有参数都会传给原始函数。也就是说，这个新函数会在指定的上下文中调用原始函数。\n另外一个用处是，在第一个参数之后传给bind()的参数也会随this值一起被绑定。\nfunction f(y,z)&#123;return this.x+y+z&#125;let g = f.bind(&#123;x:1&#125;, 2)g(3) // =&gt; 6，this.x绑定到1，y绑定到2，z是3\n\n\n\ntoString方法和所有JavaScript方法一样，函数也有toString()方法，要求返回一个符合函数声明语句的字符串，通常是返回函数完整的源代码。\nFunction构造函数该构造函数接受任意多个字符串参数，最后一个参数是函数体的文本（语句以分号分隔），其余参数都用于指定新函数的参数名，不接受任何指定新函数名字的参数。\n需要注意，Function()允许在运行时动态创建和编译JavaScript函数。它创建的函数不适用词法作用域，而是始终编译为如同顶级函数一样。\n函数式编程虽然JavaScript不是Lisp或Haskell那样的函数式编程语言，但函数也是对象这个机制意味着可以在JavaScript中实现函数式编程技巧。\n使用函数处理数组const sum = (x,y)=&gt;x+yconst square = x=&gt;x*xconst map = function(a,...args)&#123;return a.map(...args)&#125;const reduce = function(a,...args)&#123;return a.reduce(...args)&#125;let data=[1,1,3,5,5]let mean=reduce(data,sum)/data.lengthlet deviations=map(data,x=&gt;x-mean)let stddev = Math.sqrt(reduce(map(deviations,square),sum)/(data.length-1))stddev // =&gt; 2\n\n\n\n高阶函数定义：操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数\n函数的部分应用将bind()和高阶函数组合，可以在已定义的函数基础上轻松定义更有意思的函数。\n函数记忆在函数式编程中，在闭包中缓存中间数据也被称为“函数记忆”\n类JavaScript中的类和基于原型的继承机制与Java等语言中类和基于类的继承机制有着本质区别。\n类和原型原型对象是类的核心特征，类意味着一组对象从同一个原型对象继承属性\n类和构造函数构造函数是一种专门用于初始化新对象的状态的函数，当使用new关键字调用时，才会自动创建新对象，并将构造函数的prototype属性作为新对象的原型。也就是说，**构造函数本身并没有（且不需要）创建返回任何新对象，仅仅需要初始化this**，它（通过new）调用会自动创建新对象。一般构造函数都是由new关键字来调用的，若当成普通方法调用通常 会有些问题。\n之前提到，几乎所有对象都有原型，但只有少数对象有prototype属性。同时只有函数对象有prototype属性，所以使用同一构造函数创建的所有对象都继承同一个对象，是同属于一个类的。\n我们可以手动编写构造函数的prototype属性，prototype这个属性名是强制性的，会在创建新对象时被默认解释为要继承的原型。\n构造函数、类标识和instanceof原型对象是类标识的基本，但构造函数不是（因为两个不同的构造函数的prototype属性可能同时指向同一个原型对象）。但是构造函数是类的公共标识，构造函数的名称一般也是类名。\ninstanceof的右操作数代表某个类的构造函数，实质是检查对象（或对象所继承的对象中）是否继承该构造函数的prototype属性\nconstructor属性每个JavaScript函数（除了箭头函数、生成器函数和异步函数）都可以作为构造函数，并自动拥有一个prototype属性，这个属性的值是一个对象，有一个不可枚举的constructor属性，而这个constructor属性的值就是该函数对象。\n使用class关键字的类ES6引入了class关键字，使类的创建更加的简便，可以看成语法糖，它并未改变JavaScript类基于原型的本质，并且由class声明的类的对象只是一个构造函数。\n继承则需要使用extends关键字\n需要注意以下几点：\n\n类体中不支持名&#x2F;值对形式的属性定义\n\n类体中一般使用对象字面量简写形式定义方法，方法间是不用逗号分隔的\n\n关键字constructor用于定义类的构造函数，但实际定义的函数并不叫constructor。class声明语句会定义一个新变量（名称为类名），并将这个特殊构造函数的值赋给该变量。\n\n与函数定义表达式类似，也有类定义表达式（不常用）\n\n即使没有use strict指令，类体中所有代码默认处于严格模式\n\n类声明不会“提升”\n\n\n静态方法把static关键字放在方法声明前面可以定义静态方法，作为构造函数而非原型对象的属性定义的。\n获取方法、设置方法及其他方法的方法在class体内，对象字面支持的所有间歇方法定义语法都可以在类体中使用，包括获取方法、设置方法及其他方法的方法\n公有、私有和静态字段拓展类语法以支持定义实例和静态标准化过程还在继续，目前可以这样定义字段：\nclass c&#123;    len = 0    size = 10&#125;\n\n私有实例字段则需要在字段名声明前带#前缀，私有字段对类体外部代码不可见、不可访问（因此无法修改），只能在类内部访问，可以通过获取函数实现读取。但需要在类体中声明私有字段后，才可以通过this访问。\nclass c&#123;    #len = 0    size = 10    get len()&#123;return this.#len;&#125;&#125;\n\n静态字段则是在声明字段名前加上static关键字\n为已有类添加方法JavaScript基于原型的继承机制是动态的，即对象所继承的原型对象的属性发生变化后，则对象继承修改后的属性。理论上我们可以通过修改原型对象，来增强JavaScript类（但一般不推荐在内置类型的原型上添加方法，可能造成兼容性问题）\n子类子类与原型定义子类时，让其通过父类的prototype属性创建一个对象，就能通过原型实现继承了，但这样并不能支持子类调用父类的方法和构造函数\n通过extends和super创建子类class MyArr extends Array&#123;    /*类体*/&#125;\n\n这种声明类的方式支持使用super关键字调用父类构造函数和父类的方法。super关键字很像this，它引用当前对象，但允许访问父类定义的被覆盖的方法。\n委托而不是继承在你的类中创建另一个类的实例，并在需要时委托该实例去做你希望的事反而比新创建一个类更方便，这种策略也被称为“组合”（能组合就不继承）\n类层次与抽象类尽管使用组合代替继承是一个良好的准则，但有些情况仍需要多级子类来实现。JavaScript没有正式定义抽象方法或抽象类的语法，但我们可以手动模拟定义抽象类以及多个子类。\n模块模块化编程的目的是能够用不同的作者和来源不同的代码模块组装成大型程序，并正常运行。\n基于类、对象和闭包的模块类之所以称为模块，是因为对象是模块：给对象添加属性不影响程序的全局命名空间，也不影响其他对象的属性。但是基于类和对象实现模块的方式不支持隐藏内部实现细节。但闭包和立即调用函数表达式实现模块可以将实现细节和辅助函数隐藏。（隐藏指的是对模块使用用户不可见）\n基于闭包的自动模块化编写JavaScript代码文件并手动转为立即调用表达式，来转为模块，这一过程是可预见的、重复的。\n可以想象有一个工具，它可以自动解析代码，将每个文件的内容包装在一个立即调用表达式中，还可以跟踪每个函数的返回值，并将所有内容拼接为一个大文件，这样就能实现自动模块化\nNode中的模块与浏览器不同，编写Node程序时，每个文件都是一个拥有私有命名空间的独立模块。除非文件主动导出，且被另一模块显式导入，否则是不可用的。\nNode模块使用require()函数导入其他模块，使用module.exports或Exports对象的属性导出公共API\nNode的导出Node定义了一个全局对象exports对象，这个对象始终有定义，如果要编写导出一个或多个值的Node模块，可以给export设置属性或直接设置module.export对象。他们两引用的是同一个对象\nconst sum = (x,y)=&gt;x+y;const nav = (x)=&gt;-x;// 方式一export.sum = sumexport.nav = nav// 方式二module.export = &#123;sum, nav&#125;\n\nNode的导入Node模块通过调用require()函数导入其他模块，该函数的参数是要导入的模块的名称，返回值是该模块导出的值\n需要注意，导入Node内置的模块或通过包管理器安装到系统上的模块，可以直接写该模块名导入。若是导入自己代码中的模块，则需要写相对路径和模块文件名（可以省略后缀名.js，但不推荐）。\n然后，取得调用require()的返回值，可以导入整个对象，也可以使用解构赋值导出指定属性。\nES6中的模块ES6为JavaScript添加了import和export关键字，意味着将模块作为核心语言特性来支持。本质和Node模块没有区别，只是在语法上有些不同。\n此外，ES6模块和JavaScript普通脚本有很大区别，前者的每个文件都有自己的上下文，且自动应用严格模式。\nES6的导出\n普通导出，只需要在变量&#x2F;函数&#x2F;类的声明前加上export关键字即可\n导出多个，在文件末尾添加一句：export &#123; /*逗号分隔的标识符列表*/ &#125;\n只导出一个，将export替换为export default即可。而且默认导出支持任意表达式，包括匿名函数表达式、对象字面量等。这种情况下，如果后面接花括号&#123;&#125;包括起来的代码，会被认为是导出对象字面量。\n\n注意export关键字只能出现在JavaScript代码的顶层，而不能在循环、函数、类当中\nES6的导入// 最通用的导入写法import 标识符 from &#x27;./xxx.js&#x27;import &#123;/*标识符列表*/&#125; from &#x27;./xxx.js&#x27;// 全部一次性导入到一个对象当中import * as 标识符 from &#x27;./xxx.js&#x27;// 导入没有返回值的模块，一般是只需要运行该模块中的内容时，会这样做。因为首次导入模块会运行一次（再导入则什么都不做）import &quot;./xxx.js&quot;\n\n\n导出的值会变成当前模块指定的标识符的值，它是一个常量。\n导入语句会被自动提升到顶部，不允许出现在类、函数、循环体等语句当中，只能出现在模块顶部。\n导入到模块以字符串字面量形式给出，但不能出现在反引号中。且写法一定得是相对路径、绝对路径、URL中的一种，而不能直接写一个文件名，否则会找不到。即使是同一目录下也不能写成类似xxx.js，而要写成./xxx.js\n\n导入和导出时重命名当遇到命名冲突，或想要精简命名，又或导入默认导出的情况时，可以配合as关键字，来为导入&#x2F;导出的标识符进行重命名。\nimport &#123;sum as sss&#125; from &#x27;./xxx.js&#x27;// 导入默认导出，则另外再配合default关键字import &#123;default as sss&#125; from &#x27;./xxx.js&#x27;export &#123;\tsum as sss&#125;\n\n\n\n再导出当多个文件想要同时导入相同的几个模块时，有可能造成代码体积膨胀。所以ES6模块支持将导入和导出二合一，通过export from两个关键字构造一条”再导出”语句：从另一文件导入后作为本模块的导出\n// 通常做法export &#123;mean&#125; from &#x27;./xxx.js&#x27;// 导入/导出所有export * frmo &#x27;./xxx.js&#x27;// 重命名export &#123;mean as average&#125; frmo &#x27;./xxx.js&#x27;// 导入默认模块并导出export &#123;default as mean&#125; from &#x27;./xxx.js&#x27;// 作为当前模块默认导出export &#123;mean as default&#125; from &#x27;./xxx.js&#x27;// 导入默认并作为默认导出export &#123;default&#125; from &#x27;./xxx.js&#x27;\n\n\n\n在网页中使用JavaScript模块必须通过&lt;script type=&#39;module&#39;&gt;标签告诉浏览器你的代码是一个模块。ES6模块的一个核心特性是每个模块的导入都是静态的，意味着只要有一个起始模块，浏览器就可以加载它导入的所有模块。\n支持&lt;script type=&#39;module&#39;&gt;的浏览器也必然支持&lt;script nomodule&gt;，这样就能很好解决某些浏览器不兼容ES6模块的问题了。因为支持该标签的浏览器会忽略带有nomodule属性的脚本，而不支持该标签的浏览器会因为不认识nomodule属性，而直接忽略，并运行代码。综上，这样做可以实现用&lt;script type=&#39;module&#39;&gt;来加载现代JavaScript代码。\n由于&lt;script type=&#39;module&#39;&gt;增加了跨源加载的限制，其带来的副作用之一是不能在开发模式下使用file:URL来测试ES6模块。为此，需要启动一个静态Web服务器来测试。\n通过import()动态导入import()是一个操作符，圆括号是这个操作符语法的必须部分，它的参数应该是一个模块标识符，跟静态import指令中的完全一样，只不过没有字符串字面量的限制。\n调用import()会返回一个期约对象，表示加载和运行指定模块的异步过程，加载完成后期约兑现，返回模块的导出对象，需要搭配then或async await来使用。合理地使用它，可以实现将比较大的文件拆分，按需加载。\nimport.meta.urlimport.meta引用了一个对象，包含当前执行模块的元数据，其中url属性是加载模块时使用的URL。可以配合使用来加载与模块位于同一（或相对）目录的其他资源。\n迭代器与生成器可迭代对象及其相关的迭代器、生成器都是ES6的新特性\n迭代器原理理解JavaScript中的迭代，必须理解3个不同的类型，首先是可迭代对象（类似Array Set等）。其次是迭代器对象，用于执行迭代。最后是可迭代对象，保存每次迭代的结果，三者定义如下：\n\n可迭代对象指的是任何具有专用迭代器方法，且该方法返回迭代器对象的对象\n\n迭代器对象是指任何具有next()方法，且该方法返回迭代结果对象的对象\n\n迭代结果对象是具有属性value和done的对象\n\n\n迭代一个可迭代对象的过程如下：\n\n调用其迭代器方法，获得一个迭代器对象\n然后重复调用这个迭代器对象的next()方法\n直至返回done属性为true的迭代结果对象\n\n\n迭代器方法没有使用惯用名称，而是使用了Symbol.iterator作为名字\n内置可迭代数据类型的迭代器对象本身也是可迭代的，即他们的迭代器对象本身也有一个名为Symbol.iterator的方法，返回他们自己\n\n实现可迭代对象只要你的数据类型表示某种可迭代的结构，就应该考虑把他们实现为可迭代对象。\n创建可迭代对象，除了使用生成器，可以通过给类在定义基础的构造函数和方法上，再定义[Symbol.iterator]()&#123;/*返回迭代器对象*/&#125;方法，其中迭代器对象一定要包含next()方法返回迭代结果，可选包含[Symbol.iterator]()&#123;return this;&#125;表示让迭代器本身也可迭代。\n定义返回可迭代值的函数也同样重要且常用，原理是一样的，让函数返回一个可迭代的迭代器对象即可。\n“关闭”迭代器：return()方法：\n尽管next()很常用，但是在某些情况，比如需要提前终止迭代（文件异常关闭、主动break等），此时解释器会检查迭代器对象是否有return()方法，有的话就会调用它（不传参数），那么此时就有机会处理一些必要的事务，比如关闭文件、保存数据、释放内存等等。该return()方法必须返回一个迭代结果对象，但其属性会被忽略，且返回非对象会导致报错。\n生成器生成器可以极大地简化自定义迭代器的创建，特别适合要迭代的值是某个计算结果的场景。\n创建生成器，首先要定义一个生成器函数，该函数在语法上同普通的javaScript函数，但关键字需要多加一个*号，加在function之后，函数名之前。\n调用生成器函数并不会实际执行函数体的代码，而是得到一个生成器对象，同时也是一个迭代器，调用其next()方法才会导致生成器函数的函数体从头（或当前位置）开始，执行直至遇到一个yield语句停止。yield也是ES6的新特性，类似return，该语句的值会成为调用迭代器的next()方法的返回值。\n生成器示例/*斐波那契数列*/function* feibonaqi()&#123;    let x=0,y=1;    for(;;)&#123;        yield y;        [x,y]=[y,x+y];    &#125;&#125;//注意不要用...来调用该函数，否则会无限循环function fi(n)&#123;    for(let f of feibonaqi())&#123;        if(n--&lt;=0)return f;    &#125;&#125;//在for/of中使用即可\n\nyield*与递归生成器yield*和yield类似，它不是会送一个值，而是迭代可迭代对象并回送得到的每个值，两者相同的就是只能在生成器函数中使用。\nfuntion* sequence(...iterables)&#123;    for(let iterable of iterables)&#123;        yield* iterable;    &#125;&#125;function* oneDigitPrimes()&#123;    yield 2;    yield 3;    yield 5;&#125;[...sequence(&quot;abc&quot;,oneDigitPrimes())] // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,2,3,5]\n\n\n\nyield*可以用来迭代任何可迭代对象，包括通过生成器生成的，意味着我们可以编写递归生成器。\n高级生成器特性生成器返回函数的值生成器函数也可以有return返回值，但只会在手工迭代时显式调用next()才能看到，其他情况则会被忽略。 \nyield表达式的值yield关键字后面的表达式的值会成为调用next()方法时返回值。\n而yield语句本身也是有值的，该值是下一次调用next方法时，传给next()的参数值。也就是说，只有再次调用next，才能得到且访问到上一次暂停处yield语句的值。\n生成器和调用者是两个独立的执行流，它们交替传值（和控制权）。\n生成器的return()和throw()方法对与生成器，我们无法定义一个return()方法，但我们可以在生成器函数中使用try/throw/finally语句块中作必要的清理工作，生成函数内置的return()方法会保证这些清理代码运行。\n而且，当生成器函数中使用yield*回送其它可迭代对象时，调用生成器的next()方法会导致调用该可迭代对象的next()方法，同理return()和throw()也会相应被调用（如果该可迭代对象有定义这两个方法的话）。\n异步JavaScript异步编程在计算机领域中是司空见惯的，特别是网络应用。JavaScript中提供了三个特性（期约、async/await语法糖关键字、for/await语法糖），让异步代码的编写更加容易。\n使用回调的异步编程在最基本的层面，JavaScript异步编程是基于回调实现的。回调就是函数（某些情况也是一种行为），它可以传给其他函数，而其他函数会在满足某个条件（或某个事件发生）时，调用（“回调”）这个函数。\n定时器setTimeout()函数算是最简单的异步操作了，在一定时间后运行某些代码。\n事件客户端JavaScript编程几乎都是事件驱动的，浏览器响应用户的动作，生成事件，然后在特定上下文中为特定类型时间注册回调函数，当事件发生时就调用这些函数。这些回调函数叫做事件处理程序或事件监听器，是通过addEventListener()注册的。\n网络事件网络请求也是一种常见的异步操作，大多数Web API都支持在网络请求对象上调用addEventListener()来定义事件处理程序\nNode中的回调与事件Node.js服务端JavaScript环境底层就是异步的，定义了很多使用回调和事件的API，比如读取文件、读取网络请求的内容\n期约期约是一种为简化异步编程而设计的核心语言特性，它是一个对象，表示异步操作的结果。这个结果可能就绪，也可能未就绪，也就是说我们无法同步拿到结果，但是期约API支持在期约对象上注册事件处理程序，也属于处理回调的一种方式。\n期约可以避免多层嵌套的回调，让异步编程易于阅读，同时标准化了异步错误处理。\n使用期约期约对象有一个实例方法叫then()，是期约独有的特性。该方法类似addEventListener()，接收事件处理程序作为参数，并在预期计算完成后被调用，但只会被调用一次，即使通过then注册了多次同一个函数。\n\n期约有几种状态：得到兑现、被拒绝、既未兑现也为被拒绝时的待定状态、得到兑现或被拒绝时的落定状态\n\n使用期约处理错误：\n对期约而言，异步计算结果会在正常结束后传给then()的第一个参数的函数，而把异常传给then()的第二个参数的函数，但一般很少这样用，而更多使用catch()，这个方法只是对调用then()时以null作为第一个参数，以指定错误处理函数作为第二个参数的一种简写形式。\n期约链期约有一个最重要的优点，就是以线性then()方法调用链的形式表达一连串异步操作，而无须把每个操作嵌套在前一个操作的内部， 也就是说我们可以在一个表达式中调用多个方法，也被称为方法链，以一个期约为例：fetch().then().then()。\n我们之前提到的方法链中，都只有一个对象，每个方法均返回处理后的对象本身。但是基于期约的方法链略有不同，每个then()会返回一个新的期约对象，并在传给then()的函数执行完才会兑现。\nthen()方法会把我们的回调函数保存在某个地方，并返回一个新期约，并将该回调函数的返回值用于兑现这个新期约。\n解决期约function c1(response)&#123;    let p4 = response.json();    return p4;&#125;function c2(profile)&#123;    displayUserInfo(profile)&#125;let p1 = fetch(&quot;/api/user/info&quot;)let p2 = p1.then(c1)let p3 = p2.then(c2)\n\n我们将上一小节的期约链例子中的函数单独写出来，会更直观一些。我们发现，除了p1 p2 p3三个期约，函数c1返回的也是一个期约（假设返回值为v），并用于兑现期约p2。\n此时，如果v未兑现，就会以期约的类型返回，此时p2会得到一个期约类型的返回值，那么称p2以v这个值得到解决。如果过段时间，v得到兑现，以一个非期约类型的值得以解决时，则p2同样以相同的值兑现。同理，若v被拒绝，则p2会以相同的理由被拒绝。这就是期约得到了“解决”的意思，即完全拒绝于另一个期约。\n再谈期约和错误细致的错误处理在异步编程中非常重要，.catch()作为.then()的特殊简写形式，让异常捕获的代码可读性更高。.catch()只有在上一环（不是指上一个）的回调中抛出错误时才会被调用，否则会被忽略，之前回调返回的值会成为下一个.then()的回调的输入。.catch()回调捕获到错误会使之停止在期约链中向下传递，同时也可以抛出新错误。如果.catch()回调正常返回，则返回值就会用于解决或兑换与之关联的期约（比如下一个.then()或.catch()回调）\n同时，期约对象也定义了一个.finally()方法，类似try/catch中的finally子句，会在期约落定时调用，而且finally()的回调不需要参数，若该回调发生错误，则finally()期约会被以相同的错误理由被拒绝。\n并行期约函数Promise.all()可以做到并行多个异步操作，它接收一个期约对象的数组作为输入，返回一个期约，当遇到输入期约中某个被拒绝了，会立即返回被拒绝的期约，即使输入期约中还有的是待定状态。否则，返回的期约会以每个输入期约的兑现值的数组兑现。注意，输入输入组可以包含非期约值，会被认为已兑现期约的值，且会被原封不动地复制到输出数组中。\n函数Promise.allSettled()类似，也能实现并行多个异步操作，但它会等所有输入期约全部落定后兑现，返回的期约解决为一个对象数组，数组元素分别对应输入期约，并且视情况包含status value属性或status reason属性，表示输入期约正常兑现和值，或被拒绝和拒绝理由。\n若想在输入的期约数组中，有一个期约兑现或拒绝则立马兑现或拒绝，则可以使用Promise.race() \n创建期约基于其它期约的期约：\n顾名思义，调用一个返回期约的函数的.then()方法，就可以返回一个新期约了\n基于同步值的期约：\n静态方法Promise.resolve() Promise.reject()接收一个值作为参数，并在当前同步代码块运行结束后立即返回一个会立即（但异步）以该值兑现&#x2F;作为理由拒绝的期约。若传入的值也是一个期约，则返回的期约会被立即解决，但得等到参数期约兑现&#x2F;被拒绝后才会兑现&#x2F;被拒绝。\n适用场景之一就是编写一个API，实际执行的计算属于同步代码，但又想从函数回期约。\n从头开始创建期约：\n调用Promise()构造函数，给它传入一个函数作为唯一参数，该函数需要写成接收两个参数，这两个参数需要按惯例命名为resolve reject。构造函数会同步调用这两个参数，并为这两个参数传入对应的函数值（一般是非期约值），并以该函数值作为被解决&#x2F;被拒绝的值。\n串行期约：\n有两种思路，一是动态创建期约链，需要时就往之前的期约链上加一个.then()，调用返回一个期约即可；二是使用伪递归，递归创建上一级期约回调中的期约，合理设置返回条件和中间变量保存结果即可，原理就是顶级期约一定会等回调被兑现&#x2F;拒绝才会相应兑现&#x2F;拒绝的。\nasync和await这是ES2017新增的两个关键字，极大简化了期约的使用，甚至可以像编写同步代码一样，感受不到期约的存在了。但是理解期约的工作原理仍为重要。\nawait表达式await关键字接收一个期约并将其转化为一个返回值或一个抛出的异常，该表达式会一直等到期约落定。并且任何使用await的代码本身都是异步的，不用担心会在期约落定之前被阻塞。\nasync函数只能在以async关键字声明的函数内部使用await关键字，且这样的函数的返回值将是一个期约。如果async函数会正常返回，那么作为该函数真正返回值的期约对象将解决为这个明显的返回值。\n可以对任何函数使用async关键字，包括函数表达式、箭头函数。\n等候多个期约使用await的连续调用相同函数的语句，是并发执行的。\n实现细节以async声明的函数，可以理解为它被包装在一个返回期约的包装函数中。子函数则相当于传给被await标记的期约的then()方法\nasync function f(x)&#123;/*函数体*/&#125; // async声明的函数可以理解为以下代码function f(x)&#123;    return new Promise(function(resolve, reject)&#123;        try&#123;            resolve((function(x)&#123;/*函数体*/&#125;)(x))        &#125;        catch(e)&#123;            reject(e)        &#125;    &#125;)&#125;\n\n\n\n\n\n异步迭代期约只适合单次运行的异步计算，不适合与重复性异步事件来源一起使用，也就是无法用于连续的异步事件。\nfor/await循环与常规的await表达式类似，for/await循环也是基于期约的，只是把await调用内置在了循环中，从而让代码更加整洁。换句话说，该异步迭代器会产生一个期约，for/await循环等待该期约兑现，将兑现值赋给循环变量，然后执行循环体。\n以下两段代码是等价的：\nfor (const promise of promises)&#123;    response = await promise;    handle(response)&#125;for await (const response of promises)&#123;    handle(response)&#125;\n\n异步迭代器异步迭代器和之前讲的常规迭代器非常类似，但有两点不同：\n\n异步可迭代对象以符号名字Symbol.asyncIterator实现一个方法。for/await兼容常规迭代器，但仍会优先尝试Symbol.asyncIterator方法\n异步迭代器的next()方法返回一个期约，解决为迭代器对象结果。\n\n异步生成器异步生成器既有异步函数的特点（比如async声明），也有生成器的特点（比如使用yield），使用async function*进行声明。\n实现异步迭代器除了用异步生成器实现异步迭代器，还可以直接实现。这需要定义一个包含Symbol.asyncIterator()方法的对象，该方法要返回一个包含next()方法的对象，而这个next()方法要返回解决为一个迭代器结果对象的期约。                                                                             \n异步迭代器的优点 是它允许我们表示异步事件流或数据流。\n异步迭代器的编写难度，一部分取决于它的异步性来源。任何异步迭代器方法都必须能在内部维护一个期约队列，让这些期约按照异步事件发生的顺序依次解决。\n元编程一些JavaScript特性可以宽泛地归类为“元编程”特性。如果说常规编程是写代码去操作数据，那么元编程就是写代码去操作其他代码。\n属性的特性 JavaScript属性有名字和值，但每个属性也有3个关联的特性，用于指定指定属性的行为：\n\nwritable可写\nenumerable可枚举（在for/in和Objects.keys()枚举）\nconfigurable可配置（是否可以删除、修改属性）\n\n不仅如此，属性的值（value）也可以看成特性，这样每个JavaScript属性都有4个特性。但是，访问器属性较为特殊，它没有value和writable特性，但相应有get、set特性（这两个特性是函数值）\n调用Object.getOwnPropertyDescriptor()可以获得特定对象的某个属性的属性描述符（拥有与它所描述的属性的特性相同的属性名），该方法第一个参数为指定的对象，第二个为属性名（字符字面量类型）。注意，该方法只对自有属性有效，不能查询继承属性。\n调用Object.defineProperty()方法可以设置属性的特性或创建一个具有指定特性的属性。该方法第一个参数是指定对象，第二个参数是属性名，第三个是属性描述符对象（省略的属性默认为false或undefined，或保持不变）。\n一次性创建或修改多个属性，则可以调用Object.defineProperties()，第一参数是指定对象，第二个参数是包含“属性名:属性描述符”键值对的对象。\nObject.Create()接收第二个可选参数，和Object.defineProperties()的第二个参数一样。      \n\n可修改和可配置是不同的，不可修改但是可配置，一样能进行修改。\nObject.assign()只复制可枚举属性和属性值，但不复制属性的特性，需要特别注意一下。\n\n对象的可拓展能力 定义：是否可以给对象添加新属性（普通JavaScript对象默认是可拓展的）\nObject.isExtensible()接收一个对象作为参数，用于确定该对象是否可拓展。\nObject.preventExtensions()接收一个对象作为参数，让该对象不可拓展，这个过程是不可逆的。（注意，这个函数只影响对象本身的可拓展能力，但是可以正常继承。也就是说给一个不可拓展对象的原型添加新属性是可以的，并且该不可拓展对象仍可以继承这些新属性）\nObject.seal()不仅可以让对象不可拓展，也会让对象的所有自有属性不可拓展。不过，可写的已有属性仍可写。Object.isSealed()用于确定对象是否封存。\nObject.freeze()不仅可以让对象不可拓展，也会它的属性不可配置，还会把对象的所有自有属性变成只读的。但不会影响访问器属性。Object.isFrozen()可以确定对象是否被冻结\n注意，在提到seal() freeze()都特别加重了“自有属性”，这是这两个方法的关键：只影响传给自己（这两个方法）的对象，而不影响对象的原型。另外，加上preventExtensions()，他们全都返回传给它们的对象，能方便地支持嵌套使用。\nprototype特性对象的prototype特性指定对象从哪里继承属性，一般被称为对象的原型，而不说是对象的prototype特性。特别要注意，当prototype以代码字体出现时，它指的是一个普通对象的属性，而不是prototype特性\n对象的prototype特性是对象被创建时设定的，下面是几个常见的原型设定方式以及特点：\n\n使用对象字面量创建对象，则该对象原型是Object.prototype\n使用new创建对象，则该对象的原型是该对象的构造函数的prototype属性的值\n使用Object.create()创建的对象，则原型是传给它的第一个参数（可能是null）\n\n下面是其它有关原型查询、设置和修改的一些接口：\n\nisPrototypeOf()：确定一个对象是不是另一个对象的原型（或原型链上的一环），功能和intanceOf类似\nObject.setPrototypeOf()：修改对象原型，一般很少使用\n__proto_：暴露对象的prototype属性，已废弃（不推荐使用）\n\n公认符号Symbol类型是ES6推出的，旨在拓展JavaScript的同时，也不影响现有Web向后兼容。之前提到的迭代器那一章中，Symbol.iterator就是一个“公认符号”–Symbol()工厂函数的一组属性，同时也是一组符号值，用来控制JavaScript对象和类的某些底层行为\nSymbol.iterator和Symbol.asyncIterator这两个符号可以让类或对象自己变成可迭代对象和异步可迭代对象\nSymbol.hasInstance如果instanceof的右侧是一个有[Symbol.hasInstance]方法的对象，那么就会以左侧的值作为参数来调用这个方法并返回这个方法的值，返回值会被转化为布尔值，作为instanceof操作符的值。用处就是可以自己定义伪类型对象来做一些类型检查\nlet uint8 = &#123;\t[Symbol.hasInstance](x)&#123;\t\treturn Number.isInteger(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=255;\t&#125;&#125;128 instanceof uint8 // =&gt; true\n\n\n\nSymbol.toStringTag该符号和一般JavaScript对象的toString()方法联系不大。\n但是如果调用内置类型实例的方法相同的Object.prototype.toString().call()就完全不同了，传入一个任意JavaScript值，都可以获取该值的“类特性”（这是typeof操作符远不及的），以下是几个例子：\nObject.prototype.toString().call([])    // =&gt; &quot;[Object Array]&quot;Object.prototype.toString().call(&quot;&quot;)    // =&gt; &quot;[Object String]&quot;Object.prototype.toString().call(false) // =&gt; &quot;[Object Boolean]&quot;\n\n\n\nES6之后，该方法不仅可以对内置类型的实例生效，也可以用于自己定义的类。\n只需要在类中定义一个属性的符号名为Symbol.toStringTag，这是属性的值就会作为Object.prototype.toString()的输出。\nclass MyClass &#123;    get [Symbol.toStringTag()] &#123;return &quot;MyClass&quot;&#125;&#125;let c = new MyClass()Object.prototype.toString().call(c) // =&gt; &quot;[Object MyClass]&quot;\n\n\n\nSymbol.speciesES6中，我们可以使用class extends关键字来拓展任何内置类，同时也包括继承有关的规范。比如继承Array，那么调用子类从父类继承下来的map slice等方法，ES6规定将（默认）返回子类的实例（而不是父类），实现过程如下：\n\nES6推出后，Array()构造函数会有一个名字为Symbol.species符号属性\n使用extends创建子类时，子类构造函数会从超类构造函数继承属性（包括Symbol.species），这是一种特殊的继承。\nArray的map() slice()等创建并返回新数组的这些方法，在ES6中被修改了部分功能，也就是它们不仅创建一个常规的Array，还（实际上）会调用new  this.constructor[Symbol.species]()创建新数组\n接下来才是重点：\nArray[Symbol.species]是一个只读的访问器属性，其获取函数简单地返回this，可以通过defineProperty()来赋值，也可以在定义子类时顺便给重写了。\n子类构造函数会继承Array[Symbol.species]的获取函数，也被称为“子类构造函数作为超类的物种，并继承了这个获取函数”\n\n\n\n综上可以发现，通过这个机制可以更灵活的创建Array的子类，比如确定对返回的数组使用哪个构造函数。但该符号不止用在Array的子类拓展中，其它地方也会被用到，比如定型数组的slice()方法\nSymbol.isConcatSpreadable上一小节提到的符号适用于Array的concat filter map slice splice5个方法，这一节将讲到concat()方法，它还会用另一Symbol.isConcatSpreadable()符号来控制该函数的特定行为。\nconcat方法会默认将this数组和参数中的数组打平或“展开”，而非数组类型只是简单地添加到末尾，这个行为是通过JavaScript解释器是否将要连接的值当作数组来对待决定的。\nES6之前，使用Array.isArray()来判断，ES6推出后，那么则优先根据要连接的值是一个对象且包含Symbol.isConcatSpreadable符号属性，以该属性的布尔值（true/false）来确定是否应该展开参数。\n使用场景有：让自定义的类数组对象赋予也能用concat进行连接、或让自定义的数组子类不能使用concat\n模式匹配符号ES6之后，除了能够使用RegExp对象执行模式匹配操作，也能使用任何具有定义了模式匹配行为的符号属性的对象，也就是说，类似match matchAll search等String匹配方法，都会有类似的公认符号Symbol.match Symbol.search等等，两者之间的转化关系如下：\n/* 在调用字符串的匹配方法时 */string.method(pattern,arg)/* 该调用会转化为 对模式对象上相应的符号化命名方法的调用*/pattern[symbol](string,arg)\n\n\n\nSymbol.toPrimitiveES6中，该公认符号允许我们覆盖默认的对象到原始值的转换行为，完全自定义自己的类实例如何转换为原始值。根据该接口编写相应的符号属性方法即可。\nSymbol.unscopables该公认符号是针对废弃的with语句所导致的兼容性问题所引入的。有点难理解，大致意思就是能够将Symbol.unscopables中的属性在模拟with作用域时忽略。\n模板标签在这之前，我们得复习一下“模板字面量”–位于反引号之间的字符串，如果一个求值为函数的表达式后紧接一个模板字面量，那就换转换为一个函数调用–也被称为“标签化模板字面量”，其中被调用的函数也被称为标签函数，并看成是元编程之一\n如果此时模板字面量中有n个插值，那么标签函数在被调用后会收到n+1个参数，第一个参数是一个包含n+1个字符串的数组，其余n个参数是要插入的值，顺序为他们出现在模板字面量中的顺序。\n反射API与Math对象类似，Reflect对象不是类，它的属性这是定义了一组相关函数，下面列举几个API以及相应的常规写法：\n\n\n\n常规写法\n反射API\n\n\n\nf.apply(o,args)\nReflect.apply(f,o,args)\n\n\nnew c(...args)\nReflect.construct(c,args,newTarget)\n\n\nObject.defineProperty(o,name,descriptor)\nReflect.defineProperty(o,name,descriptor)\n\n\no[name]\nReflect.get(o,name,receiver)\n\n\n以上只列举几个反射API，虽然并没有提供新特性，但它们用一个方便的API筛选出了一组特性，即支持对JavaScript对象执行基础的操作。\n代理对象  ES6及之后的版本的Proxy类是一项强大的元编程特性，让我们能够自己实现基础操作，并创建具有普通对象无法企及能力的代理对象。\n创建代理对象时，需要指定另外两个对象，即目标对象和处理器对象。得到的代理对象没有自己的状态或行为，只是把自己要执行的操作（比如读属性、写属性等等）发送给处理器对象或目标对象。\nlet proxy = new Proxy(target, handlers)\n\n\n\n代理对象支持的操作就是反射API定义的那些操作。对所以基础操作，代理对象都这样处理：如果处理器对象上存在相应的方法，代理就调用该方法执行相应操作（这里的方法和签名和之前反射API介绍的完全相同）。如果处理其对象不存在对应方法，则代理就在目标对象上执行基础操作。\n当处理对象是空时，代理对象本质就是目标对象的一个透明包装器，大多时候这都是没有必要的，除了用于可撤销代理。\n 可撤销代理：使用Proxy.revocable()工厂函数而不是Proxy()来创建一个可撤销代理，返回值中包含一个代理对象和一个revoke()函数。一旦调用revoke函数，代理立马失效。如此看来，可撤销代理可以充当某种代码隔离的机制，比如将某个函数传给一个不信任的第三方库，并在使用完这个库之后撤销代理，防止第三方库一直持有对你函数的引用，并在不知情的时候调用它，这在防御式编程中并不罕见。\n当处理对象非空时，我们就需要好好地定义处理器了，以实现自定义行为，这样就和底层目标对象本质上变得不相干了。这时代理的应用范围变得非常灵活和广泛，比如实现一个只读包装器、一个（更为底层的）日志代理等等。 \n代理不变式：代理对象是可以和目标对象的状态不一致的，比如代理对象被设置为冻结状态，但实际上目标对象没有冻结的话，仍然可以通过Reflect接口修改属性值。至于如何保证两者的不一致不会太离谱，实际上，Proxy类会在转发完操作后对结果执行合理性检查，如果违背了重要的JavaScript不变式，则会抛出TypeError（不让继续操作）\nBOM浏览器对象模型（BOM -- Browser Object Model）是一个应用编程接口（API），用于支持访问和操作浏览器的窗口\n浏览器中的JavaScriptJavaScript其最初目的就是为浏览器显示的文档赋予动态行为，随着技术发展，不仅JavaScript经历了多次重大改变，**Web平台的能力也出现了爆炸式的增长，可以算是一个完善的应用开发平台**了。\n浏览器专注于格式化文本与图片的显示，但其同原生操作系统一样，具有许多操作系统级别的能力，包括图形、视频、音频、网络等等\nJavaScript能够使Web应用使用Web平台提供的服务，这就包括本节的标题–浏览器中的JavaScript\n\nWeb API是通过主要浏览器厂商的共识来定义的，Web API官方文档就是一系列规范，其受众是实现它们的C++程序员，而不是使用这些API的JavaScript程序员\n好在Mozilla的MDN Web文档提供了可靠的、全面的Web API文档–Web API 接口参考 | MDN (mozilla.org)\n\nWeb编程基础Web编程中很重要的一部分就是编写Web应用中的JavaScript程序，以及将这部分程序加载到浏览器、获取输入输出和响应事件。\\\n注释使用VSCode进行开发时，行注释：//（ctrl+/）、块注释：/**/（Shift+alt+a）\n语句结束符即分号;，结束符分号会被自动推断，所以可写可不写，但也要注意可能导致上下文解析出问题的情况，要酌情加分号。当然，也得看团队开发风格和规范\n&lt;script&gt;标签JavaScript需要嵌入HTML才能被浏览器执行，需要将JavaScript代码放在&lt;script&gt; 标签中，\n\nsrc属性：\n\n设置&lt;script&gt;的src属性外部引用路径（推荐），而不用在HTML文档中直接写具体代码\n\n\ntype属性：\n\n用于指定脚本是模块–type=&quot;module&quot;；在网页嵌入数据但不显示\n\n\nasync与defer：\n\n这两个属性只对使用src属性的&lt;script&gt;标签起作用，若同时设置默认只async生效\n浏览器默认解析&lt;script&gt;标签时必须运行脚本，以免漏掉document.wirte()所生成的内容，才能继续渲染，async和defer会明确告诉浏览器，当前链接的脚本没有使用document.wirte()\nasync会让浏览器尽早运行脚本，但在脚本下载期间不会阻塞文档解析。由于是尽早执行的机制，所以这类方式引入的脚本一加载完就会执行，执行顺序无从预测\ndefer会让浏览器完全加载和解析完文档后才执行，这类方式引入的脚本的执行顺序是按照其出现在文档中的顺序执行的\n\n\n\n\n将&lt;script&gt;标签放在文档的什么位置，需要开发者结合执行机制来考虑让其在什么时机执行。比如涉及操控文档节点的代码，则需要在文档完全加载和解析后的时机执行，一般为HTML文件末尾\n有的则会有默认执行顺序，比如alert()和prompt()会跳过页面渲染先被执行，type=module的会在文档加载完毕后执行（可以通过设置async属性，让其尽早执行–一加载完所有依赖就执行）、\n\n文档对象模型文档对象模型（DOM -- Document Object Model）是一个应用编程接口（API），用于在HTML中使用拓展的XML。Document对象是JavaScript编程中最重要的对象之一，它代表浏览器窗口或标签页显示的HTML文档\n文档中的每一个HTML标签都是一个JavaScript Element对象，其中的每一行文本是一个Text对象，这些对象相当于一个Node，构成了一个DOM树，DOM API赋予JavaScript对这棵树进行查询和遍历。且每个标签类型都对应一个JavaScript类\n浏览器中的全局对象每个浏览器窗口或标签页都有一个全局对象，其上定义了JavaScript标准库以及许多Web API属性（比如浏览器浏览记录history、窗口像素宽度innerWidth、**全局对象本身window**等等）\n脚本共享命名空间模块中的常量、函数、类等，如果需要被其他脚本使用，需要明确地导出和导入，但在非模块脚本中，情况完全不同。\n如果在顶级脚本中定义了一个类、函数等，则该声明对同一文档中的所有脚本可见，但这样对于大型程序来说，避免命名冲突会很麻烦，尤其是引入了第三方库，更是棘手。不得不提一个历史遗留问题（现已有替代方案），**var和function会在共享的全局对象上创建属性，而ES6中的const let class则不会在共享的全局对象上创建属性–这类声明会被共享且拥有相同的文档作用域，但它们不作为**JavaScript可以访问到的任何对象（比如window）的属性存在。\n综上，模块脚本和非模块脚本的共享命名空间不同，同时注意var function const let class的特殊性。\n你 \nJavaScript程序的执行首先，JavaScript程序的边界在哪里并没有正式的定义。其次，我们可以把JavaScript程序的执行想象成发生在两个阶段：\n\n第一阶段，文档内容加载完成，&lt;script&gt;指定的代码（外部&amp;内部）执行\n第二阶段：第一阶段文档加载完毕及所有代码运行之后，就是第二阶段。这个阶段是异步的、事件驱动的。\n\nJavaScript是单线程语言，所以客户端的程序一定要保证不会长时间运行，否则代码执行期间停止响应用户输入，严重影响体验，但这在有些情况下（比如计算密集型任务）是不可避免的。当然，Web平台提供了一种安全线程机制，补充了JavaScript这点的不足。\n客户端JavaScript时间线–之前粗略分的两个阶段可以进一步细化：\n\n浏览器创建Document对象并解析网页，不断添加Element对象和Text节点，此时document.readyState=&quot;loading&quot;\n对没有async defer 或 type=&quot;module&quot;的&lt;script&gt;标签，会先将其添加到文档，再执行其中的代码。若代码中有document.write()，会暂停解析。注意此时的（没有async defer 或 type=&quot;module&quot;）&lt;script&gt;标签只能看到自己和之前已解析的文档内容\n对有async的&lt;script&gt;标签，会下载完全后并执行，但解析器不会暂停等待下载，这类标签能看到自己和之前已解析的文档内容，也有可能看到更多的内容\n文档解析完成后，document.readyState=&quot;interactive&quot;\n对有defer和没有async的模块脚本，会按照其在文档中的出现顺序进行执行，这类标签能看到完整的文档内容\n浏览器在Document对象上派发DOMContentLoaded事件，标志第二阶段开始\n此时文档已完全解析，但浏览器会一直等所有外部资源（图片、音频等）都加载完，且所有async脚本都加载并执行完后，document.readyState=&quot;complete&quot;，并在Window对象派发load事件\n浏览器开始异步调用事件处理程序–即从这一刻起，对用户输入事件、网络事件、定时器超时等响应\n\n程序输入与输出输入的来源有文档内容本身、事件形式的用户输入、全局navigator属性等等\n输出的方式有DOM API、React等高级框架、console.log()等，但是这种输出只面向开发者用于调试，不能作为对用户的输出。\n程序错误在浏览器运行的JavaScript程序并不会真正“崩溃”，如果出现异常，其它没问题的已注册的函数会照常执行，当然，开发者可以自行编写错误处理程序，但那并不经常必需。\nWeb安全模型由于理论上JavaScript可以在用户的私人设备执行任意代码，因此存在明显的安全隐患，但Web应用的不断蓬勃发展是不可避免的，各浏览器厂商也在努力平衡两者。以下是解决安全隐患的一些策略 ：\n\n限制JavaScript的能力，比如不能像客户端删除或者写入文件\n同源策略，指对JavaScript代码能够访问和操作什么Web内容有一整套限制\n跨站点脚本（Cross-Site Scripting -- XSS）是一种攻击方式，需要程序员对此有所了解\n\n事件JavaScript使用异步事件驱动的编程模型，在这种编程风格下，浏览器会对尽可能多的对象在发生任何值得关注的事情时生成事件，比如点击、敲击键盘。这并非Web编程的专利，这是任何具有图形界面的应用都应该这么设计。\n事件类型类型上是字符串，表示发生了什么事，例如mousemove keydown等，也被称为事件名称\n\n设备相关输入事件\n设备无关输入事件\n用户界面事件\n状态变化事件\nAPI特定事件\n\n事件目标是一个对象，事件发生在该对象上或者与该对象有关\n事件对象是与特定事件关联的对象，包含有关该事件的细节，事件对象作为事件处理器程序的参数传入，且所有事件对象都包含type和target属性，分别表示事件类型和事件目标\n事件处理器（&#x2F;监听器）是一个函数，负责处理或响应事件，由应用通过浏览器注册，需要指明事件类型和事件目标，有两种注册事件处理器的方式：\n\n早期，设置为事件目标的对象或文档元素的一个属性，比如onload onclick等等：\n\n设置对象属性：例window.onload=function()&#123;/*处理程序的代码*/&#125;，但这样每个属性最多绑定一个事件处理程序\n\n设置文档元素属性：例&lt;button onclick=&quot;console.log(&#39;Clicked!&#39;);&gt;Click me&lt;/button&gt;&quot;，注意HTML属性中的JavaScript代码没有严格一说，可能存在意外变量的环境中执行，不容易排查bug（不推荐）\n\n\n\n通过addEventListener()将事件处理程序传给对象&#x2F;元素–任何可以作为事件目标的对象，都有这个方法：\n\n该方法接受三个参数：第一个是事件类型、第二个是事件发生时触发的函数、第三个可选–是一个布尔值或对象\n多次调用addEventListener()可以为同一对象同一事件类型绑定多个处理程序，执行顺序按注册顺序执行\n可选参数为布尔值时，代表注册为捕获事件处理程序；为对象时，规定以该形式：&#123;capture: 布尔值, once: 布尔值, passive: 布尔值&#125;\ncapture为true，代表注册为捕获事件处理程序\nonce为true，代表被触发一次后会自动移除\npassive为true，代表事件处理程序永远不调用preventDefault()取消默认动作\n以上若不设置，默认为false\n\n\n\n\n\n除此，需要注意事件处理程序被调用时会接收一个Event对象作为唯一的参数，整个对象提供了事件的详细信息：\n\ntype\ntarget\ncurrentTarget\ntimeStamp\nisTrusted\n等等\n\n\n取消注册的方法是removeEventListener()，参数和注册函数一模一样，只是第三个参数中只有capture有效–用于取消对应的事件捕获程序\n\n事件传播是一个过程，浏览器会决定在这个过程中，让哪些对象触发事件处理程序。如果事件的目标是Window或其他独立对象，浏览器对这个事件的响应就是简单地调用该对象上对应的事件处理程序，但如果事件目标是Document或其它文档元素，就没有那么简单。\n事件传播可以分为三个阶段：\n\n事件捕获：提供了把事件发送到目标之前先行处理的机会，最先调用的是Window对象上注册的捕获处理程序，然后才是Document，一直沿DOM树往下\n调用目标对象本身的事件处理程序\n事件冒泡：和捕获正好相反，沿DOM树网上直到Window，调用父节点&#x2F;元素的事件处理程序\n\n事件取消\n浏览器默认会对很多用户事件做出响应，比如点击链接会跳转、滑动滚轮浏览器会滚动等等，如果你需要为这些时间绑定自定义的处理程序，则可以调用事件对象的preventDefault()方法\n\nstopPropagation()：停止冒泡，阻止事件在 DOM 中继续冒泡\n\nstopImmediatePropagation()：与第二点类似\n\n\n派发自定义事件如果一个JavaScirpt对象有addEventListener()方法，那么它就是一个“事件对象”，那么就同样会有一个dispatchEvent()方法–该方法会向一个指定的事件目标派发一个 Event\n我们可以使用CustomEvent()构造函数创建一个自定义对象，然后传给dispatchEvent()方法\n操作DOMDOM API将文档组织成一个Node对象树，其中Node可以是Document、 Element、 Text节点或者Comment节点。客户端JavaScript程序操作文档中的一个或多个元素，首先是要以某种方式获取或选择表示该元素的Element对象\n选择Document元素\n**querySelect()和querySelectAll()**：\n\n参数：CSS选择符（例querySelect(&#39;button, input[type=&quot;button&quot;]&#39;)）\n特点：Element类和Document类都提供了querySelect()和querySelectAll()方法来选取元素，当在元素上调用时，只返回其后代中的元素（可以理解为沿DOM树向下）\n返回结果：\nquerySelect()返回的是一个**Element对象**或null\nquerySelectAll()返回的不是Element对象数组，而是一个类似数组的NodeList对象（可以理解为伪数组），但要注意该NodeList的length属性和其中包含的元素不会随着文档内容或结构的变化而变化\n\n\n注意：对于伪元素::first-line、::first-letter，该接口什么都找不到；同时，很多浏览器也拒绝对:link、:visited伪类返回结果，以保护用户隐私\n\n\n**closest()**：\n\n该方法是由Element类定义的，以选择符作为唯一参数，返回匹配的最近祖先元素（可以理解为沿DOM树向上匹配）\n\n\n其它选择元素的方法\n\n类似getElementById()、getElementByName()等方法，如今可以算废弃状态，不推荐使用\n\n\n\n文档结构与遍历在选择完的Element元素后，常常需要继续查找与其相关的部分（父亲、孩子、同辈），以下是常用的属性–可以引用其他节点：\n\n只有Element对象才有的属性–返回结果为Element对象或null–可以理解为在遍历一个Element对象树（会忽略文本Text节点）：\n\nchildElementCount\n\nfirstElementChild\n\nlastElementChild\n\npreviousElementSibling\n\nnextElementSibling\n\n\n\n所有Node节点都定义了的属性–不想忽略文本则使用如下属性：\n\nparentNode\n\nchildNodes\n\nfirstChild\n\nlastChild\n\npreviousSibling\n\nnextSibling\n\nnodeType\n\nnodeValue\n\nnodeName\n\n\n\n\n\n若只需要关心文档中的Element对象，不关心其中的文本Text，使用Element对象才有的属性，会忽略文档树中的Text、Comment节点\n\n属性HTML标签中的属性键值对，我们一般操作的方式有如下几种：\n\n使用Element类提供的getAttribute() \\ setAttribute() \\ hasAttribute() \\ removeAttribute()，用于查询、设置、检测和删除元素的属性，但是略显麻烦\n所有标准的HTML元素的标准属性，在对应的**HTMLElement对象上也有相应的JavaScript属性（且属性的值的数据类型**不变），此时使用JavaScript访问会更为便捷。（但是不能用delete来删除属性，一般用removeAttribute()）\n自定义的HTML元素属性一般规定以data-开头（小写），Element对象定义了dataset对象来保存这些自定义的HTML属性。例如dataset.x对应data-x的值，多个单词时–dataset.sectionNumber对应data-section-number的值（重要）\n\n\n一般来说，HTML的属性名是不区分大小写的，而镜像到JavaScript中要区分大小写（默认全部小写–多个单词则对应小驼峰命名法）\n除去上述的一般情况，还需注意如下不同：\n\n比如&lt;input&gt;的value属性对应defaultValue，而&lt;input&gt;中用户输入的值才对应value\nclass属性对应className，但考虑更改习惯，Element对象定义了classList属性（类数组对象）和四个方法add() \\ remove() \\ contains() \\ toggle()来修改class类属性\n\n\n元素内容元素的内容一般有两种表示（得看具体场景）：\n\nHTML表示–即标记字符串\n修改Element对象的innerHTML或outerHTML属性，就可以修改标签内的（或包括标签本身在内的）元素内容\n或者使用Element方法中的insertAdjacentHTML()，来插入与指定元素相邻的任意HTML标记字符串–该方法接受两个参数，第一个参数表示插入位置（关键字可选beforebegin \\ afterbegin \\ beforeend \\ afterend），第二个参数则是要出插入到内容\n\n\n纯文本表示–即不解析&#x2F;不转义\nNode类定义了textContent属性，适用于Text节点和Element节点，对于后者的返回结果为所有后代元素中的文本\nElement类定义了innerText属性，作用类似，但是有些BUG，故不推荐使用\n&lt;script&gt;中的文本永远不会被浏览器显示但是会出现在文档树中，理论上也可以作为嵌入任意文本数据的场所，只需要设置type属性为某个值，比如text/x-custom-data，然后使用text属性即可访问其保存的数据\n\n\n\n\n直接设置innerHTML或outerHTML的效率很高，因为浏览器本身就很擅长解析HTML，但是不推荐使用类似+=等操作符来追加文本，因为这要先序列化字符串再解析，效率不高\n\n创建、插入和删除节点这里讨论的节点一般指Element对象或Text节点，他们都是节点Node对象：\n\n创建Element对象：document.createElement()\n创建Text节点：document.createTextNode()（很少用）\n\nNode对象有在DOM树中插入、删除和替换节点的方法：\n\nappend()–把参数添加到孩子列表的末尾\nprepend()–把参数添加到孩子列表的开头\nafter()–在自身后面插入新内容\nbefore()–在自身前面插入新内容\nremove() –移除自己\nreplaceWith()–替换自己\n参数：除了remove()方法不接收参数，其它都接受任意多个参数，这些参数为Node对象或字符串（字符串会自动转换为Text节点）\n\n\n需要注意，append()和prepend()只在Element对象上有定义，after()和before()则同时存在于Element对象和Text节点上。\n被创建的元素只能插入到文档的一个地方，若重复插入，则以最后一次的新位置。可以使用cloneNode()方法创建新副本，传入true以复制全部内容，然后使用副本进行插入。\n像appendChild() insertBefore()等老式DOM API比这里介绍的更难用，不推荐使用它们\n\n操作CSS行内样式\n映射关系：HTML中元素的CSS属性对应Element对象上的style属性，是一个CSSStyleDeclaration对象，该对象的属性对应具体的CSS键值对\n命名约定：CSSStyleDeclaration对象属性名会剔除连字符，并将每个连字符后面的字母变为大写（例div.style.fontSize）\n属性值类型：CSSStyleDeclaration对象属性的所有值都是字符串，需要加上引号（但不需要把分号一起加进去）\n设置方法：直接修改属性值、使用getAttribute() setAttribute()、使用CSSStyleDeclaration对象的cssText属性\n\n计算样式同样以CSSStyleDeclaration对象表示，但有如下不同：\n\n是只读的\ncssText属性的值是undefined\n简写属性不会被计算（例如margin、border等），需要访问更基础的属性（例如marginLeft、borderLeftWidth等）\n计算样式的属性是绝对值，即返回px后缀的值\n\n操作样式表以下是几个常用的修改样式表的操作：\n\nstyle link标签对应的Element对象会有一个disable属性（值类型为布尔类型），用来启用&#x2F;禁用整个样式表\n使用DOM API，创建link标签并设置引用的样式表，然后插入到文档中\n使用标签的classList属性来添加&#x2F;移除样式\n\nCSS动画和事件JavaScript可以用来监控CSS过渡动画和复杂动画的进度，实现机制是浏览器在播放过渡动画和复杂动画期间会派发事件\n过渡动画：\n\ntransitionrun（首次出发过渡）\ntransitionstart（当发生视觉变化–考虑到延时）\ntransitionend（动画完成）\nelapsedTime属性是从transitionstart到结束经过的秒数\n\n动画animation同上类推\n文档几何与滚动对于Web应用–基于树的抽象文档模型，对于用户–基于几何坐标系的文档视图，下面就是对后者进行详细的介绍：\n文档坐标和视口坐标当页面不发生滚动时&#x2F;或文档比视口小，文档坐标的左上角和视口坐标的左上角是重合的。两者坐标系是相同的，x坐标向右表示增大，y坐标向下表示增大。 在JavaScript中最常用的是视口坐标，两坐标之间的转换，必须加上滚动位移（scroll offset）\n视口的定义：浏览器窗口实际显示文档内容的区域（不包含浏览器的外框，比如地址栏等）\n\n容器坐标：\n\n在使用position:fixed显示定位元素时，top left是相对视口坐标\n在使用position:relative相对定位元素时，top left是相对于没有给它设置position属性时的位置进行定位\n在使用position:absolute定位元素时，top left是相对文档或者最近的包含定位元素\n\n这也是为什么有“子绝父相”的定位设计套路\n\n查询元素的几何大小Element的getBoundingClientRect()方法可有其确定元素的大小，没有参数，返回结果是一个对象，有left right等等几何属性\ngetClientRects()返回的是一个只读的类数组对象，其元素类似getBoundingClientRect()返回的矩形对象\n确定位于某一点的元素Document的elementFromPoint()方法，接收一个点的x和y坐标–视口坐标（例如鼠标事件中的clientX和clentY），返回位于这个点上的元素（默认是该位置最内部、嵌套最深、最外层、最大z-index的）。\n滚动Window对象的scrollTo()方法接收一个点的x和y坐标–文档坐标，并设置滚动条的位移。该方法的作用是将指定的点移动（或尽可能接近）到视口的左上角。\nWindow对象的scrollBy()方法作用类似，只不过传入的点是相对值，会加在当前滚动位置之上\n这两个方法都能接收对象作为参数传入，控制更多的效果–下面这个例子则是让其平滑地滚动：\nwindow.scrollTo(&#123;    left: 0,    top: &quot;100px&quot;,    behavior: &quot;smooth&quot;&#125;)\n\n\n\nElement对象的scrollIntoView()方法，会让该元素移动到视口中可见为止，默认是让元素上边对齐或接近视口上沿。该方法接收唯一参数false，使元素底边尽量对齐视口下沿。\n该方法也接受一个对象作为参数传入，并可以设置更多属性，比如block、inline来设置垂直&#x2F;水平方向的定义效果（关键字为start end nearest center）\n视口大小、内容大小和滚动位置视口大小可以通过Window.innerWidth和Window.innerHeight属性得到\n文档的整体大小与**&lt;html&gt;元素**相同，即与document.documentElement的大小相同，可以使用该元素的getBoundingClientRect()方法，也可以使用offsetWidth和offsetHeight属性来获取宽高\n文档在视口中的滚动位移可以通过Window.scrollX和Window.scrollY获得（只读的）\n对于元素来说，情况更复杂一些，Element对象都定义了以下属性：\n\noffsetHeight\noffsetWidth\noffsetLeft\noffsetTop\noffsetParent\nclientHeight\nclientWidth\nclientLeft\nclientTop\nscrollHeight\nscrollWidth\nscrollLeft（可写属性）\nscrollTop（可写属性）\n\n\n具体含义可以查MDN文档，但好像不常用\n\nWeb组件组件定义：不断发展的Web标准允许JavaScript使用新标签扩展HTML，扩展后的标签就是自成一体、可重用的UI组件（比如一个好看的搜索框）\n使用Web组件Web组件是在JavaScript中定义，所以在使用之前，需要引入定义该组件的JS文件，且经常以JavaScript模块来实现（通过&lt;script type=&quot;module&quot;&gt;标签来引入HTML文件中）。然后详细阅读该组件的说明文档，了解使用方法。\n由于模块实在文档内容解析完之后加载，在此之前浏览器会尝试解析这些UI组件，这很正常，即在没有定义之前，浏览器就遇到并尝试解析它，此时浏览器会向DOM树中添加一个通用的HTMLElement，在加载了其定义后便会升级它。\nWeb组件同样支持子组件，机制是使用插槽slot来传递（后续会详细说明）\nHTML模板定义：当网页中包含多个重复的HTML结构时，可以使用&lt;template&gt;标签定义一次该结构，然后通过JavaScript按需重复使用该结构。虽然它和Web组件关系不大，但也能对频繁使用的组件进行优化。\n特点：&lt;template&gt;即其子元素永远不会被浏览器渲染，只能在使用JavaScript的网页中使用\n自定义元素定义：将一个HTML标签与一个JavaScript类关联起来，然后文档中出现的这个标签就会在DOM树中转化为相应的类的实例。\n做法：使用customElements.define()方法，第一个参数为Web组件的标签名（必须包含一个连字符），第二个参数为HTMLElement的子类（应当进行拓展，而不是使用一个已有的&#x2F;具体的子类，比如HTMLButtonElement，因为有的浏览器不支持）\n浏览器会自动调用自定义元素类的特定“生命期方法”：\n\nconnectedCallback()（被插入文档时调用）\ndisconnectedCallback()（从文档中移除时调用）\nobservedAttributes（静态类型，一个元素均为属性名的数组，具体什么属性由自己定义以及对应的读写方法）\nattributeChangeedCallback()（当observedAttributes中任何一个属性被修改时调用，传入属性名、旧值、新值）\n\n影子DOM定义：一个强大的封装机制，允许把一个“影子根节点”附加给一个（自定义）元素，后者被称为“影子宿主”。影子宿主与所有HTML元素不无二致，影子根节点则作为更私密的后代元素的根，仿佛一个迷你文档，“影子”则是指在这个迷你文档中的所有后代元素。（相反，影子DOM之外的DOM树被称为**阳光DOM**）\n区别：“影子DOM”这个子树并不属于常规DOM树，不会出现在常规DOM树的children数组中，对常规DOM API也不可见（比如querySeletor()，即隐藏且独立的。\n封装机制（关键特性）：\n\n创建影子根节点并附加于影子宿主时，可以指定模式为“开放”或“关闭”。前者意味影子宿主会获得一个**shadowRoot属性**，JavaScript可以通过这个属性来访问影子根节点的后代元素。\n\n影子根节点之下定义的样式是私有的（大多情况是完全独立的），不会影响外部元素。当然也可以被外部样式所覆盖。\n\n影子DOM中的事件部分会封闭在影子DOM中（比如load），部分则会向上冒泡、穿透影子DOM、target发生相应变化（比如focus）。\n\n\n对于影子宿主来说，它既包含原本的children[]数组，也包含被附加的影子DOM，实现两者同时显示的机制如下：\n\n影子根节点的后代始终显示在影子宿主内\n影子根节点的后代若包含一个&lt;slot&gt;元素，则宿主元素的阳光DOM子元素会作为&lt;slot&gt;的子元素一样显示，替代该插槽中的任何影子DOM元素。若此时宿主没有阳光DOM子元素，则该插槽中的影子DOM内容作为默认内容显示\n影子根节点的后代若不包含&lt;slot&gt;，则宿主的阳光DOM子元素永远不会显示\n影子根节点的后代若包含多个&lt;slot&gt;，且通过name属性为它们命名，则宿主的阳光DOM子元素可以通过设置slot=&quot;slotname&quot;属性，来决定自己出现在哪个插槽中。\n\n\n创建影子根节点并附加于影子宿主，通过调用宿主的attachShadow()方法，传入&#123;mode:&quot;open&quot;&#125;这个唯一的参数即可，返回值是影子根节点对象，同时也是宿主的shadowRoot属性的值，类型是DocumentFragment\n\n可伸缩矢量图形SVG(Scalable Vector Graphics)是一种图片格式，SVG图形是对绘制期望图形的精确的、分辨率无关的描述，是在**文本文件XML**标记语言描述的。SVG本身有一套语法规则，比较复杂。\n在HTML中使用SVG\n&lt;img&gt;标签中引入.svg图片\n直接使用&lt;svg&gt;标签嵌入SVG，还可以使用CSS样式控制字体、颜色、线宽等，更多语法可参考文档SVG：可缩放矢量图形 | MDN (mozilla.org)\n\n编程操作SVG使用&lt;svg&gt;标签的另一作用就是可以配合JavaScript更改状态\n通过JavaScript创建SVG图片SVG严格来说仍是XML标签，而不是HTML标签，所以创建时应该用createElementNS()，示例createElementNS(&quot;http://www.w3.org/2000/svg&quot;,&quot;svg&quot;)，第一个参数是固定的，表示XML命名空间文字串\n&lt;canvas&gt;与图形&lt;canvas&gt;标签本身在HTML文档中并不可见，它只是创建了一个绘图表面以及暴露了一套基于JavaScript的强大的绘图API。与SVG的区别就是要调用方法来绘图，而不是编辑XML文档\n在调用getContext()时传入&quot;webgl&quot;可以获得一个3D图形上下文，并使用WebGL API来绘制3D图形，实际开发大多使用基于WebGL的工具库，而不是直接使用WebGL API。\n路径与多边形绘制的思路：在使用canvas对象的getContext()方法获取图形上下文后，先新建路径，然后确定路径起点，再通过线段&#x2F;曲线段连接到下一个点（也被称为子路径），最后填充路径上的线或者被路径包围的区域\n涉及的API：\n\nbeginPath()（开始一个新路径）\n\nmoveTo()（开始一个子路径，参数为起点的x y坐标）\n\nlineTo()（用线段连接下一个点，参数为下一个点的x y坐标）\n\nclosePath()（关闭路径）\n\nstroke()（绘制路径中的线段）\n\nfill()（按路径绘制顺序的顺时针方向填充被路径包围的区域）\n\n\n\n必须重新建立一个路径才能画新的子路径，否则会一直在当前路径绘制\n\n画布的大小和坐标画布的大小就是&lt;canvas&gt;中width乘height，同时也是画布的实际像素数量。所以最好要搭配JavaScript在绘制图形前，将画布大小乘以window.devicePixelRatio来避免图形放大后变模糊。每个像素在内存中会分配四个字节。\n画布坐标系原点默认画布左上角，x向右增大，y向下增大。\n修改画布大小必须重置整个画布及其所有内容。\n\n（当然了，如果用户主动放大画布也可能导致变模糊）\n\n图形属性同CSS属性一样，绘制时的图形状态由画布的指定属性决定，而不是给绘制方法传入参数，这被称为图形状态与绘制指令分离，以下是常用的一些属性：\n\n线条样式\n颜色、模式与渐变\n文本样式\n阴影\n半透明与合成效果\n保存和恢复图形状态：每个&lt;canvas&gt;元素只有一个上下文对象，只允许定义一组图形属性，不过支持save()方法保存当前图形状态，restore()方法恢复最近一次保存的状态\n\n画布绘制操作除了之前基本的API，canvas还支持矩形、曲线、文本、位图图片等绘制方法\n坐标系变换每个画布的图形状态中都有一个”当前变换矩阵“，这个矩阵定义了画布的当前坐标系。多数画布操作中所指定的点是相对于当前坐标系的而不是默认坐标系，然后通过当前坐标变换矩阵将指定的点转化为默认坐标系中的点。\n可以使用setTransform()方法更改当前变换矩阵，也可以使用translate() rotate() scale()来变换当前坐标系（更实用） \n剪切clip()方法可以定义一个剪切区域，这个区域外部将不会被绘制。\n特点：当前路径本身会被剪切为当前的剪切区域，同时变为下一次剪切的当前路径，即剪切区域会越来越小，且没有办法重置剪切区域，所以最好要先保存以便恢复再剪切\n像素操作像素级别的操作，有三个方法：\n\ngetImageData()\ncreateImageData()\nputImageData()\n\nAudio API想要在HTML文档中播放音乐，不一定要在其中包含&lt;audio&gt;或&lt;video&gt;元素，可以直接使用Audio构造函数动态创建audio元素，然后调用play()方法播放即可\nWebAudio API需要了解一定的电子音乐和信号处理知识，自己合成声音并播放\n位置、导航与历史Window和Document对象的location属性引用的都是Location对象，该对象表示当前窗口显示的文档URL，可以使用protocal hostname等基本属性，也提供了在窗口中加载新文档的API。\n给Location对象赋值一个字符串，会被解释为一个URL，然后浏览器会加载它，替换当前文档。值得注意，这样做会增加一条历史记录，而使用该对象的replace()方法则会将当前记录替换掉。\nWindow对象的history属性引用的是当前窗口的History对象，表示当前窗口的文档和文档状态列表。\n管理历史记录：\n\nhashchange事件\nhistory.pushState()方法\n\n网络fetch()\n使用步骤：\n\n调用fetch()，传入需要获取内容的URL\n在HTTP相应开始到达时取得第一步异步返回的响应对象，然后调用这个对象的某个方法，读取响应体\n取得第二步异步返回的响应体，按需处理它\n\n\n处理细节：\n\nHTTP状态码、响应头和网络错误\n\n设置请求参数 \n\n设置请求头部\n\n解析响应体\n\n流式访问响应体\n\n指定请求方法和请求体\n\n通过fetch()上传文件\n\n跨源请求\n\n其他请求选项\n\n\n\n\n服务器发送事件 HTTP天生不具备”在服务器发生事件时，接收来自服务器发送的通知“这种特性，但客户端可以选择在发送完请求后，两端都不关闭连接，此时服务器一旦有时间要通知客户端，可以将数据写入这个连接并保持打开。若连接关闭，客户端可以再次请求，重新打开一个新连接。\n客户端可以使用EventSource API来实现这种长时间的连接。两端通过SSE(Server-Sent Event,服务器发送事件)协议传输信息。\nWebSocketWebSocket API是一个复杂、强大的网络协议对外暴露的简单接口。\n它与SSE相同的是，客户端必须建立连接，然后服务端才可以异步向客户端发送消息；不同的是，WebSocket支持二进制消息，而且消息可以双向发送\n支持WebSocket的网络协议是对HTTP的拓展，WebSocket的标识连接端点不是IP和端口号，且WebSocket URL是以ws://开头，更重要的是，想要建立WebSocket连接，浏览器首先要建立一个HTTP连接，同时服务器也必须支持WebSocket协议。\n\n创建、连接和断开协议\n通过WebSocket发送消息、接收消息\n协议协商\n\nlet socket = new WebSocket(&quot;wss://example.com/stockticker&quot;)\n\n\n\n存储Web应用可以使浏览器API在用户计算机本地存储数据，目的为了让浏览器记住一些信息。客户端存储遵守按照来源隔离，不同站点的数据互相不可访问，同一站点不同页面的数据可以互通（也算一种通信机制）。下面是客户端存储的几种形式：\nlocalStorage和sessionStorage这两个属性都是引用的window对象的Storage对象，有以下特点：\n\nStorage对象的属性值必须是字符串\nStorage对象中存储的属性是持久化的，用户刷新了页面仍可以访问之前存储的信息\n相关方法有getItem() setItem() deleteItem() clear()\n\n生命周期和作用域：\nlocalStorage的存储周期是永久，除非用户手动删除。它的作用域是所有同源文档（同源：相同协议、域名和端口），即在作用域内是共享的，不过也会受浏览器限制，不同浏览器访问同一页面，它们的数据是互相不可见的。\nsessionStorage的存储周期取决于存储它的脚本所属的顶级窗口或浏览器标签，窗口或标签被永久关闭后，数据也随之删除。目前浏览器有恢复上次关闭的标签功能，所以数据存储周期看起来会更长一些。sessionStorage的作用域在窗口或标签页间隔离。\n存储事件：存储在localStorage中的数据发生变化时，都会触发Window对象的storage事件，事件范围是所有当前浏览同一网站的窗口。\ncookiecookie是浏览器为特定网页或网站保存的少量命名数据，为服务端编程而设计的，会自动在浏览器与Web服务器之间传输。客户端则使用document.cookie来操作cookie属性\ncookie的属性主要是一组键值对，也包括用于控制生命周期和作用域的可选属性，比如max-age表示保存时间（单位秒）\ncookie的可见性（即作用域）有文档来源、文档路径决定：\n\n文档路径是可以通过path属性来设置。默认情况是，cookie关联着创建它的网页，以及与该网页位于相同目录和子目录下的其他网页。\n文档来源则可以通过domain属性来控制，在一些大网站中往往需要跨子域名共享cookie，比如cat.example.com和dog.example.com，则可以设置domain=&quot;.example.com&quot;来实现共享。不可以设置为服务器父域名之外的其他域名。\n\ncookie另一个属性secure，类型为布尔值，用于指定如何通过网路传输cookie值。默认是false，表示cookie是不安全的，会在普通的不安全http连接上传输。相反，那么就只能在浏览器与服务器通过https或其他安全协议连接时传输。\nIndexedDB它是一个对象数据库，作用域为包含文档的来源，每个来源可以有任意多个IndexedDB数据库，但数据库名要唯一。\n对于IndexedDB API来说，数据库就是一个名为对象存储的集合，对象存储中存储的是对象。每个对象必须有一个键，可以用于排序和检索。也可以在创建对象存储时指定一个属性为”键路径“，可以理解为索引，对象存储上可以定义任意数量的索引。\nIndexedDB存储特性之一为原子性，查询和更新会按照事务分组，要么全部成功，要么全部失败。、\n操作步骤：\n\n打 开对应的数据库（通过名字）\n创建一个事务对象（必须）\n并使用该事务对象查找数据库中相应的对象存储（通过名字）\n最后通过该对象存储的get()方法查询对象、put()方法存储新对象（会覆盖已有对象）、add()方法添加新对象（不覆盖）\n按范围查询，则需要创建一个IDBRange对象并指定范围边界，然后作为参数传给查询方法get() 、getAll() 或 openCursor()\n\n异步性：\nIndexedDB API是异步且基于事件，而不是基于期约，所以**不能用async await**来调用API。\n事件：\n除了创建事务、查找对象存储是同步，打开数据库、更新对象存储和查询存储或索引都是异步操作。这些异步方法都会立即返回一个请求对象，浏览器会在请求失败&#x2F;成功后触发失败&#x2F;成功事件onerror/onsuccess，只有成功才能调用请求对象的result属性，即操作结果。\n事务成功完成后，事务对象上会派发complete事件。\n第一次打开一个数据库&#x2F;增大一个已有数据库版号时，indexedDB.open()返回的请求对象会触发upgradeneeded事件，这意味着你需要在事件处理程序中手动定义或更新数据库的模式，比如创建对象存储以及在对象存储上定义索引。\n\n存储的对象使用结构化克隆算法序列化为对象存储，支持对象属性值为Map Set等类型\n\n工作线程和消息传递JavaScript是单线程编程语言，因此浏览器不可能同时运行两个事件处理程序，也不会在运行一个事件处理程序的同时触发其他计时器，这样就无法并发更新文档状态或Web应用，且长时间运行某个函数，因为会导致事件循环阻塞。\n浏览器通过Worker类提供了能与主线程和事件循环同时运行的线程，这种线程适合计算&#x2F;执行密集型任务，比如图像处理、实时解析用户输入等任务。\nWork类运行于独立的环境，拥有完全独立的全局对象，且只能通过异步消息机制与主线程通信，故不能并发修改Window和Document对象，但是能很好地支持长时间运行的函数，不必担心阻塞事件循环、卡死浏览器。\nWorker对象使用步骤：\n\n创建新的工作线程\n调用Worker()构造函数，传入URL–指定需要执行的JavaScript代码。（支持相对&#x2F;绝对路径）\n\n\n向工作线程发送数据\n使用postMessage()方法，出给该方法的值会被结构化克隆算法复制一份副本，然后通过事件发送给工作线程\n\n\n从工作线程接收消息\n使用onmessage或者addEventListener()，消息保存在事件对象的data属性中（同理支持removeEventListener()）\n\n\n强制停止工作线程\n这也是Worker对象最后的方法了terminate()\n\n\n\n示例：\nlet w = new Worker(&quot;utils/testWorker.js&quot;)w.postMessage(&quot;Hello！&quot;)w.onmessage = function(e)&#123;    let stats = e.data    console.log(stats)&#125;\n\n\n\n工作线程中的全局对象在上一节提到，Worker()构造函数中的URL所指定的代码会被放在也给新的、干净的JavaScript执行环境中执行，与创建工作线程的脚本完全隔离，这个新环境中的全局对象是一个WorkerGlobalScope对象，组成内容比JavaScript核心多一些东西，比客户端**Window对象少一点东西，也就是说大部分客户端JavaScript能做的，工作线程里也能做到**，甚至是嵌套创建自己的工作线程。\n和主线程通信：\n\n该全局对象也有postMessage()和onmessage事件处理程序，只不过和Worker对象中的目标及方向正好相反。\n\nWorker()对象支持传入一个对象作为第二个参数，该对象中的属性会作为WorkerGlobalScope对象的属性\n\n该全局对象可以调用close()方法终止自己，效果同terminate()0 \n\n\n在工作线程中导入代码浏览器支持Worker的时候，JavaScript还不支持模块系统，所以工作线程有一套独特的导入外部代码机制，即importScripts()方法，参数为需要载入的外部代码文件路径。\n该方法是同步的，且不会跟踪已加载的脚本，也不会阻止循环依赖\n工作线程也支持导入模块，只需要在Worker()构造函数的第二个参数中，设置属性type=&quot;module&quot;\n工作线程执行模型执行顺序也分同步阶段和异步阶段，前者是自上而下运行自己的代码和导入所有模块及脚本，后者则是开始对事件和定时器进行监听和响应。\n工作线程会在不可能启动新任务的时候，自动安全退出。一般不建议工作线程主动终止自己\n工作线程中的错误，如果没有被捕获且适当处理，则会在全局对象上触发error事件\n消息端口对象前几节讲的postMessage()函数实质是调用在创建工作线程时一起创建的一对MessagePort消息端口对象的postMessage()方法实现通信的，客户端JavaScript无法直接访问这两个端口对象，但是可以通过MessageChannel()构造函数创建一对新的关联端口。示例如下：\nlet channel = new MessageChannellet userPort = channel.port1let workPort = channel.port2\n\nMessageChannel对象有两个属性port1 port2，这两个属性引用一对关联的MessagePort对象，可以互相通信，即通过postMessage()方法和onmessage事件处理程序。\n通信过程中，所发送的消息会先被存在一个队列中，直到端口定义了onmessage属性或者同时调用了addEventListener()以及start()方法（重要），才会被信道的另一端接收。\npostMessage()方法支持第二个参数（数组类型），代表把数组中的元素移动到（而不是复制）信道的另一端。\n这样可以让多个信道与主线程通信，只需要把MessagePort对象通过postMessage()方法移到信道的另一端，然后通过消息对象取出和使用。需要注意，此时端口对象需要同时出现在postMessage()方法的第一个和第二个参数中，才能使该端口对象在主线程失效。\n通过postMessage()跨源发送消息同理，不同源的Window对象也可以使用自带的postMessage()方法互相通信。不过参数列表会有些不同。\n\n即便同源策略阻止脚本访问另一个窗口的内容，仍然可以调用另一个窗口的postMessage()方法，来触发该窗口的message事件处理程序。\n\nNode服务器端JavaScriptNode是Javascript与底层操作系统绑定的结合，从而让JavaScript程序读写文件、执行子进程以及实现网络通信，让JavaScript成为一种通用的编程语言。Node的典型特点是其默认异步的API赋能的单线程基于事件的并发能力。\nNode程序的构成控制台输出console.log是向标准输出流发送输出的主要方式\n命令行和环境变量Node遵循Unix的惯例，程序的输入首先是从命令行参数获取，其次是从环境变量中获取，前者可以从字符串process.argv中获取，后者从process.env中获取\n程序的生命期Node基本是自顶向下执行文件中的Javascript代码，很多Node程序会在执行完文件里的最后一行代码时退出，不过，也有很多会在此之后持续运行很长一段时间。Node程序通常是异步的，基于回调和事件处理程序，且在运行完初始文件、调用完所有回调、不再有未决之事之前不会退出。\n由于Node程序天生异步，发生在回调和事件处理程序中的异常必须局部处理。\nNode模块Node是在JavaScript有模块系统之前创造的，所以Node必须自己创造一个模块系统（也被称为CommonJS模块），使用require() module.expxorts来处理模块的值的导入&#x2F;导出。Node 13增加了对ES6模块的支持，但ES6模块和CommonJS模块并不完全兼容，故Node在加载模块之前，会通过文件拓展名、package.json文件等方式确定模块的类型。\nNode包管理器一个名为npm的程序会随着node一并安装，这就是Node的包管理器，它通过位于程序根目录的package.json文件（同样是由npm创建的）帮助你下载和管理程序的依赖库\n异步api和并发风格Node不是通过线程来实现并发的，这一点与大多数编程语言不同。Node是针对I/O密集型程序（比如网络服务器）进行优化的，这一点和Javascript的通用性有所不同。\nNode通过让其API默认异步和非阻塞（当然也有同步的api，并带有Sync的字样）来实现高层次的并发，并同时保持单线程的编程模型。一般来说，你传给异步Node函数的最后一个参数始终是一个回调。除此之外，Node也有一些API使用基于事件的异步机制，通常用于处理流数据。\n基于事件的并发的核心是Node用单线程是运行一个“事件循环”，有事件时工作没有则进入睡眠状态，如此循环。\n基本数据类型、缓冲区和流Node中一个比较常用的数据类型Buffer，常用于从文件或网络数据中读取数据。Buffer类（或称为缓冲区），是字节序列，是设计用来操作Javascript字符串的，当然也常用于操作二进制数据。\n在一般处理数据的算法中，会将要处理的所有数据读取到内存中，进行处理，再把数据写到某个地方。这种方式要求要有足够大的内存空间，还可能扛不住高并发的请求，在一个缺点就是不能在读旧文件之前就写新文件。解决这类问题的办法就是使用“流”，Node支持可读流、可写流、双工流和转换流。  \n有时候需要从流中读取的数据写入另一个流，可以简单管道进行连接，必要时可以自定义一个流。\n操作文件系统Node的fs模块是用于操作文件和目录的综合性API，path模块是fs模块的补充。fs模块中大多是对Unix系统调用（及其Window对应操作）的低级绑定，但也有很多高级函数，以及相应定义了大量变体，比如基于同步阻塞的变体、基于期约的异步变体。\n编写http客户端和服务端Node的http https http2模块是功能完整但相对低级的HTTP协议的实现，定义了实现HTTP客户端和服务端的所有API，可以用来开发简单的服务器\n编写非http客户端和服务端Node完全支持其它类型的网络服务器和客户端，使用net模块就可以建立tcp服务器\n创建子线程和子线程通信Node同样非常适合编写执行其他程序的脚本，常用到child_process模块。\n多线程编程Node的并发模型是基于单线程、基于事件的，但从第十版开始支持正真的多线程编程，提供了由浏览器定义的Web Workers API非常相似的一套API。JavaScript线程默认不共享内存，只能通过消息传递来通信。主要工作是处理工作线程和父线程之间的通信。\n参考[ 2 ]: https://book.douban.com/subject/35175321/\t“JavaScript高级程序设计（第四版）”[ 3 ]: https://book.douban.com/subject/35396470/\t“JavaScript权威指南（第七版）”[ 4 ]: https://www.bilibili.com/video/BV1Y84y1L7Nn “黑马程序员前端JavaScript入门到精通”\n","categories":["学习记录"],"tags":["JavaScript"]},{"title":"【学习记录】重构","url":"/2023/05/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E3%80%8A%E9%87%8D%E6%9E%84%20-%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89%E3%80%8B/","content":"我在阅读《重构·改善既有代码的设计》（第二版）之前，总是很随意地使用“重构”这个词。\n 重构可以作为名词，也可以当作动词。前者指对软件内部的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。后者指使用一系列手法，在不改变软件可观察行为的前提下，调整其结构。（–均摘自书中原话）\n重构应该是一系列（能完美彼此组合的）小步骤构成的，是一类特定的结构调整。重构期间不会导致代码处于不可用状态，否则就不是在进行重构。\n重构vs.性能优化：\n两者区别在于目的不同，前者旨在“让代码更容易理解，更易于修改”，但可能会造成程序运行的更慢或者更快。后者旨在“让程序运行得更快”，但可能会造成程序更难理解和维护。\n既有代码场景：\n\n客户(&#96;&#96;customer)**指定几出剧目(play&#96;)让剧团表演**\n剧团根据观众人数(audience)及剧目类型（悲剧&#96;&#96;tragedy和喜剧comedy&#96;）来向客户收费\n发放账单\n剧团根据到场观众数量累计积分优惠(&#96;&#96;volume credit&#96;)，下次观演可使用此积分进行抵扣\n\n 既有代码方案（以JavaScript实现为例）：\nplays.json：存放剧团已有的剧目\n&#123;    &quot;hamlet&quot;: &#123;&quot;name&quot;: &quot;Hamlet&quot;,&quot;type&quot;:&quot;tragedy&quot;&#125;,    &quot;as-like&quot;: &#123;&quot;name&quot;: &quot;As You Like It&quot;,&quot;type&quot;:&quot;comedy&quot;&#125;,    &quot;othello&quot;: &#123;&quot;name&quot;: &quot;Othello&quot;,&quot;type&quot;:&quot;tragedy&quot;&#125;&#125;\n\n\n\ninvoices.json：存放开出的账单\n[    &#123;        &quot;customer&quot;: &quot;BigCo&quot;,        &quot;performances&quot;: [            &#123;                &quot;playID&quot;:&quot;hamlet&quot;,                &quot;audience&quot;55            &#125;,            &#123;                &quot;playID&quot;:&quot;as-like&quot;,                &quot;audience&quot;35               &#125;,            &#123;                &quot;playID&quot;:&quot;othello&quot;,                &quot;audience&quot;40               &#125;        ]    &#125;]\n\n既有代码：只有一个打印账单详情的函数，效果如下\nStatement for BigCo  Hamlet: $650.00 (55 seats)  As You Like It: $580.00 (35 seats)  Othello: $500.00 (40 seats)Amount owed is $1,730.00You earned 47 credits\n\nfunction statement (invoice,plays)&#123;    let totalAmount = 0;    let volumeCredits = 0;    let result = `Statement for $&#123;invoice.customer&#125;\\n`;    const format = new Intl.NumberFormat(&quot;en-US&quot;,    &#123;        style:&quot;currency&quot;,currency:&quot;USD&quot;,        minimumFractionDigits:2    &#125;).format;    for(let perf of invoice.performances)&#123;        const play = plays[perf.playID];        let thisAmount=0;                switch(play.type)&#123;            case &quot;tragedy&quot;:                thisAmount = 40000;                if(perf.audience&gt;30)&#123;                    thisAmount+=1000*(perf.audience-30);                &#125;                break;            case &quot;comedy&quot;:                thisAmount=30000;                if(perf.audience&gt;20)&#123;                    thisAmount+=10000+500*(perf.audience-20);                &#125;                thisAmount+=300*perf.audience;                break;            default:                throw new Error(`unknown type: $&#123;play.type&#125;`);        &#125;        // add volume credits        volumeCredits += Math.max(perf.audience-30,0);        //add extra credit for every ten comedy attendees        if(&quot;comedy&quot;===play.type)volumeCredits+=Math.floor(perf.audience/5);        //print line for this order        result += `$&#123;play.name&#125;: $&#123;format(thisAmount/100)&#125; ($&#123;perf.audience&#125; seats)\\n`        totalAmount += thisAmount;    &#125;    result += `Amount owed is $&#123;format(totalAmount/100)&#125;\\n`    result += `You earned $&#123;volumeCredits&#125; credits\\n`;    return result;&#125;\n\n可以看出这段代码组织的不够清晰，但也可以容忍（毕竟只是这么小的一个程序），但如果这个函数是处于一个庞大的系统中，类似这样把所有代码放在一个函数里就很难理解了。让人困惑的同时也让人难以修改和添加新功能。\n重构第一步确保修改的代码拥有一组可靠的测试\n对于这个函数，他的输入是账单（invoice）和剧目单，返回的是一个字符串。我只需要新建几个账单，并手动计算出最终字符串，然后与每次代码生成的字符串进行对比校验即可\n而这一步骤，可以通过测试框架来配置好\n接下来我们来关注代码：\n重构 – 小步前进提炼函数（106）要将我的理解转化到代码里，得先将这块代码抽取成一个独立的函数，按它所干的事情给它命名，比如叫 amountFor(performance)。每次想将一块代码抽取成一个函数时，我都会遵循一个标准流程，最大程度减少犯错的可能。我把这个流程记录了下来，并将它命名为提炼函数（106），以便日后可以方便地引用\n 注意作用域（以JavaScript举例），子函数位于父函数作用于下，那么子函数用到父函数的参数时，不用再写进函数声明了。\n第一个引起我注意的就是中间那段 switch 语句，以我的理解他就是计算费用的，可以提炼成一个函数\n// ================= 提炼函数（106） ================function amountFor(perf, play) &#123;  let thisAmount = 0;  switch (play.type) &#123;  case &quot;tragedy&quot;:    thisAmount = 40000;    if (perf.audience &gt; 30) &#123;      thisAmount += 1000 * (perf.audience - 30);    &#125;    break;  case &quot;comedy&quot;:    thisAmount = 30000;    if (perf.audience &gt; 20) &#123;      thisAmount += 10000 + 500 * (perf.audience - 20);    &#125;    thisAmount += 300 * perf.audience;    break;  default:      throw new Error(`unknown type: $&#123;play.type&#125;`);  &#125;  return thisAmount;&#125;// ================= statement ================function statement (invoice, plays) &#123;  let totalAmount = 0;  let volumeCredits = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  const format = new Intl.NumberFormat(&quot;en-US&quot;,                        &#123; style: &quot;currency&quot;, currency: &quot;USD&quot;,                          minimumFractionDigits: 2 &#125;).format;  for (let perf of invoice.performances) &#123;    const play = plays[perf.playID];    let thisAmount = amountFor(perf, play);//提炼函数（106）     // add volume credits    volumeCredits += Math.max(perf.audience - 30, 0);    // add extra credit for every ten comedy attendees    if (&quot;comedy&quot; === play.type) volumeCredits += Math.floor(perf.audience / 5);    // print line for this order    result += ` $&#123;play.name&#125;: $&#123;format(thisAmount/100)&#125; ($&#123;perf.audience&#125; seats)\\n`;    totalAmount += thisAmount;  &#125;  result += `Amount owed is $&#123;format(totalAmount/100)&#125;\\n`;  result += `You earned $&#123;volumeCredits&#125; credits\\n`;  return result;\n\n‘编译’、测试、提交代码（建议每次重构后，都要进行一遍这个流程）\n提炼函数（106）– 增加表达能力 – 改名完成提炼函数（106）手法后，我会看看提炼出来的函数，看是否能进一步提升其表达能力。一般我做的第一件事就是给一些变量改名，使它们更简洁，比如将 thisAmount 重命名为 result。\n这是我个人的编码风格：永远将函数的返回值命名为“result”，这样我一眼就能知道它的作用。\n使用一门动态类型语言（如 JavaScript）时，跟踪变量的类型很有意义。因此，我为参数取名时都默认带上其类型名。一般我会使用不定冠词修饰它，除非命名中另有解释其角色的相关信息，这是我的另一个代码风格，这里将perf改为了aPerformance\nfunction amountFor(aPerformance, play) &#123;  let result = 0;  switch (play.type) &#123;  case &quot;tragedy&quot;:    result = 40000;    if (aPerformance.audience &gt; 30) &#123;      result += 1000 * (aPerformance.audience - 30);    &#125;    break;  case &quot;comedy&quot;:    result = 30000;    if (aPerformance.audience &gt; 20) &#123;      result += 10000 + 500 * (aPerformance.audience - 20);    &#125;    result += 300 * aPerformance.audience;    break;  default:      throw new Error(`unknown type: $&#123;play.type&#125;`);  &#125;  return result;&#125;\n\n\n\n以查询取代临时变量（178）当我分解一个长函数时，我喜欢将play这样的变量移除掉，因为它们创建了很多具有局部作用域的临时变量，这会使提炼函数更加复杂。play 变量是由 performance 变量计算得到的，因此根本没必要将它作为参数传入\n// ================= 以查询取代临时变量（178） ================function playFor(aPerformance) &#123;  return plays[aPerformance.playID];&#125;// ================= 提炼函数（106）: amountFor(aPerformance) ================function amountFor(aPerformance,play)&#123;...&#125; // ================= 以查询取代临时变量（178） ================function statement (invoice, plays) &#123;  let totalAmount = 0;  let volumeCredits = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  const format = new Intl.NumberFormat(&quot;en-US&quot;,                        &#123; style: &quot;currency&quot;, currency: &quot;USD&quot;,                          minimumFractionDigits: 2 &#125;).format;  for (let perf of invoice.performances) &#123;    const play = playFor(perf);//以查询取代临时变量（178）    let thisAmount = amountFor(perf, play);//提炼函数（106）     // add volume credits    volumeCredits += Math.max(perf.audience - 30, 0);    // add extra credit for every ten comedy attendees    if (&quot;comedy&quot; === play.type) volumeCredits += Math.floor(perf.audience / 5);    // print line for this order    result += ` $&#123;play.name&#125;: $&#123;format(thisAmount/100)&#125; ($&#123;perf.audience&#125; seats)\\n`;    totalAmount += thisAmount;  &#125;  result += `Amount owed is $&#123;format(totalAmount/100)&#125;\\n`;  result += `You earned $&#123;volumeCredits&#125; credits\\n`;  return result;\n\n使用内联变量（123）// ================= 以查询取代临时变量（178） ================function playFor(aPerformance) &#123;  return plays[aPerformance.playID];&#125;// ================= 提炼函数（106）: amountFor(aPerformance)， 使用内联变量（123） ================function amountFor(aPerformance , play ) &#123;  let result = 0;  switch (playFor(aPerformance).type) &#123;// 使用内联变量（123）  case &quot;tragedy&quot;:    result = 40000;    if (aPerformance.audience &gt; 30) &#123;      result += 1000 * (aPerformance.audience - 30);    &#125;    break;  case &quot;comedy&quot;:    result = 30000;    if (aPerformance.audience &gt; 20) &#123;      result += 10000 + 500 * (aPerformance.audience - 20);    &#125;    result += 300 * aPerformance.audience;    break;  default:      throw new Error(`unknown type: $&#123;playFor(aPerformance).type&#125;`);// 使用内联变量（123）  &#125;  return result;&#125;// ================= 以查询取代临时变量（178） ================function statement (invoice, plays) &#123;  let totalAmount = 0;  let volumeCredits = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  const format = new Intl.NumberFormat(&quot;en-US&quot;,                        &#123; style: &quot;currency&quot;, currency: &quot;USD&quot;,                          minimumFractionDigits: 2 &#125;).format;  for (let perf of invoice.performances) &#123;    const play = playFor(perf);//以查询取代临时变量（178）    let thisAmount = amountFor(perf, playFor(perf));//提炼函数（106） 使用内联变量（123）    // add volume credits    volumeCredits += Math.max(perf.audience - 30, 0);    // add extra credit for every ten comedy attendees    if (&quot;comedy&quot; === play.type) volumeCredits += Math.floor(perf.audience / 5);    // print line for this order    result += ` $&#123;play.name&#125;: $&#123;format(thisAmount/100)&#125; ($&#123;perf.audience&#125; seats)\\n`;    totalAmount += thisAmount;  &#125;  result += `Amount owed is $&#123;format(totalAmount/100)&#125;\\n`;  result += `You earned $&#123;volumeCredits&#125; credits\\n`;  return result;\n\n改变函数声明（124）amountFor我可以对 amountFor 函数应用改变函数声明（124），移除 play 参数\n第一步是在amountFor内使用新提炼的playFor函数进行内联\n第二步是在statement内有关amountFor的调用点进行内联\nfunction statement (invoice, plays) &#123;  let totalAmount = 0;  let volumeCredits = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  const format = new Intl.NumberFormat(&quot;en-US&quot;,                        &#123; style: &quot;currency&quot;, currency: &quot;USD&quot;,                          minimumFractionDigits: 2 &#125;).format;    for (let perf of invoice.performances) &#123;    // add volume credits    volumeCredits += Math.max(perf.audience - 30, 0);    // add extra credit for every ten comedy attendees    if (&quot;comedy&quot; === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);    // print line for this order    result += ` $&#123;playFor(perf).name&#125;: $&#123;format(amountFor(perf)/100)&#125; ($&#123;perf.audience&#125; seats)\\n`;//使用内联变量（123）    totalAmount += amountFor(perf);  &#125;  result += `Amount owed is $&#123;format(totalAmount/100)&#125;\\n`;  result += `You earned $&#123;volumeCredits&#125; credits\\n`;  return result;\n\n\n\nvolumeCreditsFor提炼计算观众量积分的逻辑\nfunction volumeCreditsFor(aPerformance) &#123;  let result = 0;  result += Math.max(aPerformance.audience - 30, 0);  if (&quot;comedy&quot; === playFor(aPerformance).type)    result += Math.floor(aPerformance.audience / 5);  return result;&#125;\n\n\n\nformat移除函数变量format，改为函数声明。但是要注意函数命名，比如format 未能清晰地描述其作用，formatAsUSD 很表意，但又太长，特别它仅是小范围地被用在一个字符串模板中。\n我认为这里真正需要强调的是，它格式化的是一个货币数字，因此我选取了一个能体现此意图的命名，并应用了改变函数声明（124）手法。\n即要注意，强调的重点是什么，适用范围在哪里，才能更好的命名\nfunction usd(aNumber) &#123;  return new Intl.NumberFormat(&quot;en-US&quot;, &#123;    style: &quot;currency&quot;,    currency: &quot;USD&quot;,    minimumFractionDigits: 2,  &#125;).format(aNumber / 100);&#125;\n\n拆分循环（227）我的下一个重构目标是 volumeCredits。处理这个变量更加微妙，因为它是在循环的迭代过程中累加得到的。第一步，就是应用拆分循环（227）将 volumeCredits 的累加过程分离出来。\nfunction statement (invoice, plays) &#123;  let totalAmount = 0;  let volumeCredits = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  for (let perf of invoice.performances) &#123;//拆分循环（227）    // print line for this order    result += ` $&#123;playFor(perf).name&#125;: $&#123;usd(amountFor(perf))&#125; ($&#123;perf.audience&#125; seats)\\n`;    totalAmount += amountFor(perf);  &#125;  for (let perf of invoice.performances) &#123;//拆分循环（227）    volumeCredits += volumeCreditsFor(perf);  &#125;result += `Amount owed is $&#123;usd(totalAmount)&#125;\\n`;result += `You earned $&#123;volumeCredits&#125; credits\\n`;return result;\n\n移动语句（223）将变量声明挪动到紧邻循环的位置\nfunction statement (invoice, plays) &#123;  let totalAmount = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  for (let perf of invoice.performances) &#123;    // print line for this order    result += ` $&#123;playFor(perf).name&#125;: $&#123;usd(amountFor(perf))&#125; ($&#123;perf.audience&#125; seats)\\n`;    totalAmount += amountFor(perf);  &#125;  let volumeCredits = 0;//移动语句（223）  for (let perf of invoice.performances) &#123;    volumeCredits += volumeCreditsFor(perf);  &#125;  result += `Amount owed is $&#123;usd(totalAmount)&#125;\\n`;  result += `You earned $&#123;volumeCredits&#125; credits\\n`;  return result;\n\n把与更新 volumeCredits 变量相关的代码都集中到一起，有利于以查询取代临时变量（178）手法的施展\nfunction totalVolumeCredits() &#123;  let volumeCredits = 0;  for (let perf of invoice.performances) &#123;    volumeCredits += volumeCreditsFor(perf);  &#125;  return volumeCredits;&#125;\n\n同样是先对变量的计算过程应用提炼函数（106）手法、再以查询取代临时变量（178），然后使用内联变量（123）\nfunction statement (invoice, plays) &#123;  let totalAmount = 0;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  for (let perf of invoice.performances) &#123;    // print line for this order    result += ` $&#123;playFor(perf).name&#125;: $&#123;usd(amountFor(perf))&#125; ($&#123;perf.audience&#125; seats)\\n`;    totalAmount += amountFor(perf);  &#125;  result += `Amount owed is $&#123;usd(totalAmount)&#125;\\n`;  result += `You earned $&#123;totalVolumeCredits()&#125; credits\\n`;//使用内联变量（123）  return result;\n\n类似的，对totalAmount进行提炼、取代临时变量、内联\nfunction totalAmount() &#123;  let result = 0;  for (let perf of invoice.performances) &#123;    result += amountFor(perf);  &#125;  return result;&#125;function totalVolumeCredits() &#123;  let result = 0;  for (let perf of invoice.performances) &#123;    result += volumeCreditsFor(perf);  &#125;  return result;&#125;\n\n初步成果 – 大量嵌套函数到目前为止，我的重构主要是为原函数添加足够的结构，以便我能更好地理解它，看清它的逻辑结构。这也是重构早期的一般步骤。把复杂的代码块分解为更小的单元，与好的命名一样都很重要。\nfunction statement (invoice, plays) &#123;  let result = `Statement for $&#123;invoice.customer&#125;\\n`;  for (let perf of invoice.performances) &#123;    result += ` $&#123;playFor(perf).name&#125;: $&#123;usd(amountFor(perf))&#125; ($&#123;perf.audience&#125; seats)\\n`;  &#125;  result += `Amount owed is $&#123;usd(totalAmount())&#125;\\n`;  result += `You earned $&#123;totalVolumeCredits()&#125; credits\\n`;  return result;  function totalAmount() &#123;    let result = 0;    for (let perf of invoice.performances) &#123;      result += amountFor(perf);    &#125;    return result;  &#125;  function totalVolumeCredits() &#123;    let result = 0;    for (let perf of invoice.performances) &#123;      result += volumeCreditsFor(perf);    &#125;    return result;  &#125;  function usd(aNumber) &#123;    return new Intl.NumberFormat(&quot;en-US&quot;,                        &#123; style: &quot;currency&quot;, currency: &quot;USD&quot;,                          minimumFractionDigits: 2 &#125;).format(aNumber/100);  &#125;  function volumeCreditsFor(aPerformance) &#123;    let result = 0;    result += Math.max(aPerformance.audience - 30, 0);    if (&quot;comedy&quot; === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5);    return result;  &#125;  function playFor(aPerformance) &#123;    return plays[aPerformance.playID];  &#125;  function amountFor(aPerformance) &#123;    let result = 0;    switch (playFor(aPerformance).type) &#123;    case &quot;tragedy&quot;:      result = 40000;      if (aPerformance.audience &gt; 30) &#123;        result += 1000 * (aPerformance.audience - 30);      &#125;      break;    case &quot;comedy&quot;:      result = 30000;      if (aPerformance.audience &gt; 20) &#123;        result += 10000 + 500 * (aPerformance.audience - 20);      &#125;      result += 300 * aPerformance.audience;      break;    default:      throw new Error(`unknown type: $&#123;playFor(aPerformance).type&#125;`);    &#125;    return result;  &#125;&#125;\n\n重构 – 拆分阶段（154）如何让这些函数能够复用，最常见的方法就是拆分阶段（154）\n这里我的目标是将逻辑分成两部分：一部分计算详单所需的数据，另一部分将数据渲染成文本或 HTML。第一阶段会创建一个中转数据结构，再把它传递给第二阶段。\n生成数据createStatementData，可单独放在另一个js文件\n将数据进行渲染renderPlainText、renderHtml，和statement放在同一个文件\n重构 – 以多态取代条件表达式（272）我的设想是先建立一个继承体系，它有“喜剧”（comedy）和“悲剧”（tragedy）两个子类，子类各自包含独立的计算逻辑。\n调用者通过调用一个多态的 amount 函数，让语言帮你分发到不同的子类的计算过程中。volumeCredits 函数的处理也是如法炮制。\n为此我需要用到多种重构方法，其中最核心的一招是以多态取代条件表达式（272），将多个同样的类型码分支用多态取代。\n但在施展以多态取代条件表达式（272）之前，我得先创建一个基本的继承结构。我需要先创建一个类，并将价格计算函数和观众量积分计算函数放进去。\n我已将全部计算逻辑搬移到一个类中，是时候将它多态化了。第一步是应用以子类取代类型码（362）引入子类，弃用类型代码。为此，我需要为演出计算器创建子类，并在 createStatementData 中获取对应的子类。要得到正确的子类，我需要将构造函数调用替换为一个普通的函数调用，因为 JavaScript 的构造函数里无法返回子类。于是我使用以工厂函数取代构造函数（334）。\n最终成果\n  export default function createStatementData(invoice, plays) &#123;  const result = &#123;&#125;;  result.customer = invoice.customer;  result.performances = invoice.performances.map(enrichPerformance);  result.totalAmount = totalAmount(result);  result.totalVolumeCredits = totalVolumeCredits(result);  return result;  function enrichPerformance(aPerformance) &#123;    const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance));    const result = Object.assign(&#123;&#125;, aPerformance);    result.play = calculator.play;    result.amount = calculator.amount;    result.volumeCredits = calculator.volumeCredits;    return result;  &#125;  function playFor(aPerformance) &#123;    return plays[aPerformance.playID]  &#125;  function totalAmount(data) &#123;    return data.performances      .reduce((total, p) =&gt; total + p.amount, 0);  &#125;  function totalVolumeCredits(data) &#123;    return data.performances      .reduce((total, p) =&gt; total + p.volumeCredits, 0);  &#125;&#125;function createPerformanceCalculator(aPerformance, aPlay) &#123;    switch(aPlay.type) &#123;    case &quot;tragedy&quot;: return new TragedyCalculator(aPerformance, aPlay);    case &quot;comedy&quot; : return new ComedyCalculator(aPerformance, aPlay);    default:        throw new Error(`unknown type: $&#123;aPlay.type&#125;`);    &#125;&#125;class PerformanceCalculator &#123;  constructor(aPerformance, aPlay) &#123;    this.performance = aPerformance;    this.play = aPlay;  &#125;  get amount() &#123;    throw new Error(&#x27;subclass responsibility&#x27;);  &#125;  get volumeCredits() &#123;    return Math.max(this.performance.audience - 30, 0);  &#125;&#125;class TragedyCalculator extends PerformanceCalculator &#123;  get amount() &#123;    let result = 40000;    if (this.performance.audience &gt; 30) &#123;      result += 1000 * (this.performance.audience - 30);    &#125;    return result;  &#125;&#125;class ComedyCalculator extends PerformanceCalculator &#123;  get amount() &#123;    let result = 30000;    if (this.performance.audience &gt; 20) &#123;      result += 10000 + 500 * (this.performance.audience - 20);    &#125;    result += 300 * this.performance.audience;    return result;  &#125;  get volumeCredits() &#123;    return super.volumeCredits + Math.floor(this.performance.audience / 5);  &#125;&#125;\n\n代码量仍然有所增加，因为我再次整理了代码结构。新结构带来的好处是，不同戏剧种类的计算各自集中到了一处地方。如果大多数修改都涉及特定类型的计算，像这样按类型进行分离就很有意义。当添加新剧种时，只需要添加一个子类，并在创建函数中返回它。\n这个示例还揭示了一些关于此类继承方案何时适用的洞见。上面我将条件分支的查找从两个不同的函数（amountFor 和 volumeCreditsFor）搬移到一个集中的构造函数 createPerformanceCalculator 中。有越多的函数依赖于同一套类型进行多态，这种继承方案就越有益处\n","categories":["学习记录"],"tags":["重构"]},{"title":"【学习记录】韩顺平Linux教程","url":"/2023/04/30/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E3%80%8A%E9%9F%A9%E9%A1%BA%E5%B9%B3Linux%E6%95%99%E7%A8%8B%E3%80%8B/","content":"Linux也称GNU&#x2F;Linux，是从一项伟大的（开源）运动中诞生的，可溯源到Unix操作系统（自行wiki）\n如今Linux广泛应用于服务器，因为它稳定、高效、免费！同时，它也经常出现在嵌入式领域（比如机顶盒、手机、智能家居等应用）\n获取Linux在Windows的虚拟机软件中安装\n VM的安装(记得破解)\n Centos7（截至20年开发环境主流）Centos是Red Hat的一个分支，所以在VM新建环节的版本选项中，要选择带有Red Hat Linux字样的   操作系统的ios文件路径，可以在新建完虚拟环境后，再在设置中指定（也叫挂载），再之后即可启动虚拟环境，完成安装工作安装界面的“软件选择”选项，一般在平时学习用，则选定“GNOME 桌面”模式，勾选两个带“兼容”字样的选项和“开发工具”（具备gcc和jdk等）在完成某个设置后，可能会需要等待，这个时候不要乱点，否则容易卡死关于“手动分区”的设置：\tboot分区（1G，其实也用不了这么多）\tswap分区（2G，一般是内存的两倍，因为速度比内存慢）\t根分区（17G，即剩余所有）\t再次确认：设备类型都选择“标准分区”、文件系统除了swap分区都选择“ext4”，swap分区则选择“swap”KDUMP是一个崩溃补救的设置，生产环境中建议勾上。但其也会占一部分空间，所以学习环境中可以不用“网络和主机名”设置：可以先打开、设置好名字（不能有_等特殊字符），至于配置可以之后再设置安全策略的选项也可以不设置，跳过“用户设置”：在实际生产环境中，密码建议非常复杂，而且要不定时更新管理 ，\n Centos8（未来趋势）\n Ubuntu\n\n网络连接在同一个网段的机器是可以相互通信的（没有特殊限制的话），比如网段192.168.0.xxx\n\n 桥接模式  虚拟系统可以和外部系统相互通信，但是容易造成IP冲突，因为此时虚拟系统的网络和主机的网络地位相等，并且和主机处于同一网段\n NAT模式  虚拟系统可以和外部系统通信，而且不会造成IP冲突。因为此时虚拟系统的网络是建立在与主机**不同**的网段上此时虚拟系统若想和外部通信，先通过与其同网段的一个“路由器”进行转发，再通过主机所处网段的IP代理得以和外部通信\n 主机模式  此时虚拟系统是**独立的系统**独立的系统，仅仅让虚拟机和本地物理主机通信，不与外界通信\n\n","categories":["学习记录"],"tags":["Linux"]},{"title":"【学习记录】关系型数据库","url":"/2023/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"Relational Database Management System - RDBMS的特点：\n1.数据以表格的形式出现2.每行为各种记录名称3.每列为记录名称所对应的数据域4.许多的行和列组成一张表单5.若干的表单组成database\nRDBMS 术语\n\n\n术语\n解释\n\n\n\n数据库\n一些关联表的集合\n\n\n数据表\n表是数据的矩阵，数据库中的一个表看起来像一个简单的电子表格\n\n\n列\n一列包含了相同类型的数据，具有相同数据类型的数据的集合\n\n\n行\n一行（也称元组或记录）是一组相关的数据，用来描述某条记录的具体信息\n\n\n冗余\n存储一倍以上数据，冗余会降低性能，但提高了数据的安全性\n\n\n主键\n主键是唯一的，一个数据表中只能包含一个主键，可以通过主键来查询数据\n\n\n外键\n外键用于关联两个表\n\n\n复合键\n复合键（也称组合键）将多个列作为一个索引键，一般用于复合索引\n\n\n索引\n索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息，类似于书籍的目录\n\n\n参照完整性\n参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性\n\n\n表头\n每一列的名称\n\n\n值\n行的具体信息, 每个值必须与该列的数据类型相同\n\n\n键\n键的值在当前列中具有唯一性\n\n\n","categories":["学习记录"],"tags":["关系型数据库"]},{"title":"【学习记录】版本管理系统","url":"/2023/12/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"什么是版本控制系统版本控制系统（Version Control System - VCS）最基本的功能是版本控制，在文件的修改历程中保留修改历史，让使用者可以更方便地选择对每个版本进行合理的处理。此外，VCS需要使用者做到主动提交文本的修改记录，让VCS保存此次修改的各种信息，方便后续不时之需。还有，VCS自诞生就考虑多人共同开发时同步的需求，即要求使用者建立一个中央仓库，并要求要将所有人的改动上传到中央仓库，以此向所有人同步。由此可见，一个版本控制系统的三个核心分别为版本控制、主动提交和中央仓库。\n版本控制系统大致分为两个流派，中央式和分布式，两者分别适用于不同的开发场景，各有优点。\n中央式版本控制系统中央式版本控制系统（Centralized VCS - CVCS），顾名思义，需要创建一个中央仓库，每个开发者都将新代码提交到中央仓库，其余人再将这些代码及时同步到自己的机器上。典型的应用有svn。\n分布式版本控制系统分布式版本控制系统（Distributed VCS - DVCS），它在CVCS的设计基础上，提出了本地仓库的概念，每个开发成员都可以在自己的机器上有一份本地仓库，这个仓库也包含了所有的版本历史。这就可以让每个人可以在自己的机器上实现提交代码、查看历史且无需频繁联网中央仓库，只需要在完成一系列的操作后的某个节点，把最新的版本从本地仓库推送到中央仓库即可。其余人则可以把这些提交从中央仓库同步到自己的机器上，并把它们和自己本地代码合并。典型的应用有git\n","categories":["学习记录"],"tags":["版本管理"]},{"title":"【工程实践】报告插件编写","url":"/2023/04/11/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91airtest%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8A%A5%E5%91%8A%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/","content":"基于airtest中的报告模块，开发自定义报告插件，接入工作流中\n\n写入指定格式的日志到txt文本\n可选部分是指，不同tag的日志，其data所包含的信息会有差异。比如函数的日志就会有返回结果ret和参数call_args，而普通文本打印就不会有这个\n\n\n\n\n其次，该基本格式下可能会有个更深的层次嵌套，这个取决于写入的变量类型。比如返回结果ret可能只是一个数字，但也可能是一个复杂的dict数据\n\n&#123;&quot;tag&quot;: , &quot;depth&quot;: , &quot;time&quot;: , &quot;data&quot;:&#123;        &quot;name&quot;: ,         &quot;call_args&quot;: , --可选        &quot;start_time&quot;: ,         &quot;ret&quot;: ,         &quot;end_time&quot;: ,        &quot;traceback&quot;: null, --可选        &quot;log&quot;:  --可选       &#125;&#125;\n\n将统一格式的日志内容、测试用例的本身信息等资源，分别解析和转换，再整合成固定结构的信息体\n除了报告模板和报告生成位置，这个信息体是传给jinja2渲染的唯一变量。一个报告也仅对应一个该格式的数据体\n\n\n\n\n其中steps是步骤1中所有的log的整合列表，因此该列表内的数据格式也是统一的\n\n&#123;&quot;steps&quot;:[          &#123;          &quot;title&quot;: ,          &quot;time&quot;: ,          &quot;code&quot;:&#123;                  &quot;name&quot;: ,                  &quot;args&quot;:[                          &#123;                           &quot;key&quot;: ,                           &quot;value&quot;:                           &#125;,                         ]                 &#125;,          &quot;screen&quot;: ,          &quot;desc&quot;: ,          &quot;traceback&quot;: ,          &quot;log&quot;: ,          &quot;assert&quot;:                           &#125;,         ], &quot;name&quot;: ,        --log文件路径 &quot;scale&quot;: , &quot;test_result&quot;: (Boolean), &quot;run_end&quot;: , &quot;run_start&quot;: , &quot;static_root&quot;: , &quot;lang&quot;: , &quot;records&quot;:[],    --录屏mp4文件路径列表 &quot;info&quot;:&#123;        &quot;name&quot;: , --测试用例（脚本）名称        &quot;path&quot;: , --测试用例（脚本）完整路径        &quot;author&quot; ,--用例作者名称        &quot;title&quot; ,         &quot;desc&quot;:        &#125;, &quot;log&quot;: ,        --log文件下载链接 &quot;console&quot; ,     --console.txt文本内容&#125;\n\n如何分析并整合日志数据和其他信息，是airtest报告的主要内容（也是编写插件的基础所在）\n\n\nairtest根据jinja2模板接受的字典数据data，根据jinja2相关语法和js进行渲染\nairtest使用js对data进行处理后，动态生成相关的页面元素\nairtest仅支持进行自定义html替换，和block footer的模板继承。两者的层级位置是固定的，拓展和修改的范围十分有限\n\n","categories":["工程实践"],"tags":["airtest","插件编写","python","json"]},{"title":"wampserver搭建网站","url":"/2022/11/08/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91wampserver%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/","content":"下载安装需要翻墙才能下载软件，否则只能浏览网页而已（下载那一步会一直失败）全部next就行了（最好选个好记的目录就行）\n配置第一个网站1 新建一个文件夹这个文件夹就是用来存放你的网站的资源、代码等等一切可以通过你的网址访问到的东西\n记住路径！（下文以&quot;d:/Websites/Blog&quot;为例）\n\n2 修改3个文件：\nhttpd.conf  文件在wampserver安装路径/bin/apache/apache-xx.xx/conf搜索DocumentRoot，修改这两个路径为存放网站的根路径，示例如下：    DocumentRoot &quot;d:/Websites/Blog&quot;    Directory &quot;d:/Websites/Blog/&quot;    (注意看，后者要多个斜杠)    搜索Listen，仿照你所看到的这两行，紧接其后写下：    Listen 0.0.0.0:8080    Listen [::0]:8080\nhttpd-vhosts.conf  文件在wampserver安装路径/bin/apache/apache-xx.xx/conf/extra把已有的&lt;VirtualHost *:80&gt;...&lt;/VirtualHost&gt;这些内容，复制一份接着粘贴到其下面，但需要做三处修改。同样的是都要修改两处，示例如下：    DocumentRoot &quot;d:/Websites/Blog&quot;    Directory &quot;d:/Websites/Blog/&quot;    (注意看，后者要多个斜杠)不同的是，还要修改host，示例如下：    VirtualHost *:8080    （不要与上面的80端口重复，且不要被当前计算的应用占用的端口即可，亲测还有8081、8082都可以）\nhosts  文件在C:/Windows/System32/drivers/etc文件末尾加上两行，示例如下：    127.0.0.1 localhost    ::1 localhost    （至于为什么要加这两行，我现在还不能说得太明白，继续学习吧。有的话就不用重复了）\n\n3 新建一个php文件在&quot;d:/Websites/Blog&quot;下新建你的第一个php文件（比如叫“test.php”），写下如下代码：    &lt;?php    echo &quot;success!&quot;    ?&gt;\n\n4 success!保存以上所有的文件，重启一遍wampserver所有服务，在浏览器中输入localhost:8080/test.php，看到以下内容说明成功了！恭喜你有了第一个网站！\nsuccess!\n\n其他这只是一种方法，还有更简单的。在之后的学习中再慢慢掌握吧\n多站点还记得建立第一个站点时修改的httpd-vhostsconf吗？没错！继续把8080端口那块内容多复制几份，让网址。。。我还没试过，在看这篇文章，之后再总结。（遇到问题，重启一下wampserver所有服务）\n注意事项php需要连接数据库时的host就是，本地创建连接时需要填的 主机 的名称，一般我们是填localhost或者是项目名称\n就像这次我在工作的时候填连接名是warmserver，但这不是dbname（即，不是数据库名），数据库名是unit-platform。 那么PHP在连接数据库时，需要填的dbname就应该是unit- platform\n（这是一次22年10月末的经历）\n","tags":["wampserver"]},{"title":"【工程实践】Unity转微信小游戏插件","url":"/2023/04/25/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Unity%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%8F%92%E4%BB%B6/","content":"如有开发者想把基于Unity开发的游戏工程想直接转为微信小游戏快速上线，非常推荐使用minigame-unity-webgl-transform这个插件。本文主要总结分析如何将该插件集成到平时的测试和发版流程。\n这是官方文档的原话：\n/// 脚本调用的话可修改 Assets/WX-WASM-SDK/Editor/MiniGameConfig.asset配置，然后调用WXEditorWindow 的 DoExport方法导出小游戏\n我们就分析MiniGameConfig.asset配置文件和类WXEditorWindow.DoExport，来尝试将其集成。\nMiniGameConfig.asset这是官方为了将unity工程转为webgl资源和小游戏工程所设计的一个配置文件，几乎包含了所有转换过程中会用到的配置：\n\nProject Conf\nSDK Options\nCompile Options\nCompress Texture\nPlayer Prefs Keys就我目前使用情况来看，每次发版只需要修改其中的2~3个值，其余的保持默认就已经能满足集成了\n\n插件本身也有一个在菜单栏的工具UI入口，可以让人用鼠标点点点就可以发版了，但本文暂不讨论该方式，因为其本质也是调用了DoExport函数\nWXEditorWindow.DoExport该方法只接受一个bool参数，true代表“导出WEBGL并转换为小游戏”，false代表“将WEBGL转换为小游戏”，前者更为常用。\n编写c#脚本调用DoExport由于asset格式的文件只能在unity中修改，所以无法调用其他语言来读取和解析MiniGameConfig.asset配置文件。这是官方代码中Assets/WX-WASM-SDK/Editor/UnityUtil.cs的解析配置部分：\npublic static WXEditorScriptObject GetEditorConf()&#123;    var path = &quot;Assets/WX-WASM-SDK/Editor/MiniGameConfig.asset&quot;;    var config = AssetDatabase.LoadAssetAtPath(path, typeof(WXEditorScriptObject)) as WXEditorScriptObject;    if (config == null)    &#123;        AssetDatabase.CreateAsset(EditorWindow.CreateInstance&lt;WXEditorScriptObject&gt;(), path);        config = AssetDatabase.LoadAssetAtPath(path, typeof(WXEditorScriptObject)) as WXEditorScriptObject;    &#125;    return config;&#125;\n对应着官方代码中Assets/WX-WASM-SDK/Editor/WXEditorWindow关于配置读取和保存部分：\npublic class WXEditorWindow : EditorWindow&#123;    public static WXEditorScriptObject config;    //...//    public void LoadData()    &#123;        SDKFilePath = Path.Combine(Application.dataPath, &quot;WX-WASM-SDK&quot;, &quot;wechat-default&quot;, &quot;unity-sdk&quot;, &quot;index.js&quot;);        config = UnityUtil.GetEditorConf();        projectName = config.ProjectConf.projectName;        appid = config.ProjectConf.Appid;        cdn = config.ProjectConf.CDN;        assetLoadType = config.ProjectConf.assetLoadType;        videoUrl = config.ProjectConf.VideoUrl;        orientation = (int) config.ProjectConf.Orientation;        dst = config.ProjectConf.DST;        // streamCDN = config.ProjectConf.StreamCDN;        bundleHashLength = config.ProjectConf.bundleHashLength;        bundlePathIdentifier = config.ProjectConf.bundlePathIdentifier;        bundleExcludeExtensions = config.ProjectConf.bundleExcludeExtensions;        preloadFiles = config.ProjectConf.preloadFiles;        developBuild = config.CompileOptions.DevelopBuild;        autoProfile = config.CompileOptions.AutoProfile;        scriptOnly = config.CompileOptions.ScriptOnly;        profilingFuncs = config.CompileOptions.profilingFuncs;        profilingMemory = config.CompileOptions.ProfilingMemory;        deleteStreamingAssets = config.CompileOptions.DeleteStreamingAssets;        cleanBuild = config.CompileOptions.CleanBuild;        customNodePath = config.CompileOptions.CustomNodePath;        webgl2 = config.CompileOptions.Webgl2;        useAudioApi = config.SDKOptions.UseAudioApi;        // audioPrefix = config.ProjectConf.AssetsUrl;        useFriendRelation = config.SDKOptions.UseFriendRelation;        bgImageSrc = config.ProjectConf.bgImageSrc;        tex = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(bgImageSrc);        memorySize = config.ProjectConf.MemorySize;        hideAfterCallMain = config.ProjectConf.HideAfterCallMain;        // 不常用配置，先只通过MiniGameConfig.assets修改        dataFileSubPrefix = config.ProjectConf.dataFileSubPrefix;        maxStorage = config.ProjectConf.maxStorage;        defaultReleaseSize = config.ProjectConf.defaultReleaseSize;        texturesHashLength = config.ProjectConf.texturesHashLength;        texturesPath = config.ProjectConf.texturesPath;        needCacheTextures = config.ProjectConf.needCacheTextures;        loadingBarWidth = config.ProjectConf.loadingBarWidth;        needCheckUpdate = config.ProjectConf.needCheckUpdate;    &#125;        private void OnLostFocus()    &#123;        config.ProjectConf.projectName = projectName;        config.ProjectConf.Appid = appid;        config.ProjectConf.CDN = cdn;        config.ProjectConf.assetLoadType = assetLoadType;        config.ProjectConf.VideoUrl = videoUrl;        config.ProjectConf.Orientation = (WXScreenOritation) orientation;        config.ProjectConf.DST = dst;        // config.ProjectConf.StreamCDN = streamCDN;        config.ProjectConf.bundleHashLength = bundleHashLength;        config.ProjectConf.bundlePathIdentifier = bundlePathIdentifier;        config.ProjectConf.bundleExcludeExtensions = bundleExcludeExtensions;        config.ProjectConf.preloadFiles = preloadFiles;        config.CompileOptions.DevelopBuild = developBuild;        config.CompileOptions.AutoProfile = autoProfile;        config.CompileOptions.ScriptOnly = scriptOnly;        config.CompileOptions.profilingFuncs = profilingFuncs;        config.CompileOptions.ProfilingMemory = profilingMemory;        config.CompileOptions.DeleteStreamingAssets = deleteStreamingAssets;        config.CompileOptions.CleanBuild = cleanBuild;        config.CompileOptions.CustomNodePath = customNodePath;        config.CompileOptions.Webgl2 = webgl2;        config.SDKOptions.UseAudioApi = useAudioApi;        // config.ProjectConf.AssetsUrl = audioPrefix;        config.SDKOptions.UseFriendRelation = useFriendRelation;        config.ProjectConf.bgImageSrc = bgImageSrc;        config.ProjectConf.MemorySize = memorySize;        config.ProjectConf.HideAfterCallMain = hideAfterCallMain;        config.ProjectConf.dataFileSubPrefix = dataFileSubPrefix;        config.ProjectConf.maxStorage = maxStorage;        config.ProjectConf.defaultReleaseSize = defaultReleaseSize;        config.ProjectConf.texturesHashLength = texturesHashLength;        config.ProjectConf.texturesPath = texturesPath;        config.ProjectConf.needCacheTextures = needCacheTextures;        config.ProjectConf.loadingBarWidth = loadingBarWidth;        config.ProjectConf.needCheckUpdate = needCheckUpdate;    &#125;&#125;\n\n\n\n","categories":["工程实践"],"tags":["Unity","插件"]},{"title":"【工程实践】基于hexo搭建博客","url":"/2023/06/05/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"本着想把使用hexo搭建博客网站的过程做个记录，删删改改一大段发现，其实和官网的教程别无二致，索性贴上官网的链接，以备之后查询。\nHexo官方文档\nEasy Hexo 👨‍💻是一个对小白友好的入门hexo教程，很赞！\nKeep 主题使用指南 | Hexo 主题 Keep 官方文档 (xpoet.cn)这是使用基于hexo的自定义主题的教程，同样很赞！\n上传图片 | PicX (xpoet.cn)这是一款基于 GitHub API 开发的图床工具，提供图片上传托管、生成图片链接和常用图片工具箱服务，强烈推荐使用在博客网站图片资源配置中。\n腾讯云 产业智变·云启未来 - 腾讯 (tencent.com)，即使是静态网站，在接入评论板块时也不得不用到云服务来储存评论和文本过滤（在大陆地区使用还得是腾讯云这些国产服务靠谱）。\n以上工作做完，得到一个网站项目（可以建立本地网络服务器进行预览和调试）。接着可以使用项目托管将网站上线，我用的是Github Pages，布置好之后就可以通过本地git推送完成博客在线更新。\n","categories":["工程实践"],"tags":["hexo","博客搭建"]},{"title":"学成在线首页制作练习","url":"/2023/06/14/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0@%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/","content":"这是黑马2023前端Web开发前94集的阶段练习，内容为学成在线网站的首页：展示地址 &#x2F; 源代码地址\n布局思路先整体再局部，从外到内，从上到下，从左到右\nCSS实现思路1. 画盒子，调整盒子范围 → 宽高背景色\n2. 调整盒子位置 → flex布局、内外边距\n3. 控制图片、文字内容样式\n\nlogo功能\n单击跳转到首页\n\n搜索引擎优化，提升网站百度搜索排名，实现方法：\n\n标签结构：h1&gt;a&gt;网站名字（搜索关键字）\nCSS样式\n\n/* logo */.header .wrapper .logo a&#123;    display: block;    width: 195px;    height: 41px;    background-image: url(../images/logo.png);    /* 隐藏文字 */    font-size: 0;&#125;\n\n导航功能\n单击跳转页面\n\n实现方法：\n\n标签结构：ul&gt;li*3&gt;a\n优势：避免堆砌a标签，网站搜索排名降级\n\n\n布局思路：\n\nli设置margin-right\na设置padding-left padding-right\n\n\n\n搜索区域实现方法：\n\n标签结构：div&gt;input+a\n\n用户区域实现方法：\n\n标签结构：div&gt;a&gt;img+span\n\nbanner区域布局：banner&gt;通栏&gt;版心&gt;left+right\n左侧侧导航实现方法：\n\n标签结构：left&gt;ul&gt;li*9&gt;a\n\n布局思路：\n\na默认状态：背景图为白色右箭头\n\n右侧课程表实现方法：\n\n标签结构：.right&gt;h3+.content&gt;ul&gt;li*3&gt;a\n\n精品推荐实现方法：\n\n标签结构：recommend&gt;h3+ul+a.modify\n\n布局思路：flex布局\n精品课程考虑到多个区域是类似的结构，顾将部分CSS作为公用属性\n布局思路：flex布局\n版权区域布局思路：flex布局\n","tags":["前端界面练习"]},{"title":"小兔鲜首页制作练习","url":"/2023/06/16/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0@%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/","content":"这是黑马2023前端Web开发前131集的阶段练习，内容为小兔鲜网站的首页：展示地址 &#x2F; 源代码地址\n本次练习的特点有：素材划分更细、使用字体图标、SEO优化等\n项目目录\nimages：存放固定使用的图片素材\nuploads：存放非固定使用的图片素材\niconfont：字体图标素材\ncss\nbase.css：基础公共样式\ncommon.css：各个网页相同模块的重复样式\nindex.css：首页样式\n\n\nindex.html：首页HTML文件\n\nSEO三大标签SEO定义：搜索引擎优化，提升网站百度搜索排名\n提升SEO的常见方法：\n\n竞价排名\n将网页制作成html后缀\n标签语义化（在合适的地方使用合适的标签）\n……\n\n网页头部SEO标签：\n\ntitle\ndescription\nkeywords\n\nFavicon图标定义：网页图标，出现在浏览器标题栏，增加网站辨识度\n图标：favicon.ico，一般存放在网站的根目录里面\n版心wrapper宽度：1240px\n快捷导航结构：通栏&gt;版心&gt;导航ul\n布局：flex-end\n头部导航结构：.header&gt;logo+nav+search+cart\n底部区域结构：通栏&gt;版心&gt;服务+帮助+版权\n由于是底部区域，不用考虑SEO优化（即不用li标签包裹a标签）\nbanner结构：通栏&gt;版心&gt;轮播图+侧导航+原点指示器\n新鲜好物区域结构：标题+内容\n由于格式重复，使用公共样式\n热门品牌区域标题结构：左侧+右侧箭头\n生鲜区域标题结构：右侧&gt;菜单+查看全部\n","tags":["前端界面练习"]},{"title":"【源码】打包发布本地python模块","url":"/2022/11/17/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E6%9C%AC%E5%9C%B0python%E6%A8%A1%E5%9D%97/","content":"python打包发布说明我们在开发中，有时会遇到需要将在本地开发的python工程代码中的一些模块分享给同事或者其它社区开发者的情况，为了让他们可以通过pip的方式（从本地文件或者云端）将包导入到他们python环境中，我们则需要将我们的模块“打包”。这不同于简单的压缩文件并让他们解压到合适的目录，然而提供了一种更加规范和统一的方式去分享你的模块。下面，大致介绍一下如何使用如今（2023）最流行的python打包工具setuptools\n推荐文档\nSetuptools 【腾讯云】\nsetuptools document\nsetuptools PyPI\npackaging python\npython打包分发工具：setuptools【知乎】\n\n打包示例1. 模块的目录结构假设我当前有个模块为airtest_plugin，仅有一个report.py，该模块被放在usr/myPackages/airtest_plugins/目录下\n|-myPackages  |--airtest_plugins    |--airtest_plugin      |--__init__.py      |--README.md      |--report.py\n\n2. 编写setup.py文件在模块的同级目录建立一个setup.py文件\n|-myPackages  |--airtest_plugins    |--airtest_plugin      |--__init__.py      |--README.md      |--report.py    |--setup.py\nsetup.py内容\nimport setuptoolssetuptools.setup(    name=&#x27;airtest_plugin&#x27;,\t# 这时pip list显示的模块名称    version=&#x27;0.1&#x27;,    author=&#x27;your name&#x27;,    author_email=&#x27;your email&#x27;,    description=&#x27;plugin for airtest&#x27;,    packages=[&#x27;airtest_plugin&#x27;] # 需要一起编译的子包，用.代表层级关系)\n\n假设该模块下的report.py中有一个函数hello()：\ndef hello():    print(&#x27;Hello world!&#x27;)\n\n3. 使用setup.py中的配置打包\n编译python setup.py build\n\n生成发布压缩包python setup.py sdist\n执行完，模块同级目录下会出现一个dist文件夹，其中有一个.tar.gz格式的压缩包\n\n生成网络发布包python setup.py bdist_wheel\n执行完，dist文件夹下会出现一个.whl格式的文件（接下来我们用这个文件来安装包）\n如有必要，带上参数`--force-reinstall`表示强制安装：pip install ./dist/airtest_plugin-0.1-py3-none-any.whl \n\n4. 本地测试使用打开另一个工程，新建一个python文件，解释器环境要和上文导入包的环境一致\nfrom airtest_plugin import reporthello()------------------------------------------------output:Hello world!\n\n\n\n5. 上传到pypi里面如果想将自己的包发布到万维网，我推荐PyPI（在此之前，需要到它的官网注册一个账号）\n\n使用库twine，将刚才dist文件夹下的内容通过网络发布出去：twine upload dist/*\n按提示输入你注册的账号信息，等待片刻，登录pypi查看吧\n\n","categories":["源码"],"tags":["python"]},{"title":"【源码】airtest整体框架总结","url":"/2022/11/08/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6airtest%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/","content":"简略介绍airtest是由网易airtest团队制作的一个跨平台的UI测试框架，也是他们开源的自动化测试框架之一（还有Poco框架、airtest- selenium框架、airtestIDE编辑器、deviceFarm集群方案和airlab云测平台）。\nairtest框架是跨平台（移动端App和Windows端）的、基于opencv图像识别的、用python开发的UI自动化测试框架，不过由于识别概率的机制和项目开发过程中UI界面频繁迭代，脚本迭代成本较高。\n框架梳理airtest是可以用pip install方法下载到本地进行开发的，包下面分为5个大类，分别是：aircv、cli、core、report和utils\naircv简介aircv作为airtest的图像识别模块，封装了多种图像识别算法，可分为模板匹配和基于特征点的图像识别两类，各有优缺点，旨在根据不同场合使用不同算法。\n\n模板匹配：\n\n无法跨分辨率识别 \n一定有相对较佳的结果（即使目标不存在） \n方法名：tpl\n\n\n基于特征点的图像识别：\n\n能跨分辨率识别 \n不一定有匹配结果 （特征点过少时）\n方法名：kaze、brisk、akaze、orb、sift、surf、brief\n\n\naircv图像识别模块下包含11个脚本：\n\naircv.py：\n\n包含基于opencv封装的基本的图片处理函数\n\n\ncal_confidence.py：\n\n封装了两个计算2张图片相似度的通用函数\n\n\nerror.py：\n\n基于Exception，封装了自定义错误类\n\n\nkeypoint_base.py：重要\n\n基于KAZE算法思想\n封装了基类KeypointMatching\n\n\nkeypoint_matching.py：\n\n继承KeypointMatching\n继续封装了4个类KAZE&#x2F;AKAZE&#x2F;BRISK&#x2F;ORB\n基于opencv，无需opencv-contrib module\n\n\nkeypoint_matching_contrib.py：\n\n继承KeypointMatching\n封装了3个类BRIEF&#x2F;SIFT&#x2F;SURF\n需要opencv-contrib\n\n\nmultiscale_template_matching.py：重要\n\n基于多尺度模板匹配思想\n封装了基类MultiScaleTemplateMatching\n继承MultiScaleTemplateMatching，封装了类MultiScaleTemplateMatchingPre（基于截图预设条件）\n\n\nsift.py：重要\n\n基于sift算法思想\n封装了一系列基于特征点的图像识别算法\n\n\ntemplate.py：\n\n以函数形式封装模板匹配算法的一般流程\n\n\ntemplate_matching.py：\n\n以类的形式封装模板匹配算法的一般流程\n\n\nutils.py：\n\n封装了图像预处理和工具类的公共函数\n包含打印运行时间的修饰器函数、检查图像识别的输入的函数、图片数据互转sting&#x2F;cv2格式&#x2F;np的函数以及压缩图片质量保存的函数\n\n\n\n\n\n脚本功能介绍aircv图像识别模块包含11个脚本，功能分别如下：\naircv.py包含基于opencv封装的基本的图片处理函数，比如根据图片路径，将图片读取为cv2的图片处理格式imread()、类似的还有旋转图片、裁剪等等cal_confidence.py封装了两个计算2张图片相似度的函数（给其他地方调用的）error.pyairtest的图像识别错误类库（基于Exception），比如FileNotExistErrorkeypoint_base.py封装了基于特征点的识别基类KeypointMatching，日志中的方法名叫KAZEkeypoint_matching.py继承KeypointMatching，继续封装了4个类KAZE/AKAZE/BRISK/ORB（基于opencv），无需opencv-contrib modulekeypoint_matching_contrib.py同样继承KeypointMatching，封装了3个类BRIEF/SIFT/SURF（基于opencv-contrib），需要注意的是opencv surf算法因为专利问题，需要（设置cmake 参数nonfree为true）重新编译opencv&amp;opencv-contrib的源代码才可以引用multiscale_template_matching.py封装了多尺度模板匹配MultiScaleTemplateMatching和基于截图预设条件的多尺度模板匹配sift.py封装了sift图像识别算法template.py封装了模板匹配算法template_matching.py同样封装了模板匹配，不过是以类的形式封装utils.py图像识别的公共函数，包含打印运行时间的修饰器函数、检查图像识别的输入的函数、图片数据互转sting/cv2格式/np的函数以及压缩图片质量保存的函数\n\n\n\n如下部分将详细解析aircv图像识别模块下的算法的详细结构，以及对其进行合理评估和改进\n模板匹配在template.py和template_matching.py中，airtest对模板匹配的流程进行了代码实现，两者的流程基本一致，只不过后者在前者基础上，封装成了TemplateMatching类\n无法跨分辨率识别一定有相对较佳的结果（即使不存在）方法名：tpl\n脚本结构|-template.py|--def find_template(im_source, im_search, threshold, rgb)|--def find_all_template(im_source, im_search, threshold, rgb, max_count)|--def _get_confidence_from_matrix(im_source, im_search, max_loc, max_val, w, h, rgb)|--def _get_template_result_matrix(im_source, im_search)|--def _get_target_rectangle(left_top_pos, w, h)|-template_matching.py|--class TemplateMatching(属性: im_source, im_search, threshold, rgb )|----def find_all_results(self)|----def find_best_result(self)|----def _get_confidence_from_matrix(self, max_loc, max_val, w, h)|----def _get_template_result_matrix(self)|----def _get_target_rectangle(self, left_top_pos, w, h)\n\ntemplate.py&quot;&quot;&quot; 功能：在源图像上以模板匹配方式，求得目标图像结果    参数：      源图像：屏幕代理（默认minicap）的截图的格式      目标图像：cv2的图片处理格式      置信度阈值：float 筛选阈值，默认为0.8，即置信度超过0.8的结果会被认为是目标结果      彩色模式：bool 可以进行彩色权识别    主流程-1（find_template）：      检验图像输入      计算模板匹配的结果矩阵      依次获取匹配结果      求取可信度      求取识别位置          主流程-2（find_all_template）：      和主流程-1类似，只不过将第4、第5步重复执行，获取多个匹配结果      貌似源代码中将屏蔽已经去除的最优结果这步给注释掉了      同样的，循环主体把匹配结果矩阵放在了外面，又不做最优结果的屏蔽，那么每次的最优结果append进临时存储列表，最终列表中会出现全部相同的值了&quot;&quot;&quot;    \n主流程\n1.检验图像输入\n\n参数：\n源图像\n目标图像\n\n\n流程：\n对比两者的宽、高\n目标图像的宽、高，均不得超过源图像\n\n\n\n\n2.计算模板匹配的结果矩阵\n\n参数：\n源图像\n目标图像\n\n\n流程：\n断言源、目标图像为np.ndarray格式\n将源、目标图像的颜色空间由BGR转为GRAY\n使用cv2.matchTemplate进行模板匹配\n返回模板匹配的结果矩阵\n\n\n\n\n3.依次获取匹配结果\n\n参数：\n上一步的结果矩阵\n\n\n流程：\n使用cv2.minMaxLoc获取 最值以及最值的索引\n\n\n\n\n4.求取可信度\n\n参数：\n源图像\n目标图像\n结果矩阵的最大值\n结果矩阵的最大值的索引\n目标图像的宽\n目标图像的高\n彩色模式\n\n\n流程：\n若开启彩色模式：\n以最大值的索引为左上角，在源图像上裁取和目标图像同大小的矩阵\n使用np.clip cv2.cvtColor cv2.copyMakeBorder cv2.split对图像进行预处理，得到三张不同通道的图片\n分别使用cv2.matchTemplate进行模板匹配，比较三个结果矩阵中的最大值，返回最小值\n\n\n若不开启：\n返回结果矩阵的最大值（没错，直接返回了传进来的参数&#x2F;笑哭）\n\n\n\n\n\n\n5.求取识别位置  \n\n参数：\n结果矩阵的最大值的索引\n目标图像的宽\n目标图像的高\n\n\n流程：\n以最大值的索引为左上角\n以目标图像的宽、高为识别结果的矩形框的宽、高\n返回识别结果的矩形框的四个角点和中心点\n\n\n\n\n\n关键函数# cv2.matchTemplate 只能处理灰度图MatchTemplate(InputArray image, InputArray templ, OutputArray result, int method);        image：输入一个待匹配的图像，支持8U或者32F，大小(H, W)，用I表示        templ：输入一个模板图像，与image相同类型，大小(h, w)，用T表示        result：输出保存结果的矩阵，32F类型，大小是(H-h+1, W-w+1)        method：要使用的数据比较方法，有六种                np.clip cv2.cvtColor cv2.copyMakeBorder cv2.split\n\ncv2.matchTemplate常用的数据比较方法：\n\n方法匹配方法：TM_SQDIFF\n归一化方差匹配方法：TM_SQDIFF_NORMED,\n相关性匹配方法：TM_CCORR,\n归一化的互相关匹配方法：TM_CCORR_NOMED,\n相关系数匹配方法：TM_CCOEFF,\n归一化的相关系数匹配方法：TM_CCOEFF_NORMED$$R&#x3D;\\frac{\\sum_{x^{‘},y^{‘}}T^{‘}(x^{‘},y^{‘})·I^{‘}(x+x^{‘},y+y^{‘})}{\\sqrt{\\sum_{x^{‘},y^{‘}}T^{‘}(x^{‘},y^{‘})^2·\\sum_{x^{‘},y^{‘}}I^{‘}(x+x^{‘},y+y^{‘})^2}}$$\n\n\nnp.clip\n\ncv2.cvtColor \n\ncv2.copyMakeBorder \n\ncv2.split\n\n\ntemplate_matching.py其实就是把template.py的方法，用类封装管理起来了find_best_result()写的代码文档中，什么“基于kaze进行图像识别xxxx”，扯淡。一个模板匹配怎么和基于特征点混在一起，再说也没看到代码有相关内容\n多尺度模板匹配cv2的matchTemplate模板匹配应用范围很局限，多尺度的模板匹配可以考虑到图像旋转变形等多种情况，在脚本multiscale_template_matching.py中对此进行了实现\n脚本结构|-class MultiScaleTemplateMatching（属性：im_source, im_search, threshold, rgb, record_pos, resolution, scale_max, scale_step）|--def find_all_results|--def find_best_result|--def _get_confidence_from_matrix(self, max_loc, w, h)|--def _get_target_rectangle(self, left_top_pos, w, h)|--def _resize_by_ratio(src, templ, ratio, templ_min, src_max)|--def _org_size(max_loc, w, h, tr, sr)|--def multi_scale_search(self, org_src, org_templ, templ_min, src_max, ratio_min, ratio_max, step, threshold, time_out)|-class MultiScaleTemplateMatching**Pre**（继承 MultiScaleTemplateMatching）|--重写 def find_best_result|--新增 def _get_ratio_scope(self, src, templ, resolution)|--新增 def get_predict_point(self, record_pos, screen_resolution)|--新增 def _get_area_scope(self, src, templ, record_pos, resolution)\n\n&quot;&quot;&quot; 功能：在源图像上以多尺度模板匹配方式，求得最适合的目标图像结果    参数：      源图像：屏幕代理（默认minicap）的截图的格式      目标图像：cv2的图片处理格式      置信度阈值：float 筛选阈值，默认为0.8，即置信度超过0.8的结果会被认为是目标结果      彩色模式：bool 可以进行彩色权识别      record_pos：记录点      resolution：分辨率 基于分辨率的多尺度      scale_max：源图像的预设最大尺寸      scale_step：步长    主流程-1（MultiScaleTemplateMatching.find_best_result）：      检验图像输入      计算模板匹配的结果矩阵      求取识别位置          主流程-2（MultiScaleTemplateMatching**Pre**.find_best_result）：      检查截图分辨率（没有则立即返回None）（整体和主流程-1类似，不过基于分辨率做了更多处理）      检验图像输入      计算模板匹配的结果矩阵      求取识别位置&quot;&quot;&quot;    \nclass MultiScaleTemplateMatching主流程\n1.检验图像输入：\n\n参数：\n源图像\n目标图像\n\n\n流程：\n对比两者的宽、高\n目标图像的宽、高，均不得超过源图像\n\n\n\n\n2.计算模板匹配的结果矩阵：\n\n参数：\n源图像\n目标图像\n最小比例\n最大比例\n目标图像最小尺寸  \n源图像预设最大尺寸\n步长\n识别阈值\n最大等待时间\n\n\n流程：\n将源图像、目标图像处理成灰度图\n进行多尺度搜索（参数：源图像的灰度图，目标图像的灰度图，最小比例，最大比例，目标图像预设最小尺寸，源图像预设最大尺寸，步长，识别阈值，等待时间上限）  主流程：  新建临时存储变量（最大值、最大值对应的信息、初始化比例=最小比例、开始时间）    循环（当前比例 &lt; 最大比例）：    1.按比例缩放源、目标图像：        根据源图像预设最大尺寸求`源图像的缩放比例` = min(预设最大尺寸/源图像尺寸的长边, 1.0) ，使用**cv2.resize**缩放源图像        获取缩放后的源图像、目标图像的高、宽        比较对应边的比例 （目标图像的高/源图像的高 &gt; 目标图像的宽/源图像的宽 ？）        根据 传入参数`比例`和上一步的比较结果，求取目标图像的缩放比例 = （源图像的高或宽*比例）/目标图像的高或宽，使用**cv2.resize**缩放目标图像        返回（缩放后的源图像、缩放后的目标图像、源图像的缩放比例、目标图像的缩放比例）    2.如果缩放后的目标图像的短边 &gt; 目标图像预设最小尺寸：        使用cv2.TM_CCOEFF_NORMED标准和cv2.resize在源图像进行模板匹配        更新临时存储变量：最大值 = 匹配结果矩阵中的最大值、 最大值对应的信息 = （当前比例， 结果矩阵最大值， 结果矩阵最大值的索引， 当前目标图像的宽和高，当前源图像的缩放比例，当前目标图像的缩放比例）        如果 （达到时间上限） 并且 （当前结果矩阵最大值 &gt; 识别阈值）：          根据源图像缩放的比例，获取结果矩阵最大值对应原来的索引，以及源图像原来的宽、高           根据TM_CCOEFF_NORMED标准，求取置信度          如果（置信度 &gt; 识别阈值），返回（置信度，最大值的索引，源图像的原始宽和高，当前比例）    3.比例 = 比例 + 步长    如果 （临时存储变量的信息仍为空）：    返回 空空空（代表无结果）  重复循环主题步骤2.最后条件分支里的所有内容\n\n\n\n\n3.求取识别位置\n\n参数：\n结果矩阵的最大值的索引\n源图像的宽\n源图像的高\n置信度\n\n\n流程：\n获取目标区域（矩形框）\n拼接返回匹配结果的格式（矩形框中心坐标，矩形框（4个角点），置信度）\n比较置信度和识别阈值，决定返回None或结果\n\n\n\n\n\n关键函数cv2.resizeTM_CCOEFF_NORMED标准计算置信度\n\nclass MultiScaleTemplateMatchingPre与基类区别在于，针对源图像的分辨率做了特殊处理\n主流程\n1.检验图像输入\n\n参数：\n源图像\n目标图像\n分辨率\n\n\n流程：\n获取源图像、目标图像的宽高\n对应比较两者的宽、高，目标图像的宽、高均不能超过源图像\n比较分辨率、目标图像的宽、高\n对应比较两者的宽、高，分辨率的宽、高均不能小于目标图像\n\n\n\n\n2.计算模板匹配的结果矩阵\n\n参数：\n源图像\n目标图像\n记录点\n分辨率\n\n\n流程： \n设置临时变量 偏差量\n预测搜索区域：流程：  获取源图像、目标图像、分辨率的宽、高  获取 预测的目标点：    依据 记录点 和 分辨率，获得预测的目标点（策略是个一元一次方程，系数为记录点，自变量为分辨率，因变量就是预测点）  以预测的目标点为圆心，获取 预测的范围：    策略是 范围半径 = （源图像宽、高 乘以 目标图像宽、高）/分辨率宽、高          范围半径 = 预设的偏差量          以两者最大的为准    依据范围半径，返回预测范围的左上角点、右下角点、预测范围的分辨率\n裁剪源图像的预测区域：流程：  获取源图像的高、宽  获取在源图像中实际的有效区域：没有负数、源图像有足够空间  返回剪切后的图像（函数代码文档里写了还要返回截取偏移，但没有）\n再次检查裁剪后的源图像的尺寸是否大于目标图像\n获取预测缩放比的范围流程：  获取源图像、目标图像、分辨率的高、宽  策略：    比例1： 取最值 = 裁剪的源图像的宽、高 / 预测范围的分辨率的宽、高    比例2： 取最大值 = 目标图像的宽、高 / 裁剪的源图像的宽、高    最终缩放范围 = 比例1 乘以 比例2    返回 最终范围 与 [步长, 0.99] 的交集\n将裁剪后的源图像、目标图转为灰度图\n多尺度匹配搜索（裁剪后的源图像的灰度图，目标图的灰度图，缩放范围，步长，阈值，等待时间&#x3D;1s），对返回的最大值的索引加上预测区域的左上角点坐标\n获取最终识别区域框\n拼接识别结果\n比较置信度和识别阈值，返回None或结果\n\n\n\n\n3.求取识别位置\n\n\n关键函数分辨率：宽x高图像：高，宽，[通道]\n\n\n基于特征点的图像识别在keypoint_base.py,keypoint_matching.py,keypoint_matching_contrib.py中，airtest基于KAZE的思想，用代码对其进行了基本实现，并封装成了一个KeypointMatching基类。在此基础上，以不同改进的迭代器，继承封装了多个方法类。\n能跨分辨率识别不一定有匹配结果方法名：kaze、brisk、akaze、orb、sift、surf、brief\n脚本结构|-keypoint_base.py（对KAZE算法用代码实现，封装为类 Keypointmatching）|--def find_best_result(self)|--def show_match_image(self)|--def _cal_confidence(self, resize_img)|--def init_detector(self)|--def get_keypoints_and_descriptors(self, image)|--def match_keypoints(self, des_sch, des_src)|--def _get_key_points(self)|--def _handle_two_good_points(self, kp_sch, kp_src, good)|--def _handle_three_good_points(self, kp_sch, kp_src, good)|--def _many_good_pts(self, kp_sch, kp_src, good)|--def _get_origin_result_with_two_points(self, pts_sch1, pts_sch2, pts_src1, pts_src2)|--def _find_homography(self, sch_pts, src_pts)|--def _target_error_check(self, w_h_range)|-keypoint_matching.py（继承`Keypointmatching`基类，封装了四个类）|--类 KAZEMatching：原封不动的继承Keypointmatching|--类 BRISKMatching：仅将detector改为了`cv2.BRISK_create`|--类 AKAZEMatching：仅将detector改为了`cv2.AKAZE_create`|--类 ORBMatching：仅将detector改为了`cv2.ORB_create`|-keypoint_matching_contrib.py（继承`Keypointmatching`基类，封装了三个类（用到了opencv的拓展包，所以要对opencv做版本检查））|--类 BRIEFMatching：仅新增了star_detector、brief_extractor|--类 SIFTmatching：仅修改了detector，新增了matcher|--类 SUFMatching：仅修改了detector，新增了matcher\n\nKeypointmatching类解析\n类属性\n\nim_source 源图像\nim_search 目标图像\nthreshold 识别阈值\nrgb 彩色识别模式\n\n\n主流程：\n\n检查图像是否正常\n参数：\n源图像\n目标图像\n\n\n流程：\n判断源图像、目标图像不为空、且.any()返回True，来确定图像有效性\n\n\n\n\n获取特征点集合\n参数：\n流程：\n\n\n匹配特征点对\n提取识别区域\n计算识别区域的可信度\n\n\n其他函数:\n\nshow_match_image：将主流程走了一遍之后，把特征点连线渲染出来，生成一张图片\n\n\n\ncli这个是命令行模块\n__main__.py 总入口info.py 获取脚本信息，比如基本名、作者等 parser.py 命令行参数解析（妹搞明白。加了许多自定义的命令行参数名和解析方式）runner.py 通过命令行运行测试，基于unitest.TestCase（还没用过，不是很清楚）\n\ncore这个是所谓的核心模块，包含了对各大平台（win&#x2F;android&#x2F;linux&#x2F;ios）的封装接口，以及一些通用的接口\ncore.android 安卓模块    cap_methods 屏幕截图模块        base_cap.py 封装了屏幕截图的基类        adbcap.py 基于adb的屏幕截图基类，也是所有屏幕方法的基类（均将画面流转为cv2的图像对象）        minicap.py 基于minicap截图类（minicap是开源项目STF中的一个工具，负责屏幕显示）        javacap.py 通过yosemite.apk，基于socket通讯的截图类。性能比minicap差，但兼容性好。        screen_proxy.py 屏幕截图代理，自动选择以上截图方法中的一个            static 静态资源文件夹        adb 各个系统下的adb文件（linux\\linux_arm\\mac\\windows）        apks Yosemite.apk等airteset包        stf_libs 各个CPU框架下的libs（长知识了）            touch_methods 触摸模块        base_touch.py 触摸操作的基类，基于down、up、sleep和move四个基类的各种方法        maxtouch.py 基于maxtouch的触摸操作（是airtest自己开发的，我目前不清楚这些概念）        minitouch.py 基于minitouch的触摸操作（当前设备支持openstf的minitouch时则使用minitouch，否则使用maxtouch）        touch_proxy.py 屏幕触摸代理            adb.py     adb类，基于adb命令封装出的各种方法（需要学习adb命令大全）        android.py     安卓设备类，封装了操作安卓的很多方法        constant.py    定义各种常量，比如默认adb的服务端口地址、各adb的路径、ip的正则匹配规则等等        ime.py    输入法类（没用过不了解）        recorder.py    录屏类        rotation.py    屏幕方向监控类        yosemite.py    Yosemite类，用于javacap/录屏/yosemite输入法    core.ios IOS模块    iproxy 各系统（windows和mac）下的iproxy工具文件夹，iproxy能实现设备与电脑的端口映射        constant.py    定义各种常量        elements_type.py    只包含了一个元素类型列表（不清楚如何使用）        instruct_cmd.py    用于连接iphone        ios.py    IOS类，封装了很多操作IOS设备的方法        minicap.py    ios-minicap截图类MinicapIOS        relay.py    iphone的端口转发（高级东西，现在我还不了解）        rotation.py    屏幕方向监控类    core.linux:    linux.py     linux类，封装了部份操作方法（好少啊，是没写完吗？还是linux如此高效？）core.win:    ctypesinput.py    封装了windows鼠标、键盘输入（长见识了）        screen.py    windows截图        win.py    Windows类，封装了各种操作方法    api.pyairtest的核心api（通用的），比如初始化设备、连接设备、返回设备实例、常用的手势函数（点、滑等）、对app的常用操作函数（安装、卸载等）、对设备的常用操作函数（唤醒、返回主页面等）、还有命令行cv.pyAirtest封装的图像识别机制，包含Template类用于方便地调用函数、还有其他循环识别机制、日志保存和截图等等device.py封装了测试设备基类（看不懂，大受震撼）error.pyairtest通用的错误类库，比如AirtestErrorhelper.py工具文件，包含全局变量G（封装为了类）、报告的log()、引用路径增加using()等实现settings.py包含了一些全局设置，封装成Settings类。有是否debug、日志路径、日志文件名.格式、默认的识别算法、阈值（决定是否输出识别成功）、识别间隔延迟时间等等\n\nreport这个是报告模块\ncss 资源文件夹fonts 资源文件夹 image 资源文件夹js 资源文件夹log_template.html报告html模板report.py报告实现（也是最近需要为工作准备的内容之一，前端3剑客）\n\n\n\nairtest_report源码阅读airtest任务生成的一份报告，它的目录结构大致如下：\n|-&lt;sript_name_without_ext&gt;.log    |-log        |-&lt;timestamp&gt;.jpg        |-log.txt    |-static        |-css        |-fonts        |-image        |-js    |-&lt;sript_name_without_ext&gt;.py    |-log.html    |-&lt;tpl+timestamp&gt;.png    具体的例子：```txt|-测试购买.log    |-log                         这一部分就是完整的airtest的log日志        |-1674877913337.jpg        |-1674877913337_small.jpg   这是脚本运行时所截的图        |-log.txt    |-static                      这是html报告用到的完整的静态资源        |-css        |-fonts        |-image        |-js    |-测试购买.py                 这是测试脚本文件    |-log.html                    这是最终导出的html格式的报告    |-tpl1674121024.png           这是脚本内所识别的目标图\n\nreport.py脚本组成分析airtest.report.report作为主要的解析日志并生成报告的模块，以下尝试解读它：\n全局变量&#x2F;常量\n_paragraph_re\nap\nargs\nDEFAULT_LOG_DIR\nDEFAULT_LOG_FILE\nSTATIC_DIR\nHTML_FILE\nHTML_TPL\nLOGGING\n\n全局函数\nget_parger\n\n接收唯一参数，类型为argparse.ArgumentParser()\n使用python内置模块argparse，可给当前python文件添加一系列命令行可选参数，返回修改后的参数本身  report [script] [--outfile] [--static_root] [--log_root] [--recort] [--export] [--lang] [--plugins] [--report]\n  由此可见，report支持命令行直接调用，但不建议这样做。\n\n\nmain\n\n接收唯一参数，类型为argparse.ArgumentParser().parse_args()。\n解析传入的命令行参数的具体的值，传入LogToHtml类，进行初始化\n调用LogToHtml类中的report方法，生成html报告\n\n\nnl2br\n\nsimple_report（重点）\n\n接受四个参数：\nfilepath\nlogpath\nlogfile\noutput\n\n\n对参数进行检验，必要时重新赋值，传入LogToHtml类，进行初始化\n调用LogToHtml类中的report方法，生成html报告\n\n\ntimefmt\n\n\n全局类LogToHtml\n__init__\nlog\nscript_root\nscript_name\nlog_root\nstatic_root\ntest_result\nrun_start\nrun_end\nexport_dir\nlogfile\nlang\n\n\ninit_plugin_modules plugins的加载是以__import__()方式导入的，目前仅支持两个插件poco.utils.airtest.report 和 airtest_selenium.report    \n_load\n读取log_path日志文件，将每行的日志文本以json的格式存入log\n\n\n_analyse\n准备steps , children_steps两个空列表\n读取log，补充这两个空列表（log文件的组成详见airtest_log源码解读）\nlog[&#39;depth&#39;]                             -&gt; depth\nlog[&#39;data&#39;][&#39;start_time&#39;] or log[&#39;time&#39;] -&gt; run_start\nlog[&#39;time&#39;]                              -&gt; run_end\ndepth==0                                 -&gt; steps.append(log)\ndepth==1                                 -&gt; step[&#39;__children__&#39;] = children_steps , steps.append(deepcopy(log)) , children_steps = []\ndepth==其它                              -&gt; children_steps.insert(0, log)\n\n\n读取steps，迭代并传入方法_translated_step()，将结果存入translated_steps列表\n校验translated_steps最后一个元素的调用栈属性traceback并修改测试状态属性test_result后返回该列表\n\n\n_translate_step\n初始化7个变量：\nname       &lt;- step[&#39;data&#39;][&#39;name&#39;]\ntitle      &lt;- _translate_title(name, step)\ncode       &lt;- _translate_code(step)\ndesc       &lt;- _translate_desc(step, code)\nscreen     &lt;- _translate_screen(step, code)\ninfo       &lt;- _translate_info(step)\nassertion  &lt;- _translate_assertion(step)\n\n\n将变量所得的值存入translated字典并返回\n\n\n_translate_title\n维护一个title字典，将name属性转换为合适的title属性再返回，比如touch 对应 Touch\n\n\n_translate_code\n若step[&#39;tag&#39;] != &#39;function&#39;，立即返回None\n初始化最终的返回值code = &#123;&quot;name&quot;:step[&#39;data&#39;][&#39;name&#39;], &quot;args&quot;:[]&#125;\n将step[&#39;data&#39;][&#39;call_args&#39;]的键值对全加进args\nfor _, arg in enumerate(args)（arg须符合arg[&#39;value&#39;] 为 dict，且arg[&#39;value&#39;].get[&#39;__class__&#39;] == &#39;Template&#39;）:\n若export_dir不为空，则把arg[&#39;value&#39;][&#39;filename&#39;]对应的图片复制到script_root下，并设置&#96;arg[‘image’]为该图片的路径\n尝试获取filename对应的图片的分辨率并赋值给’arg[resolution’]&#96;\n\n\n返回code\n\n\n_translate_desc\n维护两个字典desc , desc_zh，将name属性转换为合适的描述文本再返回，比如exists 对应 &#39;断言目标图片不存在&#39;\n当step[&#39;tag&#39;] != &#39;function&#39;时，立即返回None\n\n\n_translate_screen\n若step[&#39;tag&#39;] not in [&#39;function&#39;, &#39;info&#39;]或者step.get(&#39;__children__&#39;)，立即返回None\n初始化最终的返回值screen = &#123; &#39;src&#39;:None, &#39;rect&#39;:[], &#39;pos&#39;:[], &#39;vector&#39;:[], &#39;confidence&#39;:None &#125;\n中途视情况(try_log_screen , _cv_match , touch , assert_exists , wait , exists , swipe)增加多个属性resolution, _filepath, thumbnail，并完善screen\n返回screen\n\n\n_translate_info\n尝试获取step中的traceback , log信息并返回\n\n\n_translate_assertion\n尝试获取step[&#39;data&#39;][&#39;call_args&#39;][&#39;msg&#39;]信息并返回\n\n\nget_thumbnail\nget_small_name\nis_pos\ndiv_rect\n_render\n接受三个参数：模板位置 输出位置 数据\n用jinja2渲染html详见如何使用jinja2渲染html，并将渲染后的内容存入变量html并返回详见airtest-html报告模板源码解读\n传入的数据正是report_data所返回的data,将**data作为参数传给_render()\n\n\ncopy_tree\n_make_export_dir\n设置报告文件夹的名字为.log\n在导出路径export_dir下新建这个报告文件夹\n无视错误，shutil.rmtree删除报告文件夹下的所有文件\n复制script_root下的目录树到报告文件夹\n复制log_root下的目录树到报告文件夹\n复制static_root下的css/fonts/image/js四个目录到报告文件夹，如果不是http开头的话\n返回报告文件夹路径、报告文件夹下的日志路径\n\n\nget_relative_log\nget_console\nreadFile\nreport_data\n接受两个参数output_file , record_list\n调用方法_load()，将log_path的日志内容存储到log列表中\n调用方法_analyse()，将log解析为可渲染的dict，存入变量steps\n调用get_script_info(script_path)获取脚本内容存入变量info详见airtest-cli模块源码解读\n当录像列表不为空，视情况将录像分配给指定的导出路径或默认日志目录，并将拼接好的路径存入变量records\n处理static_root的分隔符使之合法，比如\\\\ --&gt; /、如有必要则末尾添加/\n设置output_file为默认或者指定的传入参数\n新建一个字典变量data，它包含13个键，赋值了对应的值后，return data\n&#39;steps&#39; : steps\n&#39;name&#39; : self.script_root\n&#39;scale&#39; : self.scale\n&#39;test_result&#39;:self.test_result\n&#39;run_end&#39; : self.run_end\n&#39;run_start&#39; : self.run_start\n&#39;static_root&#39; : self.static_root\n&#39;lang&#39; : self.lang\n&#39;records&#39; : records\n&#39;info&#39; : info\n&#39;log&#39; : self.get_relative_log(output_file)\n&#39;console&#39; : self.get_console(output_file)\n&#39;data&#39; : json.dumps(data).replace(&quot;&lt;&quot;, &quot;&#123;&quot;),replace(&quot;&gt;&quot;, &quot;&#125;&quot;)\n注意到data的log console data这三个键有所不同，说明如下：\n\nlog，日志的相对路径\nconsole，尝试读取与导出报告同目录下的console.txt文件里的内容并返回\ndata，将以上包含12个键的字典中的&quot;&lt;&gt;&quot;对应替换为&quot;&#123;&#125;&quot;，避免被认为是特殊用法\n\n\n\n\n\n\n\nreport\n接受四个参数\nself 类实例引用\ntemplate_name \noutput_file\nrecord_list\n\n\n涉及5个类变量属性：\nscript_root\nscript_name\nlog_root\nstatic_root\nexport_dir\n\n\n涉及3个类方法属性：\n_render\n_make_export_dir\nreport_data  代码内容：\n\n\n\n\n生成报告页面，可以加入自定义数据并且重写\n根据sript_root拆分成路径和sript_name\n如果export_dir不为空：\n调用方法_make_export_dir()准备导出的路径文件夹和相关资源\n设置output_file路径\nstatic_root不是http开头的话，设置为\"static/\"\n\n\n如果record_list不为空，将log_root下的mp4文件的路径全部保存到列表\n调用方法report_data()，将返回的值存入data\n调用方法_render()，将html模板template_name、output_file和**data作为参数传入，返回方法返回的值\n\n\n\n简要总结\nairtest将日志的每一行视为一个step，但与报告中的一个步骤却又有所不同，后者由单个或者一组step组成\n每一个step，都有depth属性，它代表调用先后的关系，较大值从属于较小值。\ndepth为0的单独视为报告中的一个步骤\n连续的depth作为一组，视为报告中的一个步骤（比如depth=3,depth=2,depth=1的为一组，并以depth=1的step作为代表）\n\n\nstep的数据结构和报告中的一个步骤所需要的数据结构显然不会一样：\n通过_translate_step()方法来进行转换\n转换后的数据结构可直接被jinja2模板所使用\n\n\n\nbug其中airtest.report.report.py line526getattr(ST,\"LOG_DIR\",DEFAULT_LOG_DIR)，仅仅判断ST有没有LOG_DIR属性，而没有管它的值是否为None，从而导致不能直接调用这个接口否则会出现，拼接路径的报错，提示某参数不能为None\nairtest 的报告模板airtest调用了原生jinja2模板来渲染html，下面仅讨论被jinja2模板控制的区域部分\n\n由于liquid语法限制，block相关的语法块都会被jekkly识别到所以所有的{ 和 %中间都用-分隔\n\nhead部分脚本&#123;&#123;`static_root`&#125;&#125;\ntitle&#123;&#123;`info.title`&#125;&#125;\n数据&#123;&#123;`data|safe`&#125;&#125;\n语言&#123;&#123;`lang`&#125;&#125;\nbody部分container-fluidrow主要内容 main标题：&#123;&#123;info.title&#125;&#125;副标题：&#123;-% if not steps %-&#125;log不存在的提示语&#123;-% endif %-&#125;summary:主要是报告抬头的一些基本信息、比如运行时间、日志链接、脚本作者等等涉及&#123;&#123; info.desc &#125;&#125; &#123;&#123; if console &#125;&#125; &#123;&#123; if log &#125;&#125; &#123;&#123; info.author &#125;&#125;  &#123;&#123; info.name &#125;&#125; 自定义模块：&#123;&#123; extra_block|safe &#125;&#125;\nsteps:&#123;-% if steps|length &gt;0 %-&#125;表头（分左右两部分）：顺序 耗时 状态    |     跳至错误步骤 筛选（全部 成功 失败 断言）内容steps-content（左边）：没有jinja2控制的模板内容\n\nstep-list：\npageTool：内容steps-content（右边）：没有jinja2控制的模板内容&#123;-% endif %-&#125;\n\nfooter`&#123;-% block footer %-&#125;`\n放一些有关网易airtest的跳转链接和图标\n录屏 row gif-wrap showmenu三个按钮：放大、缩小和关闭\ncol-md-6&#123;-% if records %-&#125;  &#123;-% for r in records %-&#125;    放一个按钮：在新窗口打开    放视频本身  &#123;-% endfor %-&#125;&#123;-% endif %-&#125;\nmask hide没有jinja2控制的模板内容\n脚本&#123;&#123;static_root&#125;&#125;\n由此可看出，由模板渲染的内容仍然有限。类似点击跳转、切换列表视图等功能都写在js文件中    \nutils这个是工具模块\napkparser apk解析https://github.com/androguard/androguard    apk.py     封装了apk相关的方法（长知识，大受震撼）        axmlparser.py     封装了AXMLParser类，解析apk中的AndroidManifest.xml        axmlprinter.py    封装了AXMLPrinter类，解析编译之后的AndroidManifest文件格式工具        bytecode.py        stringblock.py        typeconstants.py    compat.pypython2/python3兼容逻辑，路径和名称之类的logger.py初始化日志，基于logginglogwraper.py封装AirtestLogger类，airtest日志和装饰类nbsp.py非阻塞流读取（听不懂，大受震撼）resolution.py用于存放一些计算函数，比如图像适配、搜索区域预测retry.py重试装饰器函数（函数导致致命错误，会在一定时间内重新运行该函数）safesocket.py封装了SafeSocket类，实现socket安全收/发通信（不懂，这也是最近要去学的--网络通信编程）selenium_proxy.py基于Selenium Chrome类的二次封装（不会用）snippet.py零散函数存放地threadsafe.py封装了ThreadSafeIter类，使迭代器/生成器线程安全（看不懂，如何让线程变安全的？）transform.pyTemplate（airtest自己独有的一个重要概念/类）类中target_pos的实现（点击图片点9个点位中的某个--airtest的一个机制）version.py获取/显示airtest版本\n\n\n\n\n\nlogairtest除了标准的运行日志，还有一套专门用来记录测试数据并生成报告的日志格式，主要的接口有如下几个：\nairtest.core.helper类仅有一个类，名为G其中有一个用AirtestLogger实例化的成员对象，以及一些记录日志相关信息的常量成员，它们是用来记录日志的关键\n函数有7个函数\nset_logdir设置日志文件路径\nlog接收的参数为:arg,timestamp,desc,snapshot。后三者顾名思义，arg则会被讨论是异常还是普通字符串，从而决定是否被标记为不通过。\nlogwrap基于类中的AirtestLogger实例，调用了Logwrap\ndevice_platform设置类中当前设备属性\nusing将指定的路径加入sys.path，从而达到脚本间的互相引用\nimport_device_clsdelay_after_operationlog()接口参考https://www.cnblogs.com/AirtestProject/p/16983441.htmlhttps://www.cnblogs.com/AirtestProject/p/16964460.htmlhttps://www.cnblogs.com/AirtestProject/p/16223928.html\nairtest.utils.logger函数仅含两个函数，如下：\n\ninit_logging()基于库logging，设置日志的样式和等级\nget_logger(name)供外部调用，获取日志对象实例\n\nairtest.utils.logwraper常量LOGGING，从airtest.utils.logger.get_logger(__name__)获取的日志对象实例\n类只有一个类AirtestLogger，继承自object。该对象生成的实例，也被叫做“logger”\n变量属性\nself.running_stack\n用于保存正在运行的测试函数的信息，以便在测试结束时将其记录到日志文件中\n\n\nself.logfile\n日志文件的路径（默认为None）\n\n\nself.logfd\n用于保存日志文件的文件句柄（默认关闭并置为None）\n\n\n\n方法\n__init__()\nrunning_stack = [], logfile = None, logfd = None\n调用方法set_logfile()\n调用函数reg_cleanup()清空给定函数寄存器，将方法handle_stacked_log作为参数\n\n\nlog()\n用于将日志信息记录到日志文件中\n记录深度depth、tag、timestamp以及data等日志信息转为json后写入文件\n\n\nset_logfile()\n用于设置日志文件的路径，并打开文件句柄\n\n\nhandle_stacked_log()\n用于处理 running_stack 中的测试函数信息，并将其记录到日志文件中\n\n\n_dumper()\n用于将对象转换为 JSON 格式的字符串\n\n\n\n函数只有一个函数Logwrap()，是装饰器函数，它用于装饰测试函数，以记录测试函数的执行情况。该函数包含以下属性和方法：\n\nwrapper()方法\n作为测试函数的包装器，用于记录测试函数的执行情况，并将执行情况记录到日志文件中：\n这些信息都放在data属性，由name,call_args,start_time,ret,end_time组成，分辨对应函数名、参数情况、开始和结束时间以及函数返回结果\n然后再把data同tag,depth,timestamp的内容作为参数，调用log()函数\n\n\n除此之外，该修饰器会额外判断是否含有名为snapshot的参数名，若有，则在函数执行完毕后调用截图函数try_log_screen()\n\n\n\n简要总结AirtestLogger.log()是最终实现写入文件的函数，可以在.air脚本中直接调用\n@Logwrap()则是负责收集所修饰的函数信息，再调用AirtestLogger.log()\nlog()才是专门暴露给用户的接口\n\n最终写入日志的基本格式为&#123;tag:, depth:, timestamp:, data:&#123;name:, call_args:, start_time:, ret:, end_time:,&#125;&#125;\n若传入的值本身就为字典，那么就可能有更多层的嵌套关系\n\n\n\n","categories":["源码"],"tags":["airtest","UI测试框架"]},{"title":"【心得】信息搜索能力","url":"/2024/02/04/%E3%80%90%E5%BF%83%E5%BE%97%E3%80%91%E4%BF%A1%E6%81%AF%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/","content":"一、搜索技术的重要性\n搜索技术是冲浪必备技能。 \n掌握搜索技术是互联网时代获取信息的关键,可以极大程度地缩小信息差距。\n\n二、搜索的目的\n了解信息(Know Something)   \n学习技能(Learn Something)\n创作内容(Create Something)\n完成任务(Do Something)\n\n三、搜索的内容\n信息资讯:新闻、事件等\n知识技能:概念、教程等\n素材文件:图片、视频、文档等\n工具软件:各类工具、插件等\n\n四、搜索的原则和规则\n要快速准确,谷歌效率最高。\n可运用搜索语法提升效率: \n限定关键词:用双引号””包裹\n限定标题:intitle\n限定内容:intext \n限定网址:inurl\n限定网站:site\n限定图片大小:imagesize\n限定文件类型:filetype\n\n\n信息源头最准确可信,要注意判断来源。\n\n五、搜索知识技能类\n主要平台:谷歌、得到APP、优质视频网站等\n注意知识质量,尽量采用一手资料。\n可下载研究报告、学术论文等高质量文档。\n视频教程可在视频网站、短视频平台获取。\n\n六、搜索素材文件类\n可利用免费素材网站、版权网站等。\n注意遵守版权,非商用基本没有风险。\n可用各种下载工具下载素材。\n需注意素材的质量、风格等符合要求。\n\n七、搜索工具软件类\n优先考虑在线工具。\n其次是软件,最后是插件。\n大多数需求都能找到对应的工具。\n可用类似网站找相似工具。\n\n八、运用AI工具\nChatGPT等AI工具可直接回答问题,无需搜索。\n可进行追问、对比、推理等,功能强大。\n结合传统搜索技术和AI工具,形成超级搜索技术。\nAI将深刻影响搜索方式,要积极运用。\n\n","categories":["心得"],"tags":["信息搜索"]},{"title":"【学习记录】掌握Chatgpt Prompt","url":"/2024/02/02/%E3%80%90%E5%BF%83%E5%BE%97%E3%80%91%E6%8E%8C%E6%8F%A1Chatgpt%20Prompt/","content":"想让Chatgpt等一类AI生成式工具有效地回答我的问题，我得学会提问（Prompt）。一是让AI告诉我们如何提问，一劳永逸；二是总结提问的规律法则，以不变应万变；三是积累一些好用的prompt公式，现拿现套。\n一劳永逸ChatGPT超级Prompt我想让你成为我的 Prompt 创作者。你的目标是帮助我创建最佳的 Prompt，这个 Prompt 将由你ChatGPT 使用。你将遵循以下过程：1.首先，你会问我 Prompt 是关于什么的。我会告诉你，但我们需要通过不断的重复来改它，通过则进行下一步。2.根据我的输入，你会创建三个部分:a)修订后的 Prompt(你编写修订后的 Prompt，应该清晰、精确、易于理解)b)建议(你提出建议，哪些细节应该包含在 Prompt 中，以使其更好)c)问题(你提出相关问题，询问我需要哪些额外信息来改进 Prompt)3.你提供的 Prompt 应该采用我发出请求的形式，由ChatGPT 执行。4.我们将继续这个选代过程，我会提供更多的信息，你会更新“修订后的Prompt”部分的请求，直到它完整为止。\n用一套Prompt寻找一套最优解决方案你需要应用连续问题解决系统(CPSS)来通过不断重复寻找我的问题，并通过深度解析后提供解决方案。CPSS的工作原理如下:1.你将采用六个步的问题解决过程来评估我的初始问题: )确定题 2定3)生成决案(最多3个)4)评估并选择解决方案5)实施解决方案6)下一个问题2.在“生成解决方案”的步骤中，应列出最多3个解决方案:在“评估和选择解决方案”的步骤中，应提供精确和具体的解决方案。在“实施解决方案”的步骤中，应提供所选解决方案付诸实施的具体方法。3.”下一个问题“部分应包含你可以向我提出的最重要的问题，以获取进一步的信息，这些信息对于问题解决过程的继续非常重要。每个问题的数量最多为3个。4.你的回答应该简洁明了，使用Markdown格式撰写，其中每个步骤的名称以粗体显示，并且所有文字包括标签的字体大小应具有一致性。5.在你回答了我的第一个问题之后，CPSS过程的下一个迭代开始。6.系统将整合我的最后一个回答，并通过每个选代逐渐提供更加深入的回答，你可以通过向我提出新的问题来引导它。你的第一个回答应该只是一个问候，提醒对方你是一个连续问题解决系统（CPSS)。不要在第一个回答中开始CPSS过程，你的第一个回答只包括问候和要求提出的要解决的问题。之后，我会为你提供信息，请在你的下一个回答中开始CPSS过程。\n通用万能公式\n写在前面，这套万能公式已经内置在了chatgpt的官网中，可以参考如下逻辑补充信息，然后完成个性化配置。\n\n告诉ChatGPT我是谁职业&#x2F;角色\n具体兴趣\n价值观&#x2F;原则\n学习风格\n个人背景\n目标\n偏好\n主要语言\n专业知识\n沟通风格\n等等等等…\nChatGPT回复问题要求回复格式\n语气\n详细程度\n建议类型\n问题类型\n资源参考核查\n批判性思维\n创意水平\n解决问题方法\n偏见意识\n语言偏好\n推理框架\n等等等等…\n规律法则\nChatGPT的底层原理是文字推断，根据“上一句”的内容，给出“下一句”。因此，我们给到的内容的越精准，就与能得到符合预期的回答。想要做到这点，有如下几个可供参考的思路和方法。\n指令词+背景+输入+输出要求指令词：精准任务（命令）\n背景：补充信息\n输入：输入数据（具体内容）\n输出要求：结果格式\n好用的公式&#x2F;插件\n写在前面，公式好用与否，很大一部分取决于个人使用体验，即主观感受。其次，公式中[]的内容才是重点。最后，不同的公式组合（即插件）才能应对更复杂的需求。\n\n多角度请用多个角度来思考[主题内容]。（从[角度1]、[角度2]、[角度3]…多个角度来思考）\n总结基于[主题内容]中的主要观点，请给出[格式]\n个性请以[参考对象或风格]的风格，为我撰写[话题]内容\n示例询问请按照以下格式，给出[主题内容]的信息。[示例格式]\n能力与角色你是具有[主题]专业知识的[角色]。请提供关于[主题]的[格式]\n分隔符[分隔符]括起来的内容，[需求提示]\n最后更新中…\n","categories":["学习记录"],"tags":["Chatgpt","Prompt"]},{"title":"【调研】Laya引擎","url":"/2023/05/02/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91Laya%E5%BC%95%E6%93%8E/","content":"\nLayabox的创始人谢成鸿在2003年将国内三大休闲娱乐平台之一的”可乐吧“以数千万价格卖给清华同方后，创立了3D端游研发公司”中娱在线“。Layabox公司成立时的引擎技术骨干均来自于追随谢成鸿多年的3D端游引擎核心成员，时间最长者达10多年。因此深厚的引擎经验积累为Layabox的引擎高速发展以及3D引擎发展方向奠定了基础（–摘自官网）\n\n Layabox自2011年开启HTML5游戏引擎研发以来，历经非开源HTML5引擎LAYA，第一代开源HTML5引擎LayaFlash、第二代开源HTML5引擎LayaAir，三个阶段。\nLayaAir引擎支持精灵、矢量图、文本、富文本、位图字体、动画、骨骼、音频与视频、滤镜、事件、加载、缓动、时间、网络、UI系统、物理系统、TiledMap、prtocol等API；支持开发2D、3D、VR的产品研发，支持Canvas与WebGL模式，支持同时发布为HTML5、Flash、APP（IOS、安卓）多种版本。\nLaya IDE 说基于layaAir引擎（的UI系统）开发的桌面端程序\n","categories":["调研"],"tags":["调研","Laya"]},{"title":"【调研】如何搭建网站","url":"/2022/11/21/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/","content":"接下来会调研一下想做个自己的网站，可能会用到的技术方案，比如服务器、前后端框架、编程语言等等\n我目前对网站设计的所有认知：\n\n网站是一系列网页，别人通过浏览器访问，在你的网页引导下浏览具体信息\n网站能展示的内容都是存储在服务器上的，需要一个web服务器来管理这些内容\nweb服务器可以分成web服务、器来讨论，前者是一个程序，后者是一个物理机（主要为web服务所用）。提供web服务的机器？\n这个提供web服务的机器，可以是自己个人电脑，也可以租赁别人提供的电脑，通过远程连接操控来编写内容，部署服务等等。\n网页内容的设计有三要素，html+css+javascript，分别是原生内容+页面布局+人机交互\n网站除了可以展示原生内容，也可以收集、展示、处理在人机交互中产生的衍生数据，这个就是服务端（后端）需要去处理的事情了\n常用的后端语言，属php最为广泛，java、python等也都有应用场景，视情况而定。其中JavaScript前后端嵌入式通吃！\n似乎很多的编程语言都能通吃前后端？不是。语言被设计出来的时候，就已经决定了它的应用场景，硬要整花活可能换来的就是没有市场等等debuff\n是的，我对于服务器和服务器的通信、服务器和客户端的通信、客户端和客户端的通信了解甚少（仅限于简易爬虫中的理解）\n\n调研内容web服务器\nnginx、apache、tomcat 这三个 可以归为一类，都是服务器.\nnginx 是轻量级 http服务器和反向代理服务器\napache也是http服务器\nnginx和apache 也都可以作为静态文件服务器来使用\ntomcat 可以认为是apache 的一个扩展，apache如果要运行java，就需要tomcat的支持，tomcat也可以独立运行。\n他们都属于应用服务器\n\nweb框架\nDjango 是 python 的 web 框架\nFlask 也是 python 的 web 框架\nRails 是 Ruby 的 web 框架，和Django性质是一样的\n大多数的Web框架提供了一套开发和部署网站的方式，在进行数据缓存、数据库访问、数据安全校验等方面，不需要自己再重新实现，而是将业务逻辑相关的代码写入框架就可以。等等\n当然不用web框架来开发网站也是有的，比如用php在apache上开发\nJava目前的主流开发框架是ssm(spring spring-mvc和mybatis)。相比之前的ssh(spring struts hibernate)，ssm也是比较轻量级的框架\n\nweb界面框架\nhtml+css+js直接原生设计界面，但开发成本、上手难度会高一些，需求的频繁变动会大大增加维护成本\nweb界面框架应运而生，比如vue.js，react，jQuery等等\n\nNode.js以下内容来自C语言中文网：\n\nJavascript 原先只能在浏览器上运行，诞生于1995年，而nodejs诞生于2009年。\nNode.js 不是一门新的编程语言，也不是一个 JavaScript 框架，它是一套 JavaScript 运行环境，用来支持 JavaScript 代码的执行。用编程术语来讲，Node.js 是一个 JavaScript 运行时（Runtime）\n所谓运行时，就是程序在运行期间需要依赖的一系列组件或者工具；把这些工具和组件打包在一起提供给程序员，程序员就能运行自己编写的代码了\nnodejs的开发团队为了避免其被误认为是 JavaScript 框架，现在也经常简称为 Node\nNode.js 运行时主要由 V8 引擎、标准库和本地模块组成，尤其是本地模块的多少，从底层决定了 Node.js 功能的强弱\n\nV8引擎\nV8 引擎就是 JavaScript 解释器，它负责解析和执行 JavaScript 代码\nV8 引擎借鉴了 Java 虚拟机和 C++ 编译器的众多技术，它将 JavaScript 代码直接编译成原生机器码，并且使用了缓存机制来提高性能，这使得 JavaScript 的运行速度可以媲美二进制程序\n\n本地模块\nNode.js 集成了众多高性能的开源库，它们使用 C&#x2F;C++ 语言实现\nNode.js 直接在计算机上运行 JavaScript 代码，并且要赋予 JavaScript 强大的能力，所以它的本地模块和浏览器中的运行时有很多大区别，甚至说几乎没有什么关联。Node.js 几乎完全抛弃了浏览器，自己从头构建了一套全新的 JavaScript 运行时\n\n标准库\n本地模块使用 C&#x2F;C++ 编写，而 Node.js 面向 JavaScript 开发人员，所以必须要封装本地模块的 C&#x2F;C++ 接口，提供一套优雅的 JavaScript 接口给开发人员，并且要保持接口在不同平台（操作系统）上的一致性\n这套 JavaScript 接口，就是 Node.js 标准库。标准库是否优雅和强大，决定了 Node.js 的易用性，直接影响 Node.js 的市场表现\n\n现成的网站生成方案使用文章转html的工具 + 托管静态资源的服务器，就能快速实现一个静态网站了，比如Jekyll/Hexo+Github Page\n什么是静态博客\n所谓静态博客，即通过生成工具（eg：Hexo、Hugo、Jekyll等），直接将作者所书写的博文编译成最终的 html；css；js 等静态文件。\n作者&#x2F;博主只需将生成的文件部署在静态 server 上面即可被在互联网中访问。\n用户通过浏览器访问服务器，直接就会获得已编译的静态资源\n\n静态博客的优缺点？优点\n速度极快，因为当用户访问博客时，只用从服务器（如nginx）调取编译好的静态资源即可，无需实时从数据库查询获取博文、图片、评论、访问量等资源，效率极高，打开网站的速度会非常快速 ！\n作者可以专心生产博文，不用管服务器维护等琐事，基本不需要维护，折腾党除外。\n成本低，市面上有很多开源免费的托管程序（如 gayhub；gitee；coding 等），不用担心高昂的服务器费用。\n很安全，无需担心数据库注入，跨站攻击等网站安全问题。（值得商榷）\n待补充\n\n\n缺点\n硬伤，无法支持原生评论，访问量统计，注册登录等功能。\n操作繁琐，虽然前面提到静态博客不用管服务器维护；不用担心高昂的服务器费用，但是没有后台管理的它，靠手动编译，如果在原基础上改动过多（美化；增删功能），将难以维护！！！\n上手难， 由于无后台管理功能，那么静态博客对新手菜鸟来说真的是难以使用，不懂 HTML、JS、CSS 根本不用谈使用了，因为你连发布文章都会非常吃力，所以想玩好静态博客，不经历点摸爬滚打，是不可能的。不要跟我说简单，因为你的简单只建立在原生无改动的情况下。\n生成速度（编译速度），不同的静态博客生成器的速度各不相同，一旦静态资源存在大量图片，速度就会有明显的变化，当然对于坚定静态博客的人，这点忽略不计。\n静态网站不会提供很复杂的功能\n\n参考：博文\n","categories":["调研"],"tags":["搭建网站"]},{"title":"【调研】测试框架","url":"/2022/11/10/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/","content":"1. 功能简介本测试平台旨在服务于每个项目组，支持Windows PC、Andorid和IOS的游戏测试，且提供接口自动化测试、UI自动化测试、性能自动化测试、压力自动化测试、兼容自动化测试、本地化测试、Mock、测试计划管理、持续测试以及其他有关测试资料汇总。本平台从如何提高测试效率，提高管理效率，提升产品质量的角度出发，分析我司测试工作方面的难点、痛点，结合市场现有的开源技术，合理整合各类资源，独立设计了一系列便捷且强大的功能，以平台的形式提供给我司各项目组使用，帮助我司测试人员在工作中更加游刃有余，从而达到提高产品整体开发效率、提升产品最终交付质量的效果。\n\n【测试计划管理】\n\n有序、整洁地制定和管理项目中所有的测试计划，记录每一个测试用例，记录每一次因需求改动的用例变更，让每一次测试都进行得高效、井井有条。\n\n【接口自动化测试】\n\n有序地、全面地、自动化地对游戏内外接口进行管理和测试，保障每一个接口的质量\n\n【UI自动化测试】\n\n基于图像识别和AI的自动化UI测试框架，测试人员根据测试用例录制游戏场景脚本，上传平台自动执行，可以大大降低繁琐、重复、无聊的测试工作量\n\n【性能自动化测试】\n\n对游戏客户端、服务端都能进行有效的性能测试，提供可视化的数据报告，帮助产品优化\n\n【压力自动化测试】\n\n对游戏客户端、服务端提供多样的压力测试工具，提供丰富的测试报告，帮助产品优化\n\n【兼容自动化测试】\n\n一机多控：一个设备上录制脚本，多台设备都可以执行\n提供云真机支持，让兼容测试变得异常方便\n\n【本地化自动化化测试】\n\n针对项目素材进行机器学习，高质量训练模型帮你快速发现本地化测试中的遗漏之处\n\n【持续测试】\n\n自动化对项目工程监听、打包、构建测试场景，持续对项目工程进行单元测试，以便尽快发现bug，全程几乎不需要人力参与\n\n【其它】\n\nwiki（知识分享）模块：平台会不定期汇总测试有关的学习资料，帮助测试人员提升专业技能；测试人员可以在这交流经验，互相帮助，一起成长。\n人员管理模块：支持用户注册、角色分配、权限修改等功能，方便人员的管理\n平台说明手册模块：提供详细完善的指南，帮助用户使用这个平台\nBUG管理模块：提供更方便顺手的工具帮助测试人员总结BUG，积累经验，定期分析复盘\n系统设置模块：个性化设置一些界面风格、语言、个人信息等等\n2. 竞品分析2.1 自动化测试框架2.1.1 流马开源\n2.1.2 luckyframe开源\n2.1.3 robotRobot框架基于Python，但也可以使用Jython（Java）或IronPython（.NET）。\nRobot框架使用关键字驱动的方法来简化测试的创建。\nRobot框架还可以测试MongoDB、FTP、Android、Appium等\n开源\n2.1.4 网络驱动（WebDriverIO）WebdriverIO是一个基于Node.js的自动化测试框架。\n由于WebDriverIO是开源的，插件多\n2.1.5 CitrusCitrus是一个开源框架，您可以使用它自动化任何消息传递协议或数据格式的集成测试。\n2.1.6 CypressCypress是一个以开发人员为中心的测试自动化框架，它使测试驱动开发(TDD)成为开发人员的现实。\nCypress运行在浏览器内部。不需要处理对象序列化或在线协议，同时为您提供对每个对象的本机访问。\n2.1.7 Seleniumweb应用程序最流行的开源测试自动化框架之一。\n它具有跨平台和跨浏览器的功能\nSelenium支持多种编程语言，如Java、C#、PHP、Python、Ruby等。\n2.1.8 Cucumber它是一个跨平台的行为驱动开发（BDD）工具，用于编写web应用程序的验收测试。\n2.1.9 Serenity与cumber和JBehave等行为驱动开发（BDD）工具集成的基于Java的框架，适用于自动化验收和回归测试更容易。\n2.1.10 CarinaCarina使用流行的开源解决方案构建，如Appium、TestNG和Selenium，这减少了对特定技术栈的依赖。您可以测试移动应用程序（本机、web、混合）、web应用程序、REST服务和数据库。Carina框架支持MySQL、sqlserver、Oracle、PostgreSQL等不同类型的数据库，提供了MyBatis ORM框架实现DAO层的惊人体验。它支持所有流行的浏览器和移动设备，并且在IOS&#x2F;Android之间重用测试自动化代码高达80%。API测试基于Freemarker模板引擎，它在生成REST请求方面提供了极大的灵活性。Carina是跨平台的，可以在Unix或Windows操作系统上轻松地执行测试。\n2.1.11 ZTFZentao Testing Framework，简称ZTF，是一款开源自动化测试管理框架。更聚焦于自动化测试的管理功能，提供了自动化测试脚本的定义、管理、驱动、执行结果的回传、Bug的创建以及和其他自动化测框架的集成。\nZTF使用go语言开发，可以支持各种平台。\nZTF支持常见的编程语言，您可以选择您喜欢用的语言来开发自动化测试脚本\n2.2 测试计划管理（测试平台）\n 考虑到测试平台一般都应该有测试管理的功能，就不分开调研总结了\n\n2.2.1 禅道国内开源项目管理软件，基于敏捷方法scrum，现今有产品管理、项目管理、测试管理、计划管理等等\n2.2.2 TESTPAD在线工具，可以创建自由形式的结构化检查列表，有助于一系列广泛的测试方法（传统手工、探索型等）。基于JavaScript ui 实现键盘驱动型编辑方式\n2.2.3 Testrail提出xmind、excel各有优缺点，支持自定义用例格式配置。是网页式用户界面。屏幕截图、预期结果、跟踪各个测试的状态、信息丰富的仪表盘等等\n2.2.4 Testlink难得的开源测试管理工具\n2.2.5 飞蛾国内的敏捷测试工具，规范的测试全流程\n2.2.6 junoOneJira集成功能的敏捷测试用例管理和问题追踪工具，提供了很多工具简化测试活动\n2.2.7 jira国外产品、一站式管理，目前购买不到本地部署版本，一款项目与事务跟踪工具\n2.2.8 PingCode国内一站式软件研发项目管理工具，不仅有需求管理、敏捷&#x2F;瀑布&#x2F;看板项目管理，还有专门的测试管理模块，支持用例创建、用例库、用例评审、测试计划、自动生成报告，测试用例还能关联版本、需求、缺陷等\n2.2.9 PractiTest国外，端到端的测试管理系统，提供了手动测试和自动化测试管理选项，还有探索式测试测试管理功能。与缺陷跟踪工具（redmine、jira等）、各种自动化工具（jenkins等）无缝集成\n2.2.10 Kualitee可以与很多工具进行集成\n2.2.11 zephyr enterprise最初是Jira中的一个插件，以增强Jira测试管理的能力，现已开发了企业版，支持Jira、Jenkins、selenium等集成\n2.2.12 Metersphere是一站式开源持续测试平台，涵盖测试管理、接口测试、性能测试、团队协作等功能\n2.2.13 bugzilla开源的、基于Web界面的缺陷跟踪工具\n2.2.14 Testopia一款与bugzilla集成使用的测试用例管理工具，允许用户将缺陷报告与测试用例运行结果集成在一起\n2.2.15 Testmonitor在线测试管理，端到端的测试管理工具\n2.2.16 Klaros-testmanagement德国，功能范围涵盖测试计划、测试创建、测试执行、测试任务分配和评估，以及测试评估和报告创建。还有支持缺陷管理、需求管理、持续集成、测试自动化和性能分析的接口\n2.2.17 QACoverage基于敏捷思想，从需求管理、测试设计、测试执行、缺陷管理以及度量和报告模块\n2.3 接口测试2.3.1 Postman很好用的一款API&#x2F;接口功能测试工具，很方便的塞数据，查看响应，设置检查点&#x2F;断言，能进行一定程度上的自动化测试\n有免费版、pro版、企业版三个版本。个人学习及日常工作免费版完全够用\n语法基于js\n2.3.2 SoapUISoapUI是一个开放源代码且完全免费的工具，因为是基于Java开发的，因此它可以Windows、Mac和Linux系统上进行了接口测试，在业界被视为API service测试的的标准工具\n支持完整的RESTful API和SOAP Web Service测试，并支持功能测试，性能测试，互操作性测试，回归测试等。\n2.3.3 REST-Assured是一套由 Java 实现的轻量级的 REST API 测试框架，可以直接编写代码向服务器端发起 HTTP 请求，并验证返回结果。\n2.3.4 Apifox是接口管理、开发、测试全流程集成工具，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。\n2.3.5 Katalon Studio免费的自动化测试工具，可以安装在windows、macOS、linux操作系统上，基于selenium 和 Appium 测试框架\n支持Web，Mobile，API 类型的自动化测试，它同时可以管理页面元素、测试数据、测试案例、生成自动化测试报告，可以集成到 CI&#x2F;CD 过程中，兼容流行的质量处理工具，包括qTest，JIRA等\n2.3.6开源的Web-API自动化测试框架——KarateKarate是基于另一个BDD测试框架Cucumber来建立的\n2.3.7 WireMock模拟 API，进行快速，强大和全面的测试。WireMock 是基于 HTTP 的 API 模拟器\n2.3.8 Hoverfly基于java，用于模拟api的工具\n2.3.9 Swagger跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目，开发人员几乎可以不用专门去维护rest api\nAPI 开发工具，它遵循 OpenAPI Specification（OpenAPI 规范，也简称 OAS）。 Swagger 可以贯穿于整个 API 生态，如 API 的设计、编写 API 文档、测试和部署。 Swagger 是一种通用的，和编程语言无关的 API 描述规范。\n2.3.10 YApi高效、易用、功能强大的API管理平台\n不仅提供了常用的接口管理功能，还提供了权限管理、Mock数据、Swagger数据导入等功能\n2.4 UI测试2.4.1 Instrumentation早期Google提供的Android自动化测试工具类\n模拟按键按下、抬起、屏幕点击、滚动等事件，通过将主程序和测试程序运行在同一个进程来实现这些功能\n需要配置AndroidManifest.xml文件，不能跨多个App。\n2.4.2 UiAutomatorAndroid提供的自动化测试框架，基本上支持所有的Android事件操作\n可以用UiAutomatorviewer抓去App页面上的控件属性而不看源码\n基于Java\n2.4.3 EspressoGoogle的开源自动化测试框架，规模更小、更简洁，API更加精确\n基于Instrumentation，不能跨App\n2.4.4 Selendroid基于Instrumentation的测试框架，可以测试Native App、Hybird App、Web App，但是网上资料较少，社区活跃度也不大\n2.4.5 robotium基于Instrumentation的测试框架\n2.4.6 Athrun淘宝出的一个移动测试框架&#x2F;平台，同时支持iOS和Android。Android部分也是基于Instrumentation，在Android原有的ActivityInstrumentationTestCase2类基础上进行了扩展，提供一整套面向对象的API。\n2.4.7 Appium开源\nNode.js写的，可以直接用NPM来进行安装\n支持native APP、hybrid APP、web APP\n2.4.10 airtest开源ui测试工具，可视化编程，支持报告\n2.4.11 poco抓取UI控件，目前不算稳定\n2.4.12 airtest-ocr识别文本\n2.4.13 solopi蚂蚁金服开源的一款移动端APP测试工具，提供脚本录制、编辑、回放，结果展示以及一机多控（即通过设备间的socket通讯实现1台手机可以控制多台手机执行脚本）等功能，其测试用例的录制和执行等操作均在手机端的一个APP中完成。不需要借助电脑软件与测试设备交互，所以通信结构比Appium简单高效，对元素的识别也是使用类似于appium的控件的方式，并且引入了类似于airtest的图像识别的方式\n2.5 性能测试2.5.1 perfdog腾讯开发（收费很贵）\n是移动全平台Android&#x2F;iOS性能测试和分析工具平台（web可视化数据管理，需登录），快速定位分析性能问题\n手机无需root或越狱，App应用及游戏也无需做任何修改，极简化即插即用\n2.5.2 LoadRunner常用的性能测试工具，支持脚本录制，也支持编程\n本质是通过http协议压测的。模拟多个浏览器发送不同的数据包给服务器\n2.5.6 SilkPerformer使用可视化脚本生成技术和对存在成千上万的并发用户的多个应用环境进行测试的能力\n2.5.7 Rational Performance Tester适用于基于 Web 的应用程序的性能和可靠性测试。Rational Performance Tester 将易用性与深入分析功能相结合，从而简化了测试创建、负载生成和数据收集，以帮助确保应用程序具有支持数以千计并发用户并稳定运行的性能。\n2.5.8 游戏引擎自带的的性能分析工具Unity Profiler\nMemory Profiler\nURP\nXcode Frame Capture\nInstrument\ntoLua Framework\nUWA（腾讯）\n2.5.9 andorid自带的性能分析工具android studio\n2.5.10 Emmagee开源\nEmmagee(机关枪)是网易杭州研究院QA团队开发的一个简单易上手的Android性能监测小工具，主要用于监控单个App的CPU，内存，流量，启动耗时，电量，电流等性能状态的变化，且用户可自定义配置监控的频率以及性能的实时显示，并最终生成一份性能统计文件。对于手游实时分析CPU和内存占比帮助非常大\n2.5.10 GT腾讯开发\nGT（随身调）安卓&#x2F;IOS手机端调测组件，用于APP的性能测试、竞品测试及仅凭一台手机即可进行App测试。 利用GT，仅凭一部手机，无需连接电脑，您即可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率&#x2F;流畅度等)、 开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等等\n2.6 压力测试2.6.1 JMeter能够对HTTP和FTP服务器进行压力和性能测试， 也可以对任何数据库进行同样的测试（通过JDBC）\n2.6.2 MonkeyAndroid SDK自带的测试工具\n对正在开发的应用程序进行压力测试，也有日志输出。实际上该工具只能做程序做一些压力测试，由于测试事件和数据都是随机的，不能自定义，所以有很大的局限性\n2.6.3 MonkeyRunnerAndroid SDK提供的测试工具（api包），比Monkey强大，可以编写测试脚本（python）来自定义数据、事件\n2.6.4 LoadRunner预测系统行为和性能的负载测试工具，通过模拟实际用户的操作行为进行实时性能监测，来帮助测试人员更快的查找和发现问题\n2.6.5 NeoLoadNeoLoad是Neotys出品的一种负载和性能测试工具，可真实地模拟用户活动并监视基础架构运行状态，从而消除所有Web和移动应用程序中的瓶颈。NeoLoad通过使用无脚本GUI和一系列自动化功能，可让测试设计速度提高5-10倍，并将维护的脚本维持在原始设计时间的10％，同时帮助用户使用持续集成系统自动进行测试\n2.6.6 WebLOAD来自Radview公司的负载测试工具，它可被用以测试系统性能和弹性，也可被用于正确性验证（验证返回结果的正确性）\n测试脚本用js\n2.6.7 阿里云PTS阿里云性能测试（Performance Testing）是一个SaaS性能测试平台，具有强大的分布式压测能力，可模拟海量用户真实的业务场景\n提供压测机\n2.6.8 kylinTOP自动化测试工具-性能测试工具-kylinTOP测试与监测平台介绍 (kylinpet.com)\n奇林测试平台（简称：kylinTOP）是一款国产的集性能测试、自动化测试（UI、接口、APP）、业务&amp;接口监控于一体的产品。kylinTOP是B&#x2F;S架构的分布式系统，支持跨平台（WINDOWS&#x2F;LINUX&#x2F;SOLARIS&#x2F;麒麟&#x2F;MAC等）运行。\n2.7 兼容自动化测试2.7.1 TestIn基于共享经济的测试众包服务平台，发单接单\n2.7.2 腾讯优测拥有千台真实手机，覆盖99%市场主流机型，支持7X24小时设备在线服务，\n2.7.3 百度 MTC百度移动云测试中心简称MTC（Mobile TestingCenter）。 该中心为开发者提供了上百种主流厂商的移动终端设备及增强模拟器，涵盖了Top 100 Android真机和各种配置的模拟器，方便开发者进行实时的手机应用开发和测试工作。\n2.7.4 阿里 MQC移动测试（MQC）是为广大企业客户和移动开发者提供真机测试服务的云平台，拥有大量热门机型，提供7x24全天候服务\n2.8 本地化自动化测试2.8.1 Digvante一个众测社区\n2.9 wiki（知识分享）模块2.10 人员管理模块2.11 平台说明手册模块2.12 BUG管理模块redmine\nbugfree\nbugzilla\nquality center\neasybug\njiar\n禅道\ntestdirector\nexcel\n2.13 系统设置模块2.14 持续测试模块3. 功能原型","categories":["调研"],"tags":["测试框架"]},{"title":"【调研】游戏测试","url":"/2022/11/06/%E3%80%90%E8%B0%83%E7%A0%94%E3%80%91%E6%B8%B8%E6%88%8F%E6%B5%8B%E8%AF%95/","content":"1. 游戏测试现状UI 自动化开发和维护成本高，投入性价比很低，而游戏又是一种界面千奇百怪又元素布局纷繁复杂的软件\n游戏测试落后于现代互联网软件测试\n游戏的cs通信所用协议通常为tcp，而不是http，常用协议测试工具是没法用的，同时也缺乏相关工具\n游戏行业的测试广泛取决于具体公司的文化\n游戏立项时一般不考虑给之后测试自动化\n写个客户端作为测试工具？\n游戏测试环境的搭建和测试数据的构造比传统软件测试领域要复杂\n游戏测试不仅要测开发上的bug，还有策划上的bug，是因为游戏作为一种特殊的软件，需求变化大、不确定因素多 。\n2. 测试平台常见需求2.1 前端web界面提供公共组件：实时查看后台的测试执行情况、展示日周月的后台统计信息（访问量、执行失败数、用例数等等）、图像算法的识别结果统计分析、测试中的bug汇总分析展示、测试数据的一键生成、测试教程（上手、入门、进阶、高级）、平台使用教程等等提供环境管理：类似unity.exe路径、unity项目路径、测试引擎等提供用例中心：可以查看已有测试用例、可以上传测试用例等提供计划管理：可以查看已有测试计划、可以上传测试计划（包括计划发起者、执行者、关联人员规模、进度显示、等级安排、计划-子计划结构、开始时间、关联脚本、关联用例、关联需求、关联需求变动、关联表单、关联的自动化测试任务）、可以更新测试计划（更新人员、更新需求、更新状态、更新关联需求、更新测试报告）提供自动化测试任务管理：可以查看已有测试任务、上传测试脚本、上传自动化测试任务、查看测试报告、查看任务执行情况提供测试追踪：可以查看测试的执行情况、可以追踪测试的所有历史信息（比如执行时间、重复执行次数、每次所用到的脚本、所依据的用例、所测试的项目svn版本号、由谁发起的、发现的bug、bug对应的提单、单子的历史情况等等）、查看自动化测试任务的提供系统管理：支持用户注册（工号、邮箱、昵称等等）、支持项目注册（往平台接入项目，不同项目组的数据要隔离等等）、支持角色权限配置（系统管理员、项目管理员、普通成员等）\n2.2 服务端有数据库统一管理所有数据，表结构设计合理对前端传来的数据做验证（部分用JavaScript在前端验证）有接口管理自动化测试引擎，并发送测试请求，接受测试结果，同时能合理分配执行资源\n2.3 测试引擎让测试执行更加灵活，不受限于资源和网络，不用排队等待或者是和他人竞争资源，用户通过配置来获取自己的执行资源（资源包括服务器权限、包括时间，比如我的定时计划不一定就能被满足，可能是其他人也想在这个时间段跟我占用同一台机子。所以可以把引擎部署到远程服务器，也可以部署到本地）支持接口自动化测试（游戏内的各种接口、第三方skd的接口）支持云真机移动端（Android和Ios）AppUI，app指打包出来的游戏（暂不支持真机）支持PC（Windows、OS）应用UI，应用指Unity、ue、模拟器\n参考流马、lunkyframe、禅道\n关键字UI自动化、并发、收集测试用例收集、客户端平台、前后端、报告、云真机、测试追踪、低代码、分布式、APP测试、游戏、快速上手、测试用例管理、方便调试、定位问题、架构、测试报告、测试日志、测试环境、测试数据、测试用例、设计模式、测试用例标准制定（参考）、测试执行、插件、测试执行、分布式、跨环境执行、使用手册、测试数据可回收、集成CI&#x2F;CD、数据前置处理、测试关键字驱动、QA日常数据收集、webUI（能用吗？录制回放都不怎么用）、APPUI、数据库、mock、工具定位（会替代研发的部分任务吗？有这个能力吗？还是说融入研发体系而不是替代）、封装深度和泛用性、耦合强度和拓展性、原型设计、如何实操（从0开始？先抄一个）、测试数据的准备和销毁（能重复自动化吗？每次都要填新数据？）、接口测试数据验证（仅验证返回值？还要验证数据库？）、unity项目自动打包\n思维借鉴和总结1、减少流程性的测试：把被测的产品功能打碎了，切成一块一块的个体。一个脚本中只测试一个 feature。杜绝了互相影响的同时也简化的 bug 定位的成本，因为你脚本里只测试了这个 feature，失败了就肯定是这个 feature 的问题了，再去看产品源码定位bug。2、测试脚本本身也要有质量，不能无限制地为了没有代码基础的QA而去降低学习要求，以至于牺牲最终质量和效率。3、任何脚本都不做任何持久化的操作，也就是说测试脚本执行前数据库和文件系统是什么样子，执行之后也是什么样子。环境始终是干净的，对每个测试脚本都是一样的。   做法： 在测试脚本运行中创建的什么数据，你在结束后就删除什么数据。   反思：效率如何保证？压力负载被减轻了，可能会有影响。4、\n3. 游戏测试细分领域3.1 服务器2性能测试3.2 游戏客户端（APK&amp;IPA）性能测试android: CPU 内存 流量 耗电量 FPS 显存 GPU 流量 电量\n3.3 移动设备兼容适配测试特别是andorid\n3.4 安全测试内存修改、配置表修改、hook游戏动态修改、代码逆向分析、网络协议攻击\n3.5 网络适应性测试弱网测试、延迟、断网频率、丢包率、上下行带宽\n4. 测试工具一般都是讲自动化测试框架，且一般需要满足三个条件：\n\n稳定系统：已上线的或者需求变动较少的\n周期长：长期运行的，开发周期长的\n脚本复用：脚本可以重复使用以降低维护成本\n\n4.1 UFT（QTP）！QTP是一种基于GUI录制的自动化测试工具，用于在回归测试阶段的时候自动批量执行回归测试用例，QTP是记录用户浏览器的操作步骤数据等去达到录制回放的功能，主要应用于：功能测试、回归测试、service testing.使用UFT、你可以在网页或者基于客户端PC应用程序上、自动模拟用户行为、在不同windows操作系统以及不同的浏览器间、为不同的用户和数据集测试相同的动作行为。当有计划并且适当的方式使用UFT时、可以节省大量的时间和成本。随着11.50版本的发布、QTP 和 Service Test 成为了UFT11.50软件组件中的一部分\n4.2 Selenium它是一个web自动化测试工具，免费小巧，支持分布式测试用例的执行，可以把测试用例分布到不同的测试机器执行，相当于分发机的功能。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。完全开源\n4.3 Appiumappium是移动端最主流的开源自动化测试框架。开源，免费，跨平台（IOS、Android、H5、Windows）。基于Selenium实现、基于JDK+SDK环境运行、现只有Desktop版。支持多语言，因为选择cs设计模式，靠c发送http请求给s即可。\n4.4 PostmanPostman是一个接口测试工具，在做接口测试的时候，Postman相当于一个客户端，它可以模拟用户发起的各类HTTP请求，将请求数据发送至服务端，获取对应的响应结果，\n4.5 JMeterApache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。能够对HTTP和FTP服务器进行压力和性能测试， 也可以对任何数据库进行同样的测试（通过JDBC）。\n4.6 Katalon StudioKatalon是在Selemium相同的内核上构建起来的一个自动化测试工具，用的是Java和Apache Groovy作为其脚本开发语言涵盖的测试范围广：\n\nWeb 的UI自动化\nAPI自动化\n移动客户端（手机APP）自动化\n桌面客户端自动化\n\n可视化操作，内部集成多，外部集成多，主流框架\n4.7 TestComplete！Testcomplete是SmartBear公司开发的一款自动化测试工具，主要应用于UI的自动化测试，收费的。利用自动化测试工具和人工智能支持的混合对象识别引擎，轻松检测和测试每个桌面，Web和移动应用程序。支持.NET,Java,Visual C++, Visual Basic, Delphi, C++Builder 和web应用程序\n4.8 SoapUISoapUI是用于Webservice接口的测试工具，可以是SOAP Webservice以及RESTful Webservice或基于HTTP的服务，SoapUI是一个开放源代码且完全免费的工具，因为是基于Java开发的，因此它可以Windows、Mac和Linux系统上进行了接口测试，在业界被视为API service测试的的标准工具。它通过soap&#x2F;http来检查、调用、实现Web Service的功能&#x2F;负载&#x2F;符合性测试。SoapUI可用于完整的RESTful API和SOAP Web Service测试。您可以进行功能测试，性能测试，互操作性测试，回归测试等等。\n4.9 PerfDog！PerfDog性能狗是移动全平台iOS\\Android性能测试工具平台，快速定位分析性能问题，提升APP应用及游戏性能和品质，收集无需ROOT&#x2F;越狱，手机硬件、游戏及应用无需做任何更改，极简化即插即用。\n4.10 mobileperfmobileperf是阿里开源的一个python PC 工具，可以收集Android性能数据: cpu、内存、流畅度、fps、logcat日志、流量、进程线程数、进程启动日志，mobileperf也支持原生monkey test。\n4.11 PyAutoGUIPyAutoGUI允许Python脚本控制鼠标和键盘，并自动与其他应用程序交互。PyAutoGUI的API设计很简单，非常容易上手，PyAutoGUI适用于 Windows、macOS和Linux系统，支持在Python2和3上运行。PyAutoGUI安装很简单。\n\n移动鼠标并单击其他应用程序的窗口。\n向应用程序发送击键信号，如填写表格。\n截取屏幕截图，并给出一个图像（例如，按钮或复选框的图像），然后在屏幕上找到它。\n找到应用程序的窗口，移动、调整大小、最大化、最小化或关闭它（目前仅适用于 Windows）。\n显示警报和消息框\nPyAutoGUI只能处理主屏幕，双屏幕不支持。也无法确定当前键盘某个键是否被按下\n\n4.12 pywinautoPywinauto是基于Python开发的，用于自动化测试的脚本模块，主要操作于Windows标准图形界面。它可以允许你很容易的发送鼠标、键盘动作给Windows的对话框和控件。\n4.13 k6k6是高性能的负载测试工具，也是一种高性能工具，旨在在预生产和QA环境中以高负载运行测试K6是一个开源的测试工具，底层用GO语言编写，测试代码是采用javascript编写，可以灵活的配置，是一款针对开发人员和测试人员都很友好的命令行性能测试工具\n4.14 LocustLocust是开源的使用Python开发，基于事件，支持分布式并且提供Web UI进行测试执行和结果展示的性能测试工具。locust是一款完全基于事件的负载测试工具，做性能测试使用的‘协程’方式，有webui图形界面、无图形界面、分布式等多种运行方式\n4.15 Mimesis用于 Python 的高性能假数据生成器，它以多种语言提供用于多种用途的数据，用于安全测试\n4.16 冰狐辅助在移动端上提供js版本的辅助api,支持在线实时调试。支持多台设备同时在线调试脚本，在线实时获取所有设备的UI树和log信息。不再需要掌握android那套复杂的调试方法。支持通过“搭积木”、配置参数的方式构建辅助脚本.在后端支持SaaS服务,支持微服务\n4.17 Auto.jsAuto.js是开源软件，支持自定义编写脚本 ，所运行的脚本代码全部可见，可在一定程度上保障安全性，也因此它备受用户的推崇。\n\n悬浮窗录制和运行\n更专业&amp;强大的选择器API，提供对屏幕上的控件的寻找、遍历、获取信息、操作等。类似于Google的UI测试框架UiAutomator，您也可以把他当做移动版UI测试框架使用\n采用JavaScript为脚本语言，并支持代码补全、变量重命名、代码格式化、查找替换等功能，可以作为一个JavaScript IDE使用\n支持使用e4x编写界面，并可以将JavaScript打包为apk文件，您可以用它来开发小工具应用\n支持使用Root权限以提供更强大的屏幕点击、滑动、录制功能和运行shell命令。录制录制可产生js文件或二进制文件，录制动作的回放比较流畅\n提供截取屏幕、保存截图、图片找色、找图等函数\n可作为Tasker插件使用，结合Tasker可胜任日常工作流\n带有界面分析工具，类似Android Studio的LayoutInspector，可以分析界面层次和范围、获取界面上的控件信息\n\n5. 测试框架5.1 TestNGTestNG脱胎于业界标杆的JUnit，但比JUnit更加强大和易于使用。TestNG涵盖几乎所有类型的测试：单元、组件、集成和前端（Selenium+TestNG）等。\n5.2 unittestunittest是Python自带的一个单元测试框架, 它可以做单元测试, 也能用于编写和运行重复的测试工作.它给自动化测试用例开发和执行提供了丰富的断言方法, 判断测试用例是否通过, 并最终生成测试结果.\n5.3 pytestPytest 是一个比较成熟且功能完备的 Python 测试框架。其提供完善的在线文档，并有着大量的第三方插件和内置帮助，适用于许多小型或大型项目。Pytest 灵活易学，打印调试和测试执行期间可以捕获标准输出，适合简单的单元测试到复杂的功能测试。还可以执行 nose, unittest 和 doctest 风格的测试用例，甚至 Django 和 trial。支持良好的集成实践， 支持扩展的 xUnit 风格 setup，支持非 python 测试。支持生成测试覆盖率报告，支持 PEP8 兼容的编码风格。\n\n能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium&#x2F;appnium等自动化测试、接口自动化测试（pytest+requests）;\npytest具有很多第三方插件，并且可以自定义扩展，比较好用的如pytest-selenium（集成selenium）、pytest-html（完美html测试报告生成）、pytest-rerunfailures（失败case重复执行）、+ + + pytest-xdist（多CPU分发）等；\n测试用例的skip和xfail处理；\n可以很好的和CI工具结合，例如jenkins\nreport框架—-allure 也支持了pytest（allure是一个能生成漂亮测试报告的开源框架）\n\n5.4 Robot Framework诺基亚-西门子开发的一款基于python的开源自动化测试框架。官方介绍：Robot Framework是用于验收测试和验收测试驱动开发（ATDD）的通用开源测试自动化框架。它具有易于使用的表格测试数据语法，并使用关键字驱动的测试方法。它的测试功能可以通过用Python或Java实现的测试库进行扩展，用户可以使用与创建测试用例相同的语法从现有的关键字创建新的更高级别的关键字。Robot Framework框架是跨平台的，独立于操作系统和应用程序。核心框架使用Python实现，支持Python 2和Python 3，并且还可以在Jython（JVM）， IronPython（.NET）和PyPy上运行。该框架有丰富的测试库生态，由各种通用测试库（包括内置库、扩展库和自定义库）和工具组成，这些库被作为单独的项目开发。\n5.5 Airtest！Airtest是一款跨平台的UI自动化测试框架，基于图像识别原理，适用于游戏和AppPoco：基于UI控件搜索的自动化测试框架，其核心优势是除了对Android、iOS之外，对游戏也是支持的，同时也支持微信小程序、微信小游戏和H5应用\n5.6 Mock在面向对象程序设计中，模拟对象（英语：mock object，也译作模仿对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象（mock object）来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助\n5.7 MockitoMockito是GitHub上使用最广泛的Mock框架,并与JUnit（java单元测试框架）结合使用。Mockito框架可以创建和配置mock对象.使用Mockito简化了具有外部依赖的类的测试开发!\n5.8 WireMockWireMock是一个开源的测试工具，支持HTTP响应存根、请求验证、代理&#x2F;拦截、记录和回放WireMock 是一个 HTTP 模拟服务器。它的核心是 Web 服务器，它可以准备好为特定请求（存根）提供罐头响应，并捕获传入的请求，以便以后检查它们（验证）。它还具有各种其他有用的功能，包括与其他 API 交互的记录&#x2F;回放、故障和延迟的注入、有状态行为的模拟。它可以被任何 JVM 应用程序用作库，也可以作为独立进程在与被测系统或远程服务器相同的主机上运行。WireMock 的所有功能都可以通过其 REST (JSON) 接口和 Java API 访问。此外，可以通过 JSON 文件配置存根\n5.9 pytest-mockunittest中存在mock模块，那么pytest中也存在mock模块，pytest中的mock使用第三方库：pytest-mockMock是Python中一个用于支持单元测试的库，它的主要功能是使用mock对象替代掉指定的Python对象，以达到模拟对象的行为。python3.3 以前，mock是第三方库，需要安装之后才能使用。python3.3之后，mock作为标准库内置到 unittest。\n5.10 RobolectricRobolectric 是基于 Junit 的单元测试框架，实现了在 JVM 上测试 Android 代码的功能。\n5.11 taurusTaurus是 BlazeMeter 的核心组件，其是一个开源自动化框架，用于运行各种开源负载测试工具和功能测试工具，支持的最流行开源压测工具有 JMeter、Selenum、Gatling、The Grnder、Locust 等\n5.12 JunitJunit 是 Java 语言的单元测试框架，理论上基于 JVM 的语言都可以使用\n6. 测试管理工具6.1 AgileTCAgileTC是一套敏捷的测试用例管理平台，支持测试用例管理、执行计划管理、进度计算、多人实时协同等能力，方便测试人员对用例进行管理和沉淀。产品以脑图方式编辑可快速上手，用例关联需求形成流程闭环，并支持组件化引用，可在各个平台嵌入使用，是测试人员的贴心助手！\n6.2 TestLinkTestLink用于进行测试过程中的管理，通过使用TestLink提供的功能，可以将测试过程从测试需求、测试设计、到测试执行完整的管理起来，同时，它还提供了好多种测试结果的统计和分析，使我们能够简单的开始测试工作和分析测试结果。 TestLink 是sourceforge的开放源代码项目之一。\n6.3 KiwiKiwi 是一个适用于iOS开发的行为驱动测试框架,旨在提供一个足够简单易用的BDD库.\n6.4 MeterSphereMeterSphere（发音：&#x2F;ˈmitərˌsfɪər&#x2F;） 是一站式开源持续测试平台，涵盖测试跟踪、接口测试、性能测试、团队协作等功能，兼容JMeter 等开源标准，有效助力开发和测试团队充分利用云弹性进行高度可扩展的自动化测试，加速高质量软件的交付。\n6.5 ZTFZentao Testing Framework，简称ZTF，是一款开源自动化测试管理框架。与市面上已有的自动化测试框架相比，ZTF更聚焦于自动化测试的管理功能。ZTF提供了自动化测试脚本的定义、管理、驱动、执行结果的回传、Bug的创建以及和其他自动化测框架的集成。ZTF使用go语言开发，可以支持各种平台。ZTF支持常见的编程语言，您可以选择您喜欢用的语言来开发自动化测试脚本。通过禅道自研的ZTF自动化测试工具，可很好地驱动8种单元测试框架、3种自动化测试框架来执行测试，并把最终结果回传给禅道，进行统一的报告展示。禅道ZTF打通了项目管理和持续集成工具之间的沟壑，贯穿持续集成、持续测试、持续部署等DevOps生命周期的不同阶段。\n","categories":["调研"],"tags":["游戏测试"]},{"title":"【踩坑（解决）】Git提交时提示换行符转换问题","url":"/2023/05/26/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91Git%E6%8F%90%E4%BA%A4%E6%97%B6%E6%8F%90%E7%A4%BA%E6%8D%A2%E8%A1%8C%E7%AC%A6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/","content":"当我是使用hexo d -g部署博客时，在INFO  Copying files from extend dirs...这一步会弹出很多类似以下语句的警告：\nwarning: in the working copy of &#39;index.html&#39;, LF will be replaced by CRLF the next time Git touches it\n这个意思是说，当git提交文档时，会根据目标平台的操作系统来决定是否要将LF换成CRLF（或者反过来）\n至于LF CRLF是什么，可自行百度\n我们可以通过设置Git的配置选项来告诉它是否在每次提交时进行转换：\ngit config --global core.autocrlf false\ngit config --global core.autocrlf true\ngit config --global core.autocrlf input\n（根据自己的实际情况，三者选其一，能解决问题即可）\n\n相关讨论：cross platform - What’s the strategy for handling CRLF (carriage return, line feed) with Git? - Stack Overflow\n\n","categories":["踩坑记录"],"tags":["git"]},{"title":"【踩坑（解决）】hexo部署后页面资源加载失败","url":"/2023/05/26/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91hexo%E9%83%A8%E7%BD%B2%E5%90%8E%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/","content":"当我修改了hexo项目根目录下的_config.yml_配置中的# Site 和# URL中的几个选项后，重新部署发现我的网站页面是如下这种效果：\n\n看样子是加载不到相应的静态资源导致的：\n\n猜测是跟url相关的配置没有设置合理的值所导致的，我修改过的只有# URL下的url这一个选项，如下：\nurl: &#39;https://github.com/laihandong/laihandong.github.io&#39;\n问题显然，那么解决方案就是改为正确的地址，如下：\nurl: &#39;https://laihandong.github.io/&#39;\n","categories":["踩坑记录"],"tags":["hexo"]},{"title":"【踩坑（解决）】vscode终端--此系统上禁止运行脚本","url":"/2023/05/16/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91vscode%E7%BB%88%E7%AB%AF--%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","content":"在VSCode的终端输入命令时，出现以下报错信息：\n因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;1351 70 中的 about_Execution_Policies\n解决方案如下：\n\n","categories":["踩坑记录"],"tags":["vscode"]},{"title":"【踩坑（解决）】微信开发者工具--cli命令行进程“卡住”","url":"/2023/05/18/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7--cli%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E7%A8%8B%E2%80%9C%E5%8D%A1%E4%BD%8F%E2%80%9D/","content":"使用python第三方库subprocess 调用微信开发者工具的命令行接口cli login时，进程疑似卡死，总会在p.communicate或者p.wait卡住\n问题分析：\n1.cli login 该命令属于需要交互的命令，即正常在cmd中运行时，它会先输出二维码，等待用户扫码，扫码确认登陆后进程才会结束。\n2.微信开发者命令行工具 cli 本质是启用集成在软件安装目录下的node环境调用js脚本来实现的\n3.js又默认把输出缓存在内存中，而不会立即把输出传回给调用调用命令的python脚本。导致python脚本捕捉不到包含二维码信息的输出，且一直等待用户登录，进程就不会结束\n4.通过任务管理器关闭 微信开发者工具 的进程，该命令的进程仍不会结束，依然卡住。猜测就是，使用命令行调起的进程，和双击 微信开发者工具 调起的进程，两者互不影响？\n验证：同时启动 微信开发者工具.exe 和 cli login，两者都会弹出登录二维码。扫描登录后者的二维码进行登录，cli login 进程结束的同时，微信开发者工具也会跳转到项目配置页面。但是扫描前者的二维码进行登陆后，cli login仍然卡在“\\ waiting for scan and login”，不会结束\n事实证明：想将微信开发者工具集成到自己的测试工具中，不推荐使用类似cli login等需要交互的命令行\n其他尝试：\n有尝试过新建两个streamReader，并为它们各自新建一个进程，实时读取cli login的输出，这样就不会等待该进程结束后才拿得到二维码\n但是事实上发现拿到的二维码是不连续的，中间会被其它输出隔断。大致描述就是，输出一半的二维码，然后有几行字，再出现一半的二维码\n","categories":["踩坑记录"],"tags":["微信开发者工具"]},{"title":"【踩坑（解决）】微信开发者工具--登陆二维码加载失败","url":"/2023/05/18/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7--%E7%99%BB%E9%99%86%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/","content":"在公司内网（windows10）打开微信开发者工具，登录页出现如下报错：\n Error: self signed certificate in certificate chain（伴随着二维码加载失败）\n解决方案：\n可能是环境变量NODE_TLS_REJECT_UNAUTHORIZED设置错误，应该为0，而不是’0’\n","categories":["踩坑记录"],"tags":["微信开发者工具"]},{"title":"【踩坑（解决）】重编译OpenCV","url":"/2022/11/10/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91%E9%87%8D%E7%BC%96%E8%AF%91OpenCV/","content":"一、理论准备\n就拿opencv举例，将python的源代码编译为pyd。\n（为什么呢？因为通过pip安装的opencv-python本身就包含一些被编译后的pyd，而不是全都是py源代码文件。）\n\n(1)C&#x2F;C++编译原理和机制所有高级语言程序想在机器上运行，那么都必须处理成机器能够理解的低级语言（比如二进制的机器语言、嵌入式、汇编语言等），然后再让机器去执行。C&#x2F;C++的编译过程就是把源程序的每一句高级语言编译成机器语言，并保存为二进制文件来给机器运行，具体包括如下几个步骤：\n\n预编译 gcc -E xxx.c -o xxx.i预处理器会将#*这些命令进行展开，也叫“宏展开”，目的是好在接下来的阶段进行替换。不仅是把define的值展开，也即将include的外部代码加载替换进来了。这时候生成的临时的预编译文件是以.i为后缀*。当然，类似注释、#pragma等字符也是在预编译里处理的。\n\n（正式）编译 gcc -S xxx.i -o xxx.s 这个过程是编译器将一个个独立的（高级语言）.c&#x2F;.cpp文件作为基本单元，编译成一个个汇编代码文件（编译器是通过后缀名来确定是否编译该文件，比如.h文件就不会进行编译）。 这时候生成的汇编代码文件是以.s为后缀。\n 在翻译成汇编语言前，工作的内容可以粗略分为两部分： 一是，检验函数或者变量是否存在它们的声明（至于怎么实现函数，要在链接中再去找函数入口地址，include***本质就是提供声明）；二是，检查语句是否符合C&#x2F;C++语法。 拓展：汇编语言和硬件有很大的关系，所以如何优化生成的汇编代码是一项重要的技术\n\n汇编 gcc -C xxx.s -o xxx.o 把汇编语言代码，一条条转化成机器语言（二进制）代码，也就是目标代码。有汇编语句和机器指令的对照表，翻译即可。 这时候生成的目标代码文件（也叫可重定位目标文件），是以.o(linux)&#x2F;.obj(windows)为后缀的。\n 目标文件中存储了编译后的机器指令代码、数据、符号表、调试信息、字符串等等内容，并把这些信息按不同的属性以“段”的方式存储，目标文件从结构上说，是已经编译好之后的可执行文件。，但其实不可以直接执行（二进制可执行文件也是一种目标文件）\n 注意：但由于之前是以一个个源代码文件进行编译的，所以一个个的目标文件未经过链接之前，有些地址和符号还未调整\n\n链接 gcc xxx.o -o xxx 由于目标文件并不能立即被执行，所以这一步主要解决目标文件的互相依赖关系，由链接器将各种符号引用和符号定义转化为可执行文件中的合适信息，通常是虚拟地址。 这时候一般生成的可执行文件（也叫可执行目标文件）是以.exe(windows)&#x2F;.out(linux)&#x2F;无后缀(linux)为后缀的\n 还有一种特殊的目标文件叫共享目标文件（又叫库文件），也能由链接器创建并通过指定-G选项来生成指定形式。 库文件的一种是静态库（.a(linux)&#x2F;.lib(windows)）， 库文件的另一种是动态库（.so(linux)&#x2F;.dll(windows)），\n （这两种库文件还没搞清楚，待更新）\n\n\n(2)C&#x2F;C++编译工具和编译器(3)C&#x2F;C++编译出的东西如何使用(4)大型项目需要用到的编译工具(5)不同系统下编译的相通之处二、资源准备\n编译器：MSVC2019（等于安装Microsoft Visual Studio 2019）\n编译工具：CMake-gui（官网链接）\npython环境：建议使用python3（官网链接）\nopencv源代码包：建议4.0及以上系列（官网链接）\n操作系统：Windows 10\n\n三、操作步骤(1)CMake配置用cmake-gui选定源码包后，在默认的配置上，还需要做的工作如下：\n\n勾选python3相关的配置\nopencv-contrib配置\nFREExx的配置（可以调用收费算法）\npydxx的配置（把必要的库一起编译进最终的cv2 pyd文件，以免出现导入库时找不到模块的报错）\n\n(2)Configure&amp;Generate这一步和（1）交叉进行，直到必要的配置都设定好后，且没有报错与红色区域为止。\n(3)生成解决方案用visual studio打开opencv.sln，对两个文件（xx和xx）进行release重新生成方案。\n(4)安装opencv-python和opencv-contrib-pythonpython版本不要过低即可（本人亲测3.6、3.8、3.10均可），先pip install opencv-python和opencv-contrib-python（版本与用源码编译的opencv保持一致）\n(5)替换cv2.pyd将以源码方式编译出来的cv2.pyd，把python的cv路径里的相同文件给替换掉即可。\n(6)验证结果import cv2img = cv2.imread(&#x27;xx/xx.jpg&#x27;)cv2.imshow(img)  # 若正常显示图片，则证明导入成功\n\n本文待完善（尽自己可见）\n","categories":["踩坑记录"],"tags":["OpenCV"]},{"title":"【阅读笔记】《资本论》","url":"/2024/01/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%B5%84%E6%9C%AC%E8%AE%BA%E3%80%8B/","content":"资本论不是经济学理论，资本论的副标题是政治经济学批判，马克思也不是经济学家。\n政治学、法学、经济学、社会学等社会科学都有两个特点：一是实证的，从事实出发；二是把事实放在逻辑框架中去的\n\n我认为这些学科给人一种自信甚至傲慢的感觉，对凡是不符合或者偏离当前学科的逻辑体系的事实，都要进行纠正甚至抹杀。而这个“不符合、偏离”是怎么定义的呢？仅从实证出发，你无法得出任何的“不符合、偏离、对与错等”这种概念，或者说这并不是因果关系。\n所以我感觉几乎所有的学科都有一个局限性，就是理性，太理性了。而事实是理性、非理性交杂分不清的，几乎所有学科都在逃避这一点，同时还为这一点自豪。\n\n范畴。事实是被范畴建构的。范畴与范畴之间有逻辑关系，这样构建的事实都是理性的。\n\n经济事实：资本–雇佣–劳动（所包含的范畴：雇佣的范畴包括工资（资本–工资–商品）、价值范畴（等价交换包括价值））\n\n将事实中的范畴清洗掉\n\n事情本身：生产资料行使对活劳动的支配权\n\n\n马克思发动哲学革命就是清洗掉事实中隐藏的范畴，还原事实本身。\n胡塞尔：现象学还原\n资本就是过去积累起来的劳动，机器、厂房等都是积累起来的劳动。个人是拥有活劳动能力的。\n社会权力（Social Power），是非理性的人与人的关系（就是冲突、对抗），是一部分人支配一部分人。人们要么选择支配别人，要么成为被支配的对象。利益是最实际的，消灭敌人就是最实际的。\n\n在减少减轻或消除人与人的不平等关系方面，人类在几千年的发展时间中没有取得任何的进步\n\n资本的增长就是人与人之间的不平等关系的扩大，资本所拥有的社会权利扩大，就会有更大的冲突对抗。\n\n全球化的资本主义发展最终导致更大的不平等，以及更大的权力对抗，即国与国的对抗（穷兵黩武），国庆告诉我，全球化到一定阶段必定有大动作，现在只是将计就计而已。\n\ncapital（das kapital）：\n\nwealth\npower\n\n社会权力（power）不是观念（idea），是一种感性的、增值的力量。中间经过意识形态（ideology）的转变，产生了权利（right）。\n把权力（power）比作重力，不能认为重力是一种观念。\n货币、商品交换作为异质要素，遵循价值规律存在于社会计划经济体系，这样的计划经济一定会被突破，只不过是是从没有资本家的资本社会到资本社会，新的社会权力诞生，意识形态表达它，新的上层体系和法的制度都要表达它。经济基础决定上层建筑（思想上层建筑：意识形态、政治上层建筑：国家制度和权力体系）\n\n或者说当时的“没有资本家”是当权阶级\n\n","categories":["阅读笔记"]},{"title":"【随笔】2023随笔集","url":"/2023/12/30/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912023%E9%9A%8F%E7%AC%94%E9%9B%86/","content":"网民失去双腿\n失去双臂\n失去双耳\n满口的唾沫\n模糊了双眼\n社会一块透镜接收宇宙的光\n从此便有了光\n这是五彩斑斓的黑\n我本诞生于黑暗\n却未曾不见得光\n","categories":["随笔"]},{"title":"【随笔】2024随笔集","url":"/2024/02/26/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912024%E9%9A%8F%E7%AC%94%E9%9B%86/","content":"自省\n凡事都是需要主动性的，只有掌握了主动权，才能让事情更加顺利\n\n学习任何领域内的知识，前中期的主要工作是理解基础知识，掌握基础能力，而不是过于深究理论，线性连续的知识获取的体验是天然不存在的。\n\n三分钟热度也能有三分钟收获，想做的事下一秒就开始行动\n\n对某个技术&#x2F;人&#x2F;理论的盲目的崇拜会使我陷入崇拜怪圈\n\n不卑不亢，强中自有强中手，同时自己也不差\n\n生理机能告诉我们不要重复任何“错误”的行为和认知，反而要反复练习“正确”的事情，将其刻入本能\n\n生命在于运动，深刻的思考需要清醒的大脑，清醒的大脑需要一个健康朝气的身体\n\n妄想以思考替代实践，实践高度决定自身上限，思想引领实践方向，实践反过来影响思考，而这种影响是纯靠思考所不能得到的\n\n保持对外部世界和内在世界的高度感知\n\n万物相通，你在某个领域或得的感悟，不妨试试放在其它各个方面都推演和代入一下\n\n\n信息茧房小白鼠以为每天都有无限的食物\n我以为每天都有无限的信息\n小白鼠以为食物就是这样\n我以为信息就是这样\n小白鼠吃饱了就可以睡觉\n我看累了就懒得思考了\n但小白鼠是离不开实验室的\n而我可以选择离开屏幕\n而屏幕外的\n是一个个铁笼\n困住了一个个我\n信息我站在这\n我能听见\n哪来的香味\n好惬意\n是枪声吗\n我是在害怕吗\n好痛苦\n好温暖\n你我之所见所感\n皆是信息\n死亡人的一生会死亡两次\n第一次是其肉体倒下时\n第二次是其精神被遗忘时\n每个人天生就适合当刽子手\n因为人无法记住所有人的精神\n甚至自己的栖息地也没守住\n共情人为什么要有感情，若人生来理性，世界还会有那么多痛苦和不幸吗？\n死亡2唯有对死亡的恐惧以及对他人遭受苦难的同情支撑着我活下去\n意义哪些支撑着你活下去的一切事物的总和就是你人生的意义\n","categories":["随笔"]},{"title":"【随笔】AI时代到来了么","url":"/2024/02/25/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91AI%E6%97%B6%E4%BB%A3%E5%88%B0%E6%9D%A5%E4%BA%86%E4%B9%88/","content":"先上结论，AI在未发生质变之前，其上限就是一个趁手的工具，能够极大地提高人类工作的效率，缩短想法到落地的时间，同时影响了人们的思考方式从而进一步解放了人类的创造力。也就是说，AI会极大地改变人类目前的工作方式，而不会改变工作内容。AI发生质变是指能和人一样思考和使用工具。我认为其从原理上是不可能的。由此，我们可以来分析一些社会热点以及思考自身如何把握AI。\nAI艺术创作AI艺术创作：人类借助AI缩短了单个创作所需要的时间，在AI大语言模型（llm）普及初期高度产出大量主要或者完全由AI生成的作品，以数量级的优势占据了市场（一段时间），从而获取了大量收益。关于AI的知识产权的社会讨论也随之更为剧烈，相关法律建设由此开始被加速推动。\n那为什么主要热点都在文化艺术创作上？AI在其他方面呢？\n先回答为什么：优秀的艺术创作的成本周期长，收益高，其内容属性和大语言模型的工作对象（电子信息）相契合。AI继续发展，最终产出相对应的优秀AI艺术创作所需的时间也会归于稳定，在达到这种程度之前，入局AI艺术创作都会有可观收益，注意要找到合适的细分赛道。再看看AI在其他行业：一些成本周期短—投入多少立马产出多少—的行业（重复的流水线作业、实体服务比如餐饮&#x2F;旅游&#x2F;出行）内容属性和大语言模型不直接契合甚至不契合的行业（物理、材料制造业）工作方式很难再发生改变的行业（生物化学制药等）；AI无法触及的领域（人类情感、体验、思考）以上举的例子，他们的行业主要工作内容是不会被如今正火的大语言模型元AI所波及的。\n把握AI用AI“搞钱”一定是大部分人首先想到的。那么按照上问讲的“AI提高效率”以及“AI适用行业”的逻辑，我们可以有两个方向：一是跟着入局目前的热点场景&#x2F;行业—文化艺术创作—一定会有收益的，至于如何找到合适的细分赛道，暂且按下不表；二是去找到现在并不直接契合大语言模型的行业和场景，但会在可接受的时间内充分地用上AI的行业，提前布局，提前入局；\n格局打开，换种思路，用AI扩大收益&#x2F;降低成本，不直接产生经济收益的“搞钱”。\n扩大什么收益？情感、信誉、人情、声誉降低什么成本？时间、精力不直接产生经济效益？AI生成一个视频发布后获得流量有媒体的分成收入，这叫直接。AI生成了一篇论文，你节省了数周的时间去做其他事，这叫不直接。\n那么由此展开，代入自己的本职工作&#x2F;副业&#x2F;社会角色，你想在哪方面获得更大的收益？你想在哪方面减少成本的投入？我作为一名自由职业者（无业游民），我需要学习大量的职业技能，AI工具就能缩短我从学习到实践的周期耗时，我只要保持和没有AI加持时差不多的精力就能同时保证学习&#x2F;实践质量。或者作为一名学者&#x2F;学生，需要阅读大量书籍文献，使用AI快速分析一本书&#x2F;一篇文献，并基于此展开连续对话式的学习，让刨根问底，提纲挈领，触类旁通成为触手可及的技能。\n展望总之，你所接触的事物只要能在物理层面和电子信息联系上（比如，书&#x2F;声音&#x2F;照片不仅可以是实体的，也可以有电子版的，这就可以和电子信息联系在一起了），就意味着会与AI大语言模型有联系，那么你就可以尝试去探索能否用AI赋能自己。\n","categories":["随笔"]},{"title":"【心得】个人成长","url":"/2024/03/06/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/","content":"思考“大”问题 比如人生主题，自己想过一个怎样的人生，一般来讲人生主题可能就一到两个\n或者阶段性的目标，比如20-30岁该往哪个目标努力\n“大”问题不会轻易改变，这是自己内心最真实的想法，也是自我驱动力的源泉\n繁化简如果一件事情理论上可行，那么就开始将其拆分成一个个具体的步骤。标准是以目前的个人能力是完全能够做到的。\n一步一个脚印，才更有可能到达彼岸\n时间分配做事情的先后顺序，有个一般公式：紧急且重要、紧急但不重要、重要但不紧急、不重要且不紧急\n例外，将自己状态最好的事件花在自己最看中的事情上面、处理难度更高的事情上\n","categories":["心得"],"tags":["个人成长"]},{"title":"【心得】如何学习","url":"/2024/03/10/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%AD%A6%E4%B9%A0/","content":"貌似人类获取知识是从接触到文字开始的，但我认为不然。那为什么我们还要记笔记，整理知识点甚至搭建个人知识库（也称“外脑”）呢？因为现在是信息时代，这个时代让我们很难再过着木心诗里写的“从前的日色变得慢 车，马，邮件都慢 一生只够爱一个人”^1的生活了。逃避或拥抱信息洪流，都可以是一个好的选择，我选择后者。那自然而然我就会去思考如何高效地获取，吸收和整理信息，最终帮助自己不断成长，实现一个个人生目标。\n何为记笔记我们从会读书写字开始，就可以说是掌握了记笔记的能力。我们把课本上自己认为重要的知识点进行圈圈划划，或者摘抄，或者按自己的理解复述到笔记本上。不论我们记不记笔记，知识点它就在那里，安安静静地躺在课本上。也就是说，我们记的不是笔记，而是自己的理解。\n我们为了能够理解书中的知识，会尝试反复去阅读，背诵，练习和实践。在节奏相对慢的时期，这样的方式屡试不爽。而面对更多的信息和更具挑战性的目标时，我会发现我的脑子”不够用“了，或是时间不够充裕，亦或是效率不尽人意，这迫使我去寻找面对各种问题时，表现更好的学习方式（或学习流）。\n我相信“为了学习而学习”并不是当下大多数人的真实需求，将学习和实践生产结合起来才是更加务实的选择。如果我们记出来的“笔记”只是另外一种形式的“课本”，那么这将缺乏实践意义^2。换句话说，只有当我们记的“笔记”称为我们实践中趁手的工具时，这种“笔记”才是我们想要的。一本简简单单的纸质&#x2F;电子笔记本也好，一个复杂的知识库也罢，我认为两者本质上就是我们为将来的自己量身打造的一个趁手的工具^3。\n何为学习学习了这么多年，我觉得学习从宏观层面来讲无非是知识获取、输入、理解消化、以及输出知识，只要肯在这三方面下功夫就一定能有所收获。\n关于如何做到知识获取，我自己是经历过暴力灌输的填鸭教学、墨守成规的权威认同、润物细无声的寓教于乐，以及如今网络时代的信息随用随取的。这四种的每一种方式都是不完全取决于个人，而是时代社会环境下的产物。我们能做的就是努力掌握更多的主动权，筛除对我们无利甚至有害的信息，主动选择对个人成长和实践生产更有利的信息^4。\n如何让知识输入到我们的脑子里呢？我目前的想法是，除了应试等功利性很强的场景，遵循顺其自然的原则。关于如何将应试的知识输入到脑中，不变的方式就是反复：反复记忆、反复练习，加强短期记忆和肌肉记忆。这和自己理不理解所输入的知识，是没有太大关系的，要不然说何来权威呢。换句话说，从知识的输入到完全理解，这还有很长一段路要走呢。\n至于如何理解消化我们的摄入的知识，这绝对是我认为最复杂的问题了。首先我是肯定天赋论在理解知识方面的重要影响的，当然这也是很难改变的一点，所以我并不打算展开说。其次，我想到了几个成语，“一点就通”、“恍然大悟”，我认为的“理解”就是“通”，就是“悟”，正所谓“触类旁通”，“一通百通”，“龙场悟道”。而不是那种溯及宇宙起源、探究终极奥义才叫“理解”。一言以蔽之，“理解”即“消化”，即将知识化为我们个人的一部分。\n 最后就是输出知识，从上面不难看出，输出知识的前提不一定包含理解知识，甚至不一定包含知识输入。我们只需要把知识运用到想用到的地方，就可以称作知识输出了。我想起一句网络语，“它（知识）就是一块砖，哪里需要哪里搬”。\n做个简短的总结，学习的前提是有东西（知识）要学，这是一个主观概念，其次是学了有用，不论用处在哪，这同样是一个主观概念^5。对于已经完成社会化的人类来说，我们无时无刻不处于学习之中。进一步讲，对于信息时代的人类来说，几乎所有人都不缺乏学习的机会，也正是这样，我们社会很大部分人所讨论的“学习”，都离不开的主旨之一就是“竞争”，是抢夺资源。与此同样重要的是，人作为理性和非理性的结合体，学习的第二大主旨就是“向内的精神世界的探索”。\n学习的原则继宏观而又抽象的概念缕清后，就不得不提一些实用可行的方法论。我比较推崇并一直践行的是费曼学习法^6，同时我也在摸索更多优秀且适合自己的方法–个人知识库^7。\n首先，我们得先了解智库^8。然后，我所认为的个人知识库它不同于智库，它更类似我们个人具体生活中的一个个军师（或统称为智囊团），他们由你一手培养，在你的征战之路上助你一臂之力。\n由于每个人的学习理念、方式方法都不尽相同，所以个人知识库天生是具有高度定制化属性的。个人知识库包含个人学习的整个流程，从获取、输入、理解、输出，应有尽有，也正因为如此，个人知识库**注定不能做到All in one**。我们只能尽力去使用合适的工具，让我们的个人知识库更加井井有条，高效使用。而不是亲手给自己量身定做的一个精致的信息茧房。\n于是我开始思考，既然大部分的知识就在那里，它就在课本里、视频里和经验教训里等等，那我该以怎样的方式将它们用到该用的地方，以及怎么才能把这些知识用好。方式方法的内容是可以不断迭代升级的，但是出发点和目的地一般是不变的。这就是我在接下来的实践中应该遵循的原则。\n如何实践购买学习资料、收藏网咯博客、写文章记录所闻所感等等，这些都是知识。我们只需要把它们摆在自己的书桌书架上，整理进书签列表中，写在随笔集笔记本或发表在个人账号上。这就是所谓的知识的输入和储备了，每个人都可以做到也不难做到。\n我们继而花上一段又一段的时间去看、去听、去揣摩，直到自己认为自己懂了。如果在接下来的实践中，又觉得自己没懂，我们又要重头学一遍了，然后再去实践，周而复始。在这个过程中，重复次数越少，我们越能在有限的时间内达到更高的实践高度。\n上文提到，即使学不会也理解不了，我们依然可以做到知识的输出和实践。而随着我们面临的处境越复杂、越具有挑战性，我们一是需要去理解所学的知识，二是去记牢所输入的知识，三是将重新学习的成本降到更低。这三点就是找到适合自己的学习方法的所遵循的实践标准。\n第一点，讲究顺其自然，触类旁通。多看多听多实践，现在不懂得，等阅历够了，这条道理就通了。\n第二点，就是重复记忆，就是复习，要多次重复、多角度重复。对于紧急任务，就要形成牢固的短期记忆，对于长期目标，就要形成持续的长期记忆。忘得慢就是记得牢，忘的少就是记的多，想忘掉都难就是非常好记。相关的理论有很多，比如卡片式记忆法、艾宾浩斯遗忘曲线等。\n第三点，复盘、梳理脉络、写博客等记录式总结，都是可以降低再次学习的成本的。\n最后，不要纠结于使用什么软件，也不要纠结于是否完全无纸化等等。保持不断地输入积累以及亲身实践，中途时不时停下来整理总结和复盘，并将主动记忆变得日常化，干就完了。\n 行笔至此，我怅然释怀。学习向来不是一个问题，具体的实践才是。\n本文分享到这就结束了，笔者会继续保持更新的。\n\n","categories":["心得"],"tags":["知识库"]},{"url":"/2024/07/05/Unity/Unity%E4%B9%8B%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/","content":"c\n出现方块字–口口口Unity version 2022.3.15f1c1\n解决方法：调大font assets的Atlas Width和Atlas Height\n\nSet Native Size和图片实际尺寸不一样Unity version 2022.3.15f1c1\n问题描述（补充）：这里设置set native size后，但图片在场景中的尺寸是实际真实尺寸的5倍！\n\n解决方案：在该物体的父级Canvas中，修改canvas scalar组件的reference pixels per unit为20\n\n","categories":["Unity疑难杂症"]},{"title":"【线性代数】奇异矩阵的名字由来","url":"/2024/07/19/%E6%95%B0%E5%AD%A6/%E3%80%90%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E3%80%91%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%8D%E5%AD%97%E7%94%B1%E6%9D%A5/","content":"顾名思义，因为这种矩阵相对来说很特别、稀有，所以显得奇异。\n而为什么会稀有呢？首先回顾一下向量的线性相关与无关的概念，往已有k个n维的向量组中添加一个新的向量，新向量落在原向量组的张成空间的概率几乎为0！\n例：[0 0 1]、[0 1 0]两个向量组成一个平面，然后再选取一个任意3维向量，它落在（3维空间）平面上的概率为0\n而矩阵就是由列向量组成的，对应着向量空间，这也是为什么出现”列向量线性相关“的概率几乎为0，继而被称为奇异矩阵。\n","categories":["数学"]}]