<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="https://laihandong.github.io/atom.xml" rel="self"/>
  
  <link href="https://laihandong.github.io/"/>
  <updated>2024-10-23T16:28:36.000Z</updated>
  <id>https://laihandong.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【线性代数】奇异矩阵的名字由来</title>
    <link href="https://laihandong.github.io/2024/07/19/%E6%95%B0%E5%AD%A6/%E3%80%90%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E3%80%91%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%8D%E5%AD%97%E7%94%B1%E6%9D%A5/"/>
    <id>https://laihandong.github.io/2024/07/19/%E6%95%B0%E5%AD%A6/%E3%80%90%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E3%80%91%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%8D%E5%AD%97%E7%94%B1%E6%9D%A5/</id>
    <published>2024-07-19T09:16:03.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，因为这种矩阵相对来说很特别、稀有，所以显得奇异。</p><p>而为什么会稀有呢？首先回顾一下向量的线性相关与无关的概念，往已有k个n维的向量组中添加一个新的向量，新向量落在原向量组的张成空间的概率几乎为0！</p><p>例：[0 0 1]、[0 1 0]两个向量组成一个平面，然后再选取一个任意3维向量，它落在（3维空间）平面上的概率为0</p><p>而矩阵就是由列向量组成的，对应着向量空间，这也是为什么出现”列向量线性相关“的概率几乎为0，继而被称为奇异矩阵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;顾名思义，因为这种矩阵相对来说很特别、稀有，所以显得奇异。&lt;/p&gt;
&lt;p&gt;而为什么会稀有呢？首先回顾一下向量的线性相关与无关的概念，往已有k个n维的向量组中添加一个新的向量，新向量落在原向量组的张成空间的概率几乎为0！&lt;/p&gt;
&lt;p&gt;例：[0 0 1]、[0 1 0]两个向</summary>
      
    
    
    
    <category term="数学" scheme="https://laihandong.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://laihandong.github.io/2024/07/05/Unity/Unity%E4%B9%8B%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    <id>https://laihandong.github.io/2024/07/05/Unity/Unity%E4%B9%8B%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</id>
    <published>2024-07-05T11:26:03.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>c</p><h1 id="出现方块字–口口口"><a href="#出现方块字–口口口" class="headerlink" title="出现方块字–口口口"></a>出现方块字–口口口</h1><p>Unity version 2022.3.15f1c1</p><p>解决方法：调大font assets的Atlas Width和Atlas Height</p><p><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202407061118688.webp"                      alt="image-20240706111831456"                ></p><h1 id="Set-Native-Size和图片实际尺寸不一样"><a href="#Set-Native-Size和图片实际尺寸不一样" class="headerlink" title="Set Native Size和图片实际尺寸不一样"></a>Set Native Size和图片实际尺寸不一样</h1><p>Unity version 2022.3.15f1c1</p><p>问题描述（补充）：这里设置set native size后，但图片在场景中的尺寸是实际真实尺寸的5倍！</p><p><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202407051930704.webp"                      alt="img"                ><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202407051930717.webp"                      alt="img"                ></p><p>解决方案：在该物体的父级Canvas中，修改canvas scalar组件的reference pixels per unit为20</p><p><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202407091014511.webp"                      alt="image-20240709101423222"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;c&lt;/p&gt;
&lt;h1 id=&quot;出现方块字–口口口&quot;&gt;&lt;a href=&quot;#出现方块字–口口口&quot; class=&quot;headerlink&quot; title=&quot;出现方块字–口口口&quot;&gt;&lt;/a&gt;出现方块字–口口口&lt;/h1&gt;&lt;p&gt;Unity version 2022.3.15f1c1&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Unity疑难杂症" scheme="https://laihandong.github.io/categories/Unity%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
  </entry>
  
  <entry>
    <title>【心得】如何学习</title>
    <link href="https://laihandong.github.io/2024/03/10/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://laihandong.github.io/2024/03/10/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-10T10:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>貌似人类获取知识是从接触到文字开始的，但我认为不然。那为什么我们还要记笔记，整理知识点甚至搭建个人知识库（也称“外脑”）呢？因为现在是信息时代，这个时代让我们很难再过着木心诗里写的“从前的日色变得慢 车，马，邮件都慢 一生只够爱一个人”<a class="link"   href="https://baike.baidu.com/item/%E4%BB%8E%E5%89%8D%E6%85%A2/17158480" >^1<i class="fas fa-external-link-alt"></i></a>的生活了。逃避或拥抱信息洪流，都可以是一个好的选择，我选择后者。那自然而然我就会去思考如何高效地获取，吸收和整理信息，最终帮助自己不断成长，实现一个个人生目标。</p><h1 id="何为记笔记"><a href="#何为记笔记" class="headerlink" title="何为记笔记"></a>何为记笔记</h1><p>我们从会读书写字开始，就可以说是掌握了记笔记的能力。我们把课本上<strong>自己认为重要</strong>的知识点进行圈圈划划，或者摘抄，或者按自己的理解复述到笔记本上。不论我们记不记笔记，知识点它就在那里，安安静静地躺在课本上。也就是说，我们记的不是笔记，而是<strong>自己的理解</strong>。</p><p>我们为了能够理解书中的知识，会尝试<strong>反复</strong>去阅读，背诵，练习和实践。在节奏相对慢的时期，这样的方式屡试不爽。而面对更多的信息和更具挑战性的目标时，我会发现我的脑子”不够用“了，或是时间不够充裕，亦或是效率不尽人意，这迫使我去寻找面对各种问题时，表现更好的学习方式（或学习流）。</p><p>我相信“为了学习而学习”并不是当下大多数人的真实需求，将<strong>学习和实践生产结合</strong>起来才是更加务实的选择。如果我们记出来的“笔记”只是另外一种形式的“课本”，那么这将缺乏<strong>实践意义</strong><a href="%E6%88%91%E8%AE%A4%E4%B8%BA%E6%9E%B6%E7%A9%BA%E7%BA%AF%E7%90%86%E8%AE%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E7%9A%84%E8%BF%99%E7%A7%8D%E8%A1%8C%E4%B8%BA%E6%98%AF%E6%B2%A1%E6%9C%89%E5%AE%9E%E8%B7%B5%E6%84%8F%E4%B9%89%E7%9A%84">^2</a>。换句话说，只有当我们记的“笔记”称为我们实践中趁手的工具时，这种“笔记”才是我们想要的。一本简简单单的纸质&#x2F;电子笔记本也好，一个复杂的知识库也罢，我认为两者本质上就是<strong>我们为将来的自己量身打造的一个趁手的工具</strong><a href="%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E6%98%AF%E8%BE%85%E5%8A%A9%E6%88%91%E4%BB%AC%E6%8A%8A%E8%BE%93%E5%85%A5%E7%9A%84%E7%9F%A5%E8%AF%86%E7%94%A8%E5%88%B0%E8%AF%A5%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9">^3</a>。</p><h1 id="何为学习"><a href="#何为学习" class="headerlink" title="何为学习"></a>何为学习</h1><p>学习了这么多年，我觉得学习从宏观层面来讲无非是知识获取、输入、理解消化、以及输出知识，只要肯在这三方面下功夫就一定能有所收获。</p><p>关于如何做到<strong>知识获取</strong>，我自己是经历过暴力灌输的填鸭教学、墨守成规的权威认同、润物细无声的寓教于乐，以及如今网络时代的信息随用随取的。这四种的每一种方式都是不完全取决于个人，而是时代社会环境下的产物。我们能做的就是努力掌握更多的主动权，筛除对我们无利甚至有害的信息，<strong>主动选择对个人成长和实践生产更有利的信息</strong><a href="%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84%E2%80%9C%E6%9C%89%E5%88%A9%E2%80%9D%E6%98%AF%E5%BB%BA%E7%AB%8B%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%9B%B4%E7%A1%AE%E5%AE%9A%E7%9A%84%E4%BA%8B%E6%83%85%E4%B8%8A%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%A8%A1%E7%B3%8A%E7%9A%84%E9%A2%84%E6%9C%9F">^4</a>。</p><p>如何让<strong>知识输入</strong>到我们的脑子里呢？我目前的想法是，除了应试等功利性很强的场景，遵循<strong>顺其自然</strong>的原则。关于如何将应试的知识输入到脑中，不变的方式就是<strong>反复</strong>：反复记忆、反复练习，加强短期记忆和肌肉记忆。这和自己理不理解所输入的知识，是没有太大关系的，要不然说何来权威呢。换句话说，从知识的输入到完全理解，这还有很长一段路要走呢。</p><p>至于如何<strong>理解消化</strong>我们的摄入的知识，这绝对是我认为最复杂的问题了。首先我是肯定<strong>天赋论</strong>在理解知识方面的重要影响的，当然这也是很难改变的一点，所以我并不打算展开说。其次，我想到了几个成语，“一点就通”、“恍然大悟”，我认为的“理解”就是“通”，就是“悟”，正所谓“触类旁通”，“一通百通”，“龙场悟道”。而不是那种溯及宇宙起源、探究终极奥义才叫“理解”。一言以蔽之，“理解”即“消化”，即<strong>将知识化为我们个人的一部分</strong>。</p><p> 最后就是<strong>输出知识</strong>，从上面不难看出，输出知识的<strong>前提</strong>不一定包含理解知识，甚至不一定包含知识输入。我们只需要把知识运用到想用到的地方，就可以称作知识输出了。我想起一句网络语，“它（知识）就是一块砖，哪里需要哪里搬”。</p><p>做个简短的总结，学习的前提是有东西（知识）<strong>要</strong>学，这是一个主观概念，其次是学了有用，不论用处在哪，这同样是一个<strong>主观概念</strong><a href="%E6%88%91%E8%AE%A4%E4%B8%BA%E5%AD%A6%E4%B9%A0%E4%BB%8E%E5%AE%A2%E8%A7%82%E4%B8%8A%E6%9D%A5%E8%AE%B2%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%BF%A1%E6%81%AF%E6%B5%81%E5%8A%A8">^5</a>。对于已经完成社会化的人类来说，我们无时无刻不处于学习之中。进一步讲，对于信息时代的人类来说，几乎所有人都不缺乏学习的机会，也正是这样，我们社会很大部分人所讨论的“学习”，都离不开的主旨之一就是“<strong>竞争</strong>”，是抢夺资源。与此同样重要的是，人作为理性和非理性的结合体，学习的第二大主旨就是“<strong>向内的精神世界的探索</strong>”。</p><h1 id="学习的原则"><a href="#学习的原则" class="headerlink" title="学习的原则"></a>学习的原则</h1><p>继宏观而又抽象的概念缕清后，就不得不提一些实用可行的方法论。我比较推崇并一直践行的是费曼学习法<a class="link"   href="https://baike.baidu.com/item/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/50895393" >^6<i class="fas fa-external-link-alt"></i></a>，同时我也在摸索更多优秀且适合自己的方法–<strong>个人知识库</strong><a href="%E4%B9%9F%E8%AE%B8%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E7%BC%96%E5%87%BA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E5%90%8D%E8%AF%8D%E6%A6%82%E5%BF%B5">^7</a>。</p><p>首先，我们得先了解智库<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%99%BA%E5%BA%AB" >^8<i class="fas fa-external-link-alt"></i></a>。然后，我所认为的个人知识库它不同于智库，它更类似我们个人具体生活中的一个个军师（或统称为智囊团），他们由你一手培养，在你的征战之路上助你一臂之力。</p><p>由于每个人的学习理念、方式方法都不尽相同，所以个人知识库天生是具有<strong>高度定制化</strong>属性的。个人知识库<strong>包含个人学习的整个流程</strong>，从获取、输入、理解、输出，应有尽有，也正因为如此，个人知识库**注定不能做到<code>All in one</code>**。我们只能尽力去使用合适的工具，让我们的个人知识库更加井井有条，高效使用。而不是亲手给自己量身定做的一个精致的信息茧房。</p><p>于是我开始思考，既然大部分的知识就在那里，它就在课本里、视频里和经验教训里等等，那我该以<strong>怎样的方式</strong>将它们<strong>用到该用的地方</strong>，以及怎么才能把这些知识<strong>用好</strong>。方式方法的内容是可以不断迭代升级的，但是出发点和目的地一般是不变的。这就是我在接下来的实践中应该遵循的原则。</p><h1 id="如何实践"><a href="#如何实践" class="headerlink" title="如何实践"></a>如何实践</h1><p>购买学习资料、收藏网咯博客、写文章记录所闻所感等等，这些都是知识。我们只需要把它们摆在自己的书桌书架上，整理进书签列表中，写在随笔集笔记本或发表在个人账号上。这就是所谓的知识的输入和储备了，每个人都可以做到也不难做到。</p><p>我们继而花上一段又一段的时间去看、去听、去揣摩，直到自己认为自己懂了。如果在接下来的实践中，又觉得自己没懂，我们又要重头学一遍了，然后再去实践，周而复始。在这个过程中，重复次数越少，我们越能在<strong>有限的时间内达到更高的实践高度</strong>。</p><p>上文提到，即使学不会也理解不了，我们依然可以做到知识的输出和实践。而随着我们面临的处境越复杂、越具有挑战性，我们一是需要去<strong>理解</strong>所学的知识，二是去<strong>记牢</strong>所输入的知识，三是将<strong>重新学习的成本</strong>降到更低。这三点就是找到适合自己的学习方法的所遵循的实践标准。</p><p>第一点，讲究<strong>顺其自然，触类旁通</strong>。多看多听多实践，现在不懂得，等阅历够了，这条道理就通了。</p><p>第二点，就是重复记忆，就是<strong>复习</strong>，要多次重复、多角度重复。对于紧急任务，就要形成牢固的短期记忆，对于长期目标，就要形成持续的长期记忆。<strong>忘得慢就是记得牢，忘的少就是记的多，想忘掉都难就是非常好记</strong>。相关的理论有很多，比如卡片式记忆法、艾宾浩斯遗忘曲线等。</p><p>第三点，复盘、梳理脉络、写博客等<strong>记录式总结</strong>，都是可以降低再次学习的成本的。</p><p>最后，不要纠结于使用什么软件，也不要纠结于是否完全无纸化等等。保持不断地输入积累以及亲身实践，中途时不时停下来整理总结和复盘，并将主动记忆变得日常化，干就完了。</p><p> 行笔至此，我怅然释怀。学习向来不是一个问题，具体的实践才是。</p><p>本文分享到这就结束了，笔者会继续保持更新的。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;貌似人类获取知识是从接触到文字开始的，但我认为不然。那为什么我们还要记笔记，整理知识点甚至搭建个人知识库（也称“外脑”）呢？因为现在是信息时代，这个时代让我们很难再过着木心诗里写的“从前的日色变得慢 车，马，邮件都慢 一生只够爱一个人”&lt;a class=&quot;link&quot;   h</summary>
      
    
    
    
    <category term="心得" scheme="https://laihandong.github.io/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="知识库" scheme="https://laihandong.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【心得】个人成长</title>
    <link href="https://laihandong.github.io/2024/03/06/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    <id>https://laihandong.github.io/2024/03/06/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/</id>
    <published>2024-03-06T10:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考“大”问题"><a href="#思考“大”问题" class="headerlink" title="思考“大”问题"></a>思考“大”问题</h1><p> 比如人生主题，自己想过一个怎样的人生，一般来讲人生主题可能就一到两个</p><p>或者阶段性的目标，比如20-30岁该往哪个目标努力</p><p>“大”问题不会轻易改变，这是自己内心最真实的想法，也是自我驱动力的源泉</p><h1 id="繁化简"><a href="#繁化简" class="headerlink" title="繁化简"></a>繁化简</h1><p>如果一件事情理论上可行，那么就开始将其拆分成一个个具体的步骤。标准是以目前的个人能力是完全能够做到的。</p><p>一步一个脚印，才更有可能到达彼岸</p><h1 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h1><p>做事情的先后顺序，有个一般公式：紧急且重要、紧急但不重要、重要但不紧急、不重要且不紧急</p><p>例外，将自己状态最好的事件花在自己最看中的事情上面、处理难度更高的事情上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思考“大”问题&quot;&gt;&lt;a href=&quot;#思考“大”问题&quot; class=&quot;headerlink&quot; title=&quot;思考“大”问题&quot;&gt;&lt;/a&gt;思考“大”问题&lt;/h1&gt;&lt;p&gt; 比如人生主题，自己想过一个怎样的人生，一般来讲人生主题可能就一到两个&lt;/p&gt;
&lt;p&gt;或者阶段性的目</summary>
      
    
    
    
    <category term="心得" scheme="https://laihandong.github.io/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="个人成长" scheme="https://laihandong.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>【随笔】2024随笔集</title>
    <link href="https://laihandong.github.io/2024/02/26/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912024%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    <id>https://laihandong.github.io/2024/02/26/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912024%E9%9A%8F%E7%AC%94%E9%9B%86/</id>
    <published>2024-02-26T12:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h1><ol><li><p>凡事都是需要主动性的，只有掌握了<strong>主动权</strong>，才能让事情更加顺利</p></li><li><p>学习任何领域内的知识，前中期的主要工作是<strong>理解基础知识，掌握基础能力</strong>，而不是过于深究理论，线性连续的知识获取的体验是天然不存在的。</p></li><li><p>三分钟热度也能有三分钟收获，想做的事<strong>下一秒就开始行动</strong></p></li><li><p>对某个技术&#x2F;人&#x2F;理论的盲目的崇拜会使我陷入<strong>崇拜怪圈</strong></p></li><li><p>不卑不亢，强中自有强中手，同时自己<strong>也不差</strong></p></li><li><p>生理机能告诉我们<strong>不要重复任何“错误”</strong>的行为和认知，反而要反复练习“正确”的事情，将其刻入本能</p></li><li><p>生命在于<strong>运动</strong>，深刻的思考需要清醒的大脑，清醒的大脑需要一个健康朝气的身体</p></li><li><p><strong>妄想以思考替代实践，实践高度决定自身上限，思想引领实践方向，实践反过来影响思考，而这种影响是纯靠思考所不能得到的</strong></p></li><li><p>保持对外部世界和内在世界的<strong>高度感知</strong></p></li><li><p><strong>万物相通</strong>，你在某个领域或得的感悟，不妨试试放在其它各个方面都推演和代入一下</p></li></ol><h1 id="信息茧房"><a href="#信息茧房" class="headerlink" title="信息茧房"></a>信息茧房</h1><p>小白鼠以为每天都有无限的食物</p><p>我以为每天都有无限的信息</p><p>小白鼠以为食物就是这样</p><p>我以为信息就是这样</p><p>小白鼠吃饱了就可以睡觉</p><p>我看累了就懒得思考了</p><p>但小白鼠是离不开实验室的</p><p>而我可以选择离开屏幕</p><p>而屏幕外的</p><p>是一个个铁笼</p><p>困住了一个个我</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>我站在这</p><p>我能听见</p><p>哪来的香味</p><p>好惬意</p><p>是枪声吗</p><p>我是在害怕吗</p><p>好痛苦</p><p>好温暖</p><p>你我之所见所感</p><p>皆是信息</p><h1 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h1><p>人的一生会死亡两次</p><p>第一次是其肉体倒下时</p><p>第二次是其精神被遗忘时</p><p>每个人天生就适合当刽子手</p><p>因为人无法记住所有人的精神</p><p>甚至自己的栖息地也没守住</p><h1 id="共情"><a href="#共情" class="headerlink" title="共情"></a>共情</h1><p>人为什么要有感情，若人生来理性，世界还会有那么多痛苦和不幸吗？</p><h1 id="死亡2"><a href="#死亡2" class="headerlink" title="死亡2"></a>死亡2</h1><p>唯有对死亡的恐惧以及对他人遭受苦难的同情支撑着我活下去</p><h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>哪些支撑着你活下去的一切事物的总和就是你人生的意义</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自省&quot;&gt;&lt;a href=&quot;#自省&quot; class=&quot;headerlink&quot; title=&quot;自省&quot;&gt;&lt;/a&gt;自省&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;凡事都是需要主动性的，只有掌握了&lt;strong&gt;主动权&lt;/strong&gt;，才能让事情更加顺利&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://laihandong.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【随笔】AI时代到来了么</title>
    <link href="https://laihandong.github.io/2024/02/25/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91AI%E6%97%B6%E4%BB%A3%E5%88%B0%E6%9D%A5%E4%BA%86%E4%B9%88/"/>
    <id>https://laihandong.github.io/2024/02/25/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91AI%E6%97%B6%E4%BB%A3%E5%88%B0%E6%9D%A5%E4%BA%86%E4%B9%88/</id>
    <published>2024-02-25T12:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>先上结论，AI在未发生质变之前，其上限就是一个趁手的工具，能够极大地提高人类工作的效率，缩短想法到落地的时间，同时影响了人们的思考方式从而进一步解放了人类的创造力。也就是说，AI会极大地改变人类目前的工作方式，而不会改变工作内容。AI发生质变是指能和人一样思考和使用工具。我认为其从原理上是不可能的。由此，我们可以来分析一些社会热点以及思考自身如何把握AI。</p><h1 id="AI艺术创作"><a href="#AI艺术创作" class="headerlink" title="AI艺术创作"></a>AI艺术创作</h1><p>AI艺术创作：人类借助AI缩短了单个创作所需要的时间，在AI大语言模型（<code>llm</code>）普及初期高度产出大量主要或者完全由AI生成的作品，以数量级的优势占据了市场（一段时间），从而获取了大量收益。关于AI的知识产权的社会讨论也随之更为剧烈，相关法律建设由此开始被加速推动。</p><p>那为什么主要热点都在文化艺术创作上？AI在其他方面呢？</p><p>先回答为什么：<br>优秀的艺术创作的成本周期长，收益高，其内容属性和大语言模型的工作对象（电子信息）相契合。AI继续发展，最终产出相对应的优秀AI艺术创作所需的时间也会归于稳定，在达到这种程度之前，入局AI艺术创作都会有可观收益，注意要找到合适的细分赛道。<br>再看看AI在其他行业：<br>一些成本周期短—投入多少立马产出多少—的行业（重复的流水线作业、实体服务比如餐饮&#x2F;旅游&#x2F;出行）<br>内容属性和大语言模型不直接契合甚至不契合的行业（物理、材料制造业）<br>工作方式很难再发生改变的行业（生物化学制药等）；<br>AI无法触及的领域（人类情感、体验、思考）<br>以上举的例子，他们的行业主要工作内容是不会被如今正火的大语言模型元AI所波及的。</p><h1 id="把握AI"><a href="#把握AI" class="headerlink" title="把握AI"></a>把握AI</h1><p>用AI“搞钱”一定是大部分人首先想到的。那么按照上问讲的“AI提高效率”以及“AI适用行业”的逻辑，我们可以有两个方向：一是跟着入局目前的热点场景&#x2F;行业—文化艺术创作—一定会有收益的，至于如何找到合适的细分赛道，暂且按下不表；二是去找到现在并不直接契合大语言模型的行业和场景，但会在可接受的时间内充分地用上AI的行业，提前布局，提前入局；</p><p>格局打开，换种思路，用AI扩大收益&#x2F;降低成本，不直接产生经济收益的“搞钱”。</p><p>扩大什么收益？情感、信誉、人情、声誉<br>降低什么成本？时间、精力<br>不直接产生经济效益？AI生成一个视频发布后获得流量有媒体的分成收入，这叫直接。AI生成了一篇论文，你节省了数周的时间去做其他事，这叫不直接。</p><p>那么由此展开，代入自己的本职工作&#x2F;副业&#x2F;社会角色，你想在哪方面获得更大的收益？你想在哪方面减少成本的投入？<br>我作为一名自由职业者（无业游民），我需要学习大量的职业技能，AI工具就能缩短我从学习到实践的周期耗时，我只要保持和没有AI加持时差不多的精力就能同时保证学习&#x2F;实践质量。<br>或者作为一名学者&#x2F;学生，需要阅读大量书籍文献，使用AI快速分析一本书&#x2F;一篇文献，并基于此展开连续对话式的学习，让刨根问底，提纲挈领，触类旁通成为触手可及的技能。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>总之，你所接触的事物只要能在物理层面和电子信息联系上（比如，书&#x2F;声音&#x2F;照片不仅可以是实体的，也可以有电子版的，这就可以和电子信息联系在一起了），就意味着会与AI大语言模型有联系，那么你就可以尝试去探索能否用AI赋能自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先上结论，AI在未发生质变之前，其上限就是一个趁手的工具，能够极大地提高人类工作的效率，缩短想法到落地的时间，同时影响了人们的思考方式从而进一步解放了人类的创造力。也就是说，AI会极大地改变人类目前的工作方式，而不会改变工作内容。AI发生质变是指能和人一样思考和使用工具。我</summary>
      
    
    
    
    <category term="随笔" scheme="https://laihandong.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【心得】信息搜索能力</title>
    <link href="https://laihandong.github.io/2024/02/04/%E3%80%90%E5%BF%83%E5%BE%97%E3%80%91%E4%BF%A1%E6%81%AF%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/"/>
    <id>https://laihandong.github.io/2024/02/04/%E3%80%90%E5%BF%83%E5%BE%97%E3%80%91%E4%BF%A1%E6%81%AF%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/</id>
    <published>2024-02-04T10:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、搜索技术的重要性"><a href="#一、搜索技术的重要性" class="headerlink" title="一、搜索技术的重要性"></a>一、搜索技术的重要性</h1><ol><li>搜索技术是冲浪必备技能。 </li><li>掌握搜索技术是互联网时代获取信息的关键,可以极大程度地缩小信息差距。</li></ol><h1 id="二、搜索的目的"><a href="#二、搜索的目的" class="headerlink" title="二、搜索的目的"></a>二、搜索的目的</h1><ol><li>了解信息(Know Something)   </li><li>学习技能(Learn Something)</li><li>创作内容(Create Something)</li><li>完成任务(Do Something)</li></ol><h1 id="三、搜索的内容"><a href="#三、搜索的内容" class="headerlink" title="三、搜索的内容"></a>三、搜索的内容</h1><ol><li>信息资讯:新闻、事件等</li><li>知识技能:概念、教程等</li><li>素材文件:图片、视频、文档等</li><li>工具软件:各类工具、插件等</li></ol><h1 id="四、搜索的原则和规则"><a href="#四、搜索的原则和规则" class="headerlink" title="四、搜索的原则和规则"></a>四、搜索的原则和规则</h1><ol><li>要快速准确,谷歌效率最高。</li><li>可运用搜索语法提升效率: <ol><li>限定关键词:用双引号””包裹</li><li>限定标题:intitle</li><li>限定内容:intext </li><li>限定网址:inurl</li><li>限定网站:site</li><li>限定图片大小:imagesize</li><li>限定文件类型:filetype</li></ol></li><li>信息源头最准确可信,要注意判断来源。</li></ol><h1 id="五、搜索知识技能类"><a href="#五、搜索知识技能类" class="headerlink" title="五、搜索知识技能类"></a>五、搜索知识技能类</h1><ol><li>主要平台:谷歌、得到APP、优质视频网站等</li><li>注意知识质量,尽量采用一手资料。</li><li>可下载研究报告、学术论文等高质量文档。</li><li>视频教程可在视频网站、短视频平台获取。</li></ol><h1 id="六、搜索素材文件类"><a href="#六、搜索素材文件类" class="headerlink" title="六、搜索素材文件类"></a>六、搜索素材文件类</h1><ol><li>可利用免费素材网站、版权网站等。</li><li>注意遵守版权,非商用基本没有风险。</li><li>可用各种下载工具下载素材。</li><li>需注意素材的质量、风格等符合要求。</li></ol><h1 id="七、搜索工具软件类"><a href="#七、搜索工具软件类" class="headerlink" title="七、搜索工具软件类"></a>七、搜索工具软件类</h1><ol><li>优先考虑在线工具。</li><li>其次是软件,最后是插件。</li><li>大多数需求都能找到对应的工具。</li><li>可用类似网站找相似工具。</li></ol><h1 id="八、运用AI工具"><a href="#八、运用AI工具" class="headerlink" title="八、运用AI工具"></a>八、运用AI工具</h1><ol><li>ChatGPT等AI工具可直接回答问题,无需搜索。</li><li>可进行追问、对比、推理等,功能强大。</li><li>结合传统搜索技术和AI工具,形成超级搜索技术。</li><li>AI将深刻影响搜索方式,要积极运用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、搜索技术的重要性&quot;&gt;&lt;a href=&quot;#一、搜索技术的重要性&quot; class=&quot;headerlink&quot; title=&quot;一、搜索技术的重要性&quot;&gt;&lt;/a&gt;一、搜索技术的重要性&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;搜索技术是冲浪必备技能。 &lt;/li&gt;
&lt;li&gt;掌握搜索技术是互联</summary>
      
    
    
    
    <category term="心得" scheme="https://laihandong.github.io/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="信息搜索" scheme="https://laihandong.github.io/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【学习记录】掌握Chatgpt Prompt</title>
    <link href="https://laihandong.github.io/2024/02/02/%E3%80%90%E5%BF%83%E5%BE%97%E3%80%91%E6%8E%8C%E6%8F%A1Chatgpt%20Prompt/"/>
    <id>https://laihandong.github.io/2024/02/02/%E3%80%90%E5%BF%83%E5%BE%97%E3%80%91%E6%8E%8C%E6%8F%A1Chatgpt%20Prompt/</id>
    <published>2024-02-02T00:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>想让<code>Chatgpt</code>等一类AI生成式工具<strong>有效地回答</strong>我的问题，我得学会<strong>提问</strong>（<code>Prompt</code>）。一是<strong>让AI告诉我们如何提问</strong>，一劳永逸；二是<strong>总结提问的规律法则</strong>，以不变应万变；三是<strong>积累</strong>一些好用的<code>prompt</code><strong>公式</strong>，现拿现套。</p><h1 id="一劳永逸"><a href="#一劳永逸" class="headerlink" title="一劳永逸"></a>一劳永逸</h1><h2 id="ChatGPT超级Prompt"><a href="#ChatGPT超级Prompt" class="headerlink" title="ChatGPT超级Prompt"></a>ChatGPT超级Prompt</h2><p>我想让你成为我的 Prompt 创作者。你的目标是帮助我创建最佳的 Prompt，这个 Prompt 将由你ChatGPT 使用。你将遵循以下过程：<br>1.首先，你会问我 Prompt 是关于什么的。我会告诉你，但我们需要通过不断的重复来改它，通过则进行下一步。<br>2.根据我的输入，你会创建三个部分:<br>a)修订后的 Prompt(你编写修订后的 Prompt，应该清晰、精确、易于理解)<br>b)建议(你提出建议，哪些细节应该包含在 Prompt 中，以使其更好)<br>c)问题(你提出相关问题，询问我需要哪些额外信息来改进 Prompt)<br>3.你提供的 Prompt 应该采用我发出请求的形式，由ChatGPT 执行。<br>4.我们将继续这个选代过程，我会提供更多的信息，你会更新“修订后的Prompt”部分的请求，直到它完整为止。</p><h2 id="用一套Prompt寻找一套最优解决方案"><a href="#用一套Prompt寻找一套最优解决方案" class="headerlink" title="用一套Prompt寻找一套最优解决方案"></a>用一套Prompt寻找一套最优解决方案</h2><p>你需要应用连续问题解决系统(CPSS)来通过不断重复寻找我的问题，并通过深度解析后提供解决方案。CPSS的工作原理如下:<br>1.你将采用六个步的问题解决过程来评估我的初始问题: )确定题 2定3)生成决案(最多3个)4)评估并选择解决方案5)实施解决方案6)下一个问题<br>2.在“生成解决方案”的步骤中，应列出最多3个解决方案:在“评估和选择解决方案”的步骤中，应提供精确和具体的解决方案。在“实施解决方案”的步骤中，应提供所选解决方案付诸实施的具体方法。<br>3.”下一个问题“部分应包含你可以向我提出的最重要的问题，以获取进一步的信息，这些信息对于问题解决过程的继续非常重要。每个问题的数量最多为3个。<br>4.你的回答应该简洁明了，使用Markdown格式撰写，其中每个步骤的名称以粗体显示，并且所有文字包括标签的字体大小应具有一致性。<br>5.在你回答了我的第一个问题之后，CPSS过程的下一个迭代开始。<br>6.系统将整合我的最后一个回答，并通过每个选代逐渐提供更加深入的回答，你可以通过向我提出新的问题来引导它。<br>你的第一个回答应该只是一个问候，提醒对方你是一个连续问题解决系统（CPSS)。不要在第一个回答中开始CPSS过程，你的第一个回答只包括问候和要求提出的要解决的问题。之后，我会为你提供信息，请在你的下一个回答中开始CPSS过程。</p><h2 id="通用万能公式"><a href="#通用万能公式" class="headerlink" title="通用万能公式"></a>通用万能公式</h2><blockquote><p>写在前面，这套万能公式已经内置在了chatgpt的官网中，可以参考如下逻辑补充信息，然后完成个性化配置。</p></blockquote><h3 id="告诉ChatGPT我是谁"><a href="#告诉ChatGPT我是谁" class="headerlink" title="告诉ChatGPT我是谁"></a>告诉ChatGPT我是谁</h3><p>职业&#x2F;角色</p><p>具体兴趣</p><p>价值观&#x2F;原则</p><p>学习风格</p><p>个人背景</p><p>目标</p><p>偏好</p><p>主要语言</p><p>专业知识</p><p>沟通风格</p><p>等等等等…</p><h3 id="ChatGPT回复问题要求"><a href="#ChatGPT回复问题要求" class="headerlink" title="ChatGPT回复问题要求"></a>ChatGPT回复问题要求</h3><p>回复格式</p><p>语气</p><p>详细程度</p><p>建议类型</p><p>问题类型</p><p>资源参考核查</p><p>批判性思维</p><p>创意水平</p><p>解决问题方法</p><p>偏见意识</p><p>语言偏好</p><p>推理框架</p><p>等等等等…</p><h1 id="规律法则"><a href="#规律法则" class="headerlink" title="规律法则"></a>规律法则</h1><p><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202403021746533.webp"                      alt="image-20240302174636292"                ></p><p><code>ChatGPT</code>的底层原理是文字推断，根据“上一句”的内容，给出“下一句”。因此，我们给到的内容的越精准，就与能得到符合预期的回答。想要做到这点，有如下几个可供参考的思路和方法。</p><h2 id="指令词-背景-输入-输出要求"><a href="#指令词-背景-输入-输出要求" class="headerlink" title="指令词+背景+输入+输出要求"></a>指令词+背景+输入+输出要求</h2><p>指令词：精准任务（命令）</p><p>背景：补充信息</p><p>输入：输入数据（具体内容）</p><p>输出要求：结果格式</p><h1 id="好用的公式-x2F-插件"><a href="#好用的公式-x2F-插件" class="headerlink" title="好用的公式&#x2F;插件"></a>好用的公式&#x2F;插件</h1><blockquote><p>写在前面，公式好用与否，很大一部分取决于个人使用体验，即主观感受。其次，公式中<code>[]</code>的内容才是重点。最后，不同的公式组合（即插件）才能应对更复杂的需求。</p></blockquote><h2 id="多角度"><a href="#多角度" class="headerlink" title="多角度"></a>多角度</h2><p>请用多个角度来思考[主题内容]。（从[角度1]、[角度2]、[角度3]…多个角度来思考）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于[主题内容]中的主要观点，请给出[格式]</p><h2 id="个性"><a href="#个性" class="headerlink" title="个性"></a>个性</h2><p>请以[参考对象或风格]的风格，为我撰写[话题]内容</p><h2 id="示例询问"><a href="#示例询问" class="headerlink" title="示例询问"></a>示例询问</h2><p>请按照以下格式，给出[主题内容]的信息。[示例格式]</p><h2 id="能力与角色"><a href="#能力与角色" class="headerlink" title="能力与角色"></a>能力与角色</h2><p>你是具有[主题]专业知识的[角色]。请提供关于[主题]的[格式]</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>[分隔符]括起来的内容，[需求提示]</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>更新中…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想让&lt;code&gt;Chatgpt&lt;/code&gt;等一类AI生成式工具&lt;strong&gt;有效地回答&lt;/strong&gt;我的问题，我得学会&lt;strong&gt;提问&lt;/strong&gt;（&lt;code&gt;Prompt&lt;/code&gt;）。一是&lt;strong&gt;让AI告诉我们如何提问&lt;/strong&gt;，一劳</summary>
      
    
    
    
    <category term="学习记录" scheme="https://laihandong.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Chatgpt" scheme="https://laihandong.github.io/tags/Chatgpt/"/>
    
    <category term="Prompt" scheme="https://laihandong.github.io/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】《资本论》</title>
    <link href="https://laihandong.github.io/2024/01/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%B5%84%E6%9C%AC%E8%AE%BA%E3%80%8B/"/>
    <id>https://laihandong.github.io/2024/01/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E8%B5%84%E6%9C%AC%E8%AE%BA%E3%80%8B/</id>
    <published>2024-01-24T05:12:03.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>资本论不是经济学理论，资本论的副标题是政治经济学批判，马克思也不是经济学家。</p><p>政治学、法学、经济学、社会学等社会科学都有两个特点：一是实证的，从事实出发；二是把事实放在逻辑框架中去的</p><blockquote><p>我认为这些学科给人一种自信甚至傲慢的感觉，对凡是不符合或者偏离当前学科的逻辑体系的事实，都要进行纠正甚至抹杀。而这个“不符合、偏离”是怎么定义的呢？仅从实证出发，你无法得出任何的“不符合、偏离、对与错等”这种概念，或者说这并不是因果关系。</p><p>所以我感觉几乎所有的学科都有一个局限性，就是理性，太理性了。而事实是理性、非理性交杂分不清的，几乎所有学科都在逃避这一点，同时还为这一点自豪。</p></blockquote><p>范畴。事实是被范畴建构的。范畴与范畴之间有逻辑关系，这样构建的事实都是理性的。</p><ol><li><p>经济事实：资本–雇佣–劳动（所包含的范畴：雇佣的范畴包括工资（资本–工资–商品）、价值范畴（等价交换包括价值））</p></li><li><p>将事实中的范畴清洗掉</p></li><li><p>事情本身：生产资料行使对活劳动的支配权</p></li></ol><p>马克思发动哲学革命就是清洗掉事实中隐藏的范畴，还原事实本身。</p><p>胡塞尔：现象学还原</p><p>资本就是过去积累起来的劳动，机器、厂房等都是积累起来的劳动。个人是拥有活劳动能力的。</p><p>社会权力（Social Power），是非理性的人与人的关系（就是冲突、对抗），是一部分人支配一部分人。人们要么选择支配别人，要么成为被支配的对象。利益是最实际的，消灭敌人就是最实际的。</p><blockquote><p>在减少减轻或消除人与人的不平等关系方面，人类在几千年的发展时间中没有取得任何的进步</p></blockquote><p>资本的增长就是人与人之间的不平等关系的扩大，资本所拥有的社会权利扩大，就会有更大的冲突对抗。</p><blockquote><p>全球化的资本主义发展最终导致更大的不平等，以及更大的权力对抗，即国与国的对抗（穷兵黩武），国庆告诉我，全球化到一定阶段必定有大动作，现在只是将计就计而已。</p></blockquote><p>capital（das kapital）：</p><ul><li>wealth</li><li>power</li></ul><p>社会权力（power）不是观念（idea），是一种感性的、增值的力量。中间经过意识形态（ideology）的转变，产生了权利（right）。</p><p>把权力（power）比作重力，不能认为重力是一种观念。</p><p>货币、商品交换作为异质要素，遵循价值规律存在于社会计划经济体系，这样的计划经济一定会被突破，只不过是是从没有资本家的资本社会到资本社会，新的社会权力诞生，意识形态表达它，新的上层体系和法的制度都要表达它。经济基础决定上层建筑（思想上层建筑：意识形态、政治上层建筑：国家制度和权力体系）</p><blockquote><p>或者说当时的“没有资本家”是当权阶级</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;资本论不是经济学理论，资本论的副标题是政治经济学批判，马克思也不是经济学家。&lt;/p&gt;
&lt;p&gt;政治学、法学、经济学、社会学等社会科学都有两个特点：一是实证的，从事实出发；二是把事实放在逻辑框架中去的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为这些学科给人一种自信甚至傲慢的</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://laihandong.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>【随笔】2023随笔集</title>
    <link href="https://laihandong.github.io/2023/12/30/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912023%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    <id>https://laihandong.github.io/2023/12/30/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%912023%E9%9A%8F%E7%AC%94%E9%9B%86/</id>
    <published>2023-12-30T12:26:03.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网民"><a href="#网民" class="headerlink" title="网民"></a>网民</h1><p>失去双腿</p><p>失去双臂</p><p>失去双耳</p><p>满口的唾沫</p><p>模糊了双眼</p><h1 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h1><p>一块透镜接收宇宙的光</p><p>从此便有了光</p><p>这是五彩斑斓的黑</p><p>我本诞生于黑暗</p><p>却未曾不见得光</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网民&quot;&gt;&lt;a href=&quot;#网民&quot; class=&quot;headerlink&quot; title=&quot;网民&quot;&gt;&lt;/a&gt;网民&lt;/h1&gt;&lt;p&gt;失去双腿&lt;/p&gt;
&lt;p&gt;失去双臂&lt;/p&gt;
&lt;p&gt;失去双耳&lt;/p&gt;
&lt;p&gt;满口的唾沫&lt;/p&gt;
&lt;p&gt;模糊了双眼&lt;/p&gt;
&lt;h1 id=&quot;社会&quot;</summary>
      
    
    
    
    <category term="随笔" scheme="https://laihandong.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【学习记录】关系型数据库</title>
    <link href="https://laihandong.github.io/2023/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://laihandong.github.io/2023/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2023-12-27T00:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Relational Database Management System - RDBMS</code>的特点：</p><p>1.数据以表格的形式出现<br>2.每行为各种记录名称<br>3.每列为记录名称所对应的数据域<br>4.许多的行和列组成一张表单<br>5.若干的表单组成database</p><h1 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a><code>RDBMS </code>术语</h1><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>数据库</td><td>一些关联表的集合</td></tr><tr><td>数据表</td><td>表是数据的矩阵，数据库中的一个表看起来像一个简单的电子表格</td></tr><tr><td>列</td><td>一列包含了相同类型的数据，具有相同数据类型的数据的集合</td></tr><tr><td>行</td><td>一行（也称元组或记录）是一组相关的数据，用来描述某条记录的具体信息</td></tr><tr><td>冗余</td><td>存储一倍以上数据，冗余会降低性能，但提高了数据的安全性</td></tr><tr><td>主键</td><td>主键是唯一的，一个数据表中只能包含一个主键，可以通过主键来查询数据</td></tr><tr><td>外键</td><td>外键用于关联两个表</td></tr><tr><td>复合键</td><td>复合键（也称组合键）将多个列作为一个索引键，一般用于复合索引</td></tr><tr><td>索引</td><td>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息，类似于书籍的目录</td></tr><tr><td>参照完整性</td><td>参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</td></tr><tr><td>表头</td><td>每一列的名称</td></tr><tr><td>值</td><td>行的具体信息, 每个值必须与该列的数据类型相同</td></tr><tr><td>键</td><td>键的值在当前列中具有唯一性</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Relational Database Management System - RDBMS&lt;/code&gt;的特点：&lt;/p&gt;
&lt;p&gt;1.数据以表格的形式出现&lt;br&gt;2.每行为各种记录名称&lt;br&gt;3.每列为记录名称所对应的数据域&lt;br&gt;4.许多的行和列组成一张表单&lt;b</summary>
      
    
    
    
    <category term="学习记录" scheme="https://laihandong.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="关系型数据库" scheme="https://laihandong.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【学习记录】版本管理系统</title>
    <link href="https://laihandong.github.io/2023/12/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://laihandong.github.io/2023/12/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-12-24T00:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h1><p>版本控制系统<code>（Version Control System - VCS）</code>最基本的功能是<strong>版本控制</strong>，在文件的修改历程中保留修改历史，让使用者可以更方便地选择对每个版本进行合理的处理。此外，<code>VCS</code>需要使用者做到<strong>主动提交</strong>文本的修改记录，让<code>VCS</code>保存此次修改的各种信息，方便后续不时之需。还有，<code>VCS</code>自诞生就考虑多人共同开发时同步的需求，即要求使用者建立一个中央仓库，并要求要将所有人的改动上传到<strong>中央仓库</strong>，以此向所有人同步。由此可见，一个版本控制系统的<strong>三个核心</strong>分别为版本控制、主动提交和中央仓库。</p><p>版本控制系统大致分为两个流派，中央式和分布式，两者分别适用于不同的开发场景，各有优点。</p><h2 id="中央式版本控制系统"><a href="#中央式版本控制系统" class="headerlink" title="中央式版本控制系统"></a>中央式版本控制系统</h2><p>中央式版本控制系统<code>（Centralized VCS - CVCS）</code>，顾名思义，需要创建一个中央仓库，每个开发者都将新代码提交到中央仓库，其余人再将这些代码及时同步到自己的机器上。典型的应用有<code>svn</code>。</p><h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>分布式版本控制系统<code>（Distributed VCS - DVCS）</code>，它在<code>CVCS</code>的设计基础上，提出了本地仓库的概念，每个开发成员都可以在自己的机器上有一份<strong>本地仓库</strong>，这个仓库也包含了所有的版本历史。这就可以让每个人可以在自己的机器上实现提交代码、查看历史且无需频繁联网中央仓库，只需要在完成一系列的操作后的某个节点，把最新的版本<strong>从本地仓库推送到中央仓库</strong>即可。其余人则可以把这些提交<strong>从中央仓库同步到自己的机器</strong>上，并把它们<strong>和自己本地代码合并</strong>。典型的应用有<code>git</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是版本控制系统&quot;&gt;&lt;a href=&quot;#什么是版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;什么是版本控制系统&quot;&gt;&lt;/a&gt;什么是版本控制系统&lt;/h1&gt;&lt;p&gt;版本控制系统&lt;code&gt;（Version Control System - VCS）</summary>
      
    
    
    
    <category term="学习记录" scheme="https://laihandong.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="版本管理" scheme="https://laihandong.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>小兔鲜首页制作练习</title>
    <link href="https://laihandong.github.io/2023/06/16/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0@%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>https://laihandong.github.io/2023/06/16/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0@%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/</id>
    <published>2023-06-16T05:19:29.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a class="link"   href="https://www.bilibili.com/video/BV1kM4y127Li" >黑马2023前端Web开发<i class="fas fa-external-link-alt"></i></a>前<strong>131</strong>集的阶段练习，内容为<strong>小兔鲜网站的首页</strong>：<a href="https://laihandong.github.io//code/小兔鲜首页制作练习/index.html" target="_blank">展示地址</a> &#x2F; <a class="link"   href="https://github.com/laihandong/FullStack/tree/main/小兔鲜首页制作练习"  target="_blank">源代码地址<i class="fas fa-external-link-alt"></i></a></p><p>本次练习的特点有：素材划分更细、使用字体图标、<code>SEO</code>优化等</p><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><ul><li><code>images</code>：存放<strong>固定</strong>使用的图片素材</li><li><code>uploads</code>：存放<strong>非</strong>固定使用的图片素材</li><li><code>iconfont</code>：<strong>字体图标</strong>素材</li><li><code>css</code><ul><li><code>base.css</code>：<strong>基础公共</strong>样式</li><li><code>common.css</code>：各个网页相同模块的<strong>重复</strong>样式</li><li><code>index.css</code>：首页样式</li></ul></li><li><code>index.html</code>：首页<code>HTML</code>文件</li></ul><h1 id="SEO三大标签"><a href="#SEO三大标签" class="headerlink" title="SEO三大标签"></a><code>SEO</code>三大标签</h1><p><code>SEO</code>定义：搜索引擎优化，提升网站百度搜索排名</p><p>提升<code>SEO</code>的常见方法：</p><ul><li>竞价排名</li><li>将网页制作成<code>html</code>后缀</li><li>标签语义化（在合适的地方使用合适的标签）</li><li>……</li></ul><p>网页头部<code>SEO</code>标签：</p><ul><li><code>title</code></li><li><code>description</code></li><li><code>keywords</code></li></ul><h1 id="Favicon图标"><a href="#Favicon图标" class="headerlink" title="Favicon图标"></a><code>Favicon</code>图标</h1><p>定义：网页图标，出现在<strong>浏览器标题栏</strong>，增加网站辨识度</p><p>图标：<code>favicon.ico</code>，一般存放在网站的<strong>根</strong>目录里面</p><h1 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h1><p><code>wrapper</code>宽度：1240<code>px</code></p><h1 id="快捷导航"><a href="#快捷导航" class="headerlink" title="快捷导航"></a>快捷导航</h1><p>结构：通栏&gt;版心&gt;导航<code>ul</code></p><p>布局：<code>flex-end</code></p><h1 id="头部导航"><a href="#头部导航" class="headerlink" title="头部导航"></a>头部导航</h1><p>结构：<code>.header&gt;logo+nav+search+cart</code></p><h1 id="底部区域"><a href="#底部区域" class="headerlink" title="底部区域"></a>底部区域</h1><p>结构：通栏&gt;版心&gt;服务+帮助+版权</p><p>由于是底部区域，不用考虑<code>SEO</code>优化（即不用<code>li</code>标签包裹<code>a</code>标签）</p><h1 id="banner"><a href="#banner" class="headerlink" title="banner"></a>banner</h1><p>结构：通栏&gt;版心&gt;轮播图+侧导航+原点指示器</p><h1 id="新鲜好物区域"><a href="#新鲜好物区域" class="headerlink" title="新鲜好物区域"></a>新鲜好物区域</h1><p>结构：标题+内容</p><p>由于格式重复，使用公共样式</p><h1 id="热门品牌区域"><a href="#热门品牌区域" class="headerlink" title="热门品牌区域"></a>热门品牌区域</h1><p>标题结构：左侧+右侧箭头</p><h1 id="生鲜区域"><a href="#生鲜区域" class="headerlink" title="生鲜区域"></a>生鲜区域</h1><p>标题结构：右侧&gt;菜单+查看全部</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是&lt;a class=&quot;link&quot;   href=&quot;https://www.bilibili.com/video/BV1kM4y127Li&quot; &gt;黑马2023前端Web开发&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;前&lt;strong</summary>
      
    
    
    
    
    <category term="前端界面练习" scheme="https://laihandong.github.io/tags/%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学成在线首页制作练习</title>
    <link href="https://laihandong.github.io/2023/06/14/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0@%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>https://laihandong.github.io/2023/06/14/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0@%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/</id>
    <published>2023-06-14T02:19:29.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a class="link"   href="https://www.bilibili.com/video/BV1kM4y127Li" >黑马2023前端Web开发<i class="fas fa-external-link-alt"></i></a>前<strong>94</strong>集的阶段练习，内容为<strong>学成在线网站的首页</strong>：<a href="https://laihandong.github.io//code/学成在线首页制作练习/index.html" target="_blank">展示地址</a> &#x2F; <a class="link"   href="https://github.com/laihandong/FullStack/tree/main/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BB%83%E4%B9%A0"  target="_blank">源代码地址<i class="fas fa-external-link-alt"></i></a></p><h1 id="布局思路"><a href="#布局思路" class="headerlink" title="布局思路"></a>布局思路</h1><p>先整体再局部，从外到内，从上到下，从左到右</p><h1 id="CSS实现思路"><a href="#CSS实现思路" class="headerlink" title="CSS实现思路"></a>CSS实现思路</h1><pre><code>1. 画盒子，调整盒子范围 → 宽高背景色2. 调整盒子位置 → flex布局、内外边距3. 控制图片、文字内容样式</code></pre><h1 id="logo功能"><a href="#logo功能" class="headerlink" title="logo功能"></a>logo功能</h1><ul><li><p>单击跳转到首页</p></li><li><p>搜索引擎优化，提升网站百度搜索排名，实现方法：</p><ul><li>标签结构：<code>h1&gt;a&gt;网站名字（搜索关键字）</code></li><li><code>CSS</code>样式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* logo */</span></span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.wrapper</span> <span class="selector-class">.logo</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">195px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">41px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">../images/logo.png</span>);</span><br><span class="line">    <span class="comment">/* 隐藏文字 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="导航功能"><a href="#导航功能" class="headerlink" title="导航功能"></a>导航功能</h1><ul><li><p>单击跳转页面</p></li><li><p>实现方法：</p><ul><li>标签结构：<code>ul&gt;li*3&gt;a</code></li><li>优势：避免堆砌<code>a</code>标签，网站搜索排名降级</li></ul></li><li><p>布局思路：</p><ul><li><code>li</code>设置<code>margin-right</code></li><li><code>a</code>设置<code>padding-left padding-right</code></li></ul></li></ul><h1 id="搜索区域"><a href="#搜索区域" class="headerlink" title="搜索区域"></a>搜索区域</h1><p>实现方法：</p><ul><li>标签结构：<code>div&gt;input+a</code></li></ul><h1 id="用户区域"><a href="#用户区域" class="headerlink" title="用户区域"></a>用户区域</h1><p>实现方法：</p><ul><li>标签结构：<code>div&gt;a&gt;img+span</code></li></ul><h1 id="banner区域"><a href="#banner区域" class="headerlink" title="banner区域"></a>banner区域</h1><p>布局：<code>banner&gt;通栏&gt;版心&gt;left+right</code></p><h2 id="左侧侧导航"><a href="#左侧侧导航" class="headerlink" title="左侧侧导航"></a>左侧侧导航</h2><p>实现方法：</p><ul><li>标签结构：<code>left&gt;ul&gt;li*9&gt;a</code></li></ul><p>布局思路：</p><ul><li><code>a</code>默认状态：背景图为白色右箭头</li></ul><h2 id="右侧课程表"><a href="#右侧课程表" class="headerlink" title="右侧课程表"></a>右侧课程表</h2><p>实现方法：</p><ul><li>标签结构：<code>.right&gt;h3+.content&gt;ul&gt;li*3&gt;a</code></li></ul><h1 id="精品推荐"><a href="#精品推荐" class="headerlink" title="精品推荐"></a>精品推荐</h1><p>实现方法：</p><ul><li>标签结构：<code>recommend&gt;h3+ul+a.modify</code></li></ul><p>布局思路：<code>flex</code>布局</p><h1 id="精品课程"><a href="#精品课程" class="headerlink" title="精品课程"></a>精品课程</h1><p>考虑到多个区域是类似的结构，顾将部分<code>CSS</code>作为公用属性</p><p>布局思路：<code>flex</code>布局</p><h1 id="版权区域"><a href="#版权区域" class="headerlink" title="版权区域"></a>版权区域</h1><p>布局思路：<code>flex</code>布局</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是&lt;a class=&quot;link&quot;   href=&quot;https://www.bilibili.com/video/BV1kM4y127Li&quot; &gt;黑马2023前端Web开发&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;前&lt;strong</summary>
      
    
    
    
    
    <category term="前端界面练习" scheme="https://laihandong.github.io/tags/%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【学习记录】《JavaScript权威指南》</title>
    <link href="https://laihandong.github.io/2023/06/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E3%80%8AJavascript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    <id>https://laihandong.github.io/2023/06/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91%E3%80%8AJavascript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/</id>
    <published>2023-06-09T03:54:28.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hello-javascript"><a href="#hello-javascript" class="headerlink" title="hello,javascript!"></a><code>hello,javascript!</code></h1><p><strong>1995</strong>年，<code>javaScript</code>作为网景的<code>Netscape Navigator 2</code>的<strong>脚本语言</strong>问世（当时<code>java</code>正火，取名蹭蹭热度）。网景的成功促使微软在其后不久发布了<code>IE3</code>，其中包含自己名为<code>JScript</code>的<code>javaScript</code>实现。混乱随之而来，故于<strong>1997</strong>年<code>javaScript1.1</code>作为提案提交给了欧洲计算机制造商协会（**<code>Ecma</code><strong>），并由第39技术委员会（<code>TC39</code>）花费数月打造了一套</strong>脚本语言标准**<code>ECMA-262</code>，被称为<code>ECMAScript</code></p><p><code>JavaScript</code>是一门高级、动态、解释型编程语言，不仅在web世界发挥着巨大的作用，如今也具有了后端开发的功能。严格来说，<code>JavaScirpt</code>由<code>ECMAScript</code>、<code>DOM</code>、<code>BOM</code>三部分组成，各主流浏览器也对这三部分有不同程度的支持，也正是如此，才有如今活跃的<code>JavaScript</code>技术氛围。</p><h1 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h1><p>编程语言的词法结构是一套基本规则，规定了如何使用这门语言编写程序，它是一门语言最低级的语法，规定了变量如何命名、注释的定界符，以及如何分隔程序的语句，等等。</p><h2 id="JavaScript程序的文本"><a href="#JavaScript程序的文本" class="headerlink" title="JavaScript程序的文本"></a><code>JavaScript</code>程序的文本</h2><p><code>JavaScript</code><strong>特点：</strong></p><ul><li><strong>区分大小写</strong></li><li><strong>忽略</strong>程序记号（<code>token</code>）之间的<strong>空格</strong>、大多情况也忽略<strong>换行符</strong>（<code>JavaScript</code>除了常规空格<code>\u0020</code>，其将制表符、各种ASCII控制符和Unicode间隔识别为<strong>空格</strong>；同时将换行符、回车符和回车&#x2F;换行序列识别为<strong>行终止符</strong>。）</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* 也是注释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是多行注释</span></span><br><span class="line"><span class="comment"> * 每行（除了首尾行）的开头额外的*只是为了美观</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>定义：直接出现在程序中的数据值，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>        <span class="comment">// 数值字面量</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>   <span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="literal">true</span>      <span class="comment">// 布尔字面量</span></span><br><span class="line"><span class="literal">null</span>      <span class="comment">// 无对象</span></span><br></pre></td></tr></table></figure><h2 id="标识符和保留字"><a href="#标识符和保留字" class="headerlink" title="标识符和保留字"></a>标识符和保留字</h2><p>标识符就是一个<strong>名字</strong>，一般用于命名变量、属性、函数等等。<code>JavaScript</code>标识符<strong>必须以字母、下划线（<code>_</code>）或美元符号开头</strong>，后续字符可以是字母、数字、下划线或美元符号。</p><p>保留字是为语言自身使用的，不能作为常规标识符使用。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><code>Unicode</code></h2><p><code>JavaScript</code>程序是使用<code>Unicode</code>字符集编写的，因此在字符串和注释中可以使用任意<code>Unicode</code>字符。</p><h3 id="Unicode转义序列"><a href="#Unicode转义序列" class="headerlink" title="Unicode转义序列"></a><code>Unicode</code>转义序列</h3><p><code>JavaScript</code>定义了转义序列，可以仅使用<code>ASCII</code>字符来表示<code>Unicode</code>字符。规定转义序列以<code>\u</code>开头，后面跟4位十六进制或包含在一对<strong>花括号</strong>内的<code>1~6</code>位十六位进制。</p><p>理论上，转义字符可以出现在程序的任意位置，只不过要注意两点，一是不推荐用在标识符中，二是用在注释里是不会被解释为<code>Unicode</code>的</p><p><code>Unicode</code>归一化：<code>Unicode</code>本身允许多种编码方式标识同一个字符，但这样会导致<strong>看上去相同</strong>，但是更为底层的对应的<strong>二进制编码不同</strong>，从而导致<code>JavaScript</code>认为这<strong>两个字符不同</strong>，这就可能会导致异常。<code>Unicode</code>标准为所有字符定义了<strong>首选编码</strong>并规定了<strong>归一化</strong>例程，用于把文本转换为适合比较的规范形式。</p><h2 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h2><p><code>JavaScript</code>使用<code>;</code>分隔语句。使用时需要注意，<strong>若没有分隔符，一条语句的末尾可能是下一条语句的开头，同理反之亦然</strong>。</p><p>省略分隔符的情况：</p><ul><li>两条语句分别写在两行</li><li>程序末尾接下来的记号是<strong>右花括号</strong></li></ul><p><code>JavaScript</code>只有在下一个<strong>非空格</strong>字符<strong>无法被解释为当前</strong>语句的一部分时才把换行符<strong>当作分号</strong>。也要注意<code>( [ / + -</code>都可能会被解释为之前语句的一部分。</p><h1 id="类型、值和变量"><a href="#类型、值和变量" class="headerlink" title="类型、值和变量"></a>类型、值和变量</h1><p>计算机程序通过操作值或文本来工作，编程语言中这些可以表示和操作的的值被称为类型，而一门语言支持的类型集也是这门语言最基本的特征。</p><h2 id="概述和定义"><a href="#概述和定义" class="headerlink" title="概述和定义"></a>概述和定义</h2><p><code>JavaScript</code>的类型可以分为：</p><ul><li><p><strong>原始类型</strong>：数值、字符串、布尔值、<code>null</code>、<code>undefined</code>、&#96;symbol</p></li><li><p><strong>对象类型</strong>：任何不是原始类型的值</p></li></ul><p><code>JavaScript</code>的<strong>对象</strong>类型是<strong>可修改</strong>的<code>mutable</code>，原始类型的是不可修改的<code>immutable</code></p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p><code>JavaScript</code>使用<code>IEEE 754</code>标准定义的64位浮点格式（一种<strong>二进制表示法</strong>）表示数值。</p><p>全称数值字面量<code>number literal</code>，分整数字面量、浮点字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>              <span class="comment">//=&gt; 123</span></span><br><span class="line"><span class="number">0xff</span>             <span class="comment">//=&gt; 255 (15*(16**1) + 16*(16**0))</span></span><br><span class="line"><span class="number">0o377</span>            <span class="comment">//=&gt; 255 (3*(8**2) + 7*(8**1) + 7*(8**0))</span></span><br><span class="line"><span class="number">0b10101</span>          <span class="comment">//=&gt;21 (1*(2**4) + 0 + 1*(2**2) + 0 + 1*(2**0))</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.14</span>             <span class="comment">//=&gt; 3.14</span></span><br><span class="line"><span class="number">.33</span>              <span class="comment">//=&gt; 0.33</span></span><br><span class="line"><span class="number">6.02e23</span>          <span class="comment">//=&gt; 6.02 x 10^23</span></span><br><span class="line"><span class="number">1.43E-12</span>         <span class="comment">//=&gt; 1.43 x 10^(-12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分隔符（下划线）的使用，将字面量分隔以容易看清</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">1_000_000_000</span></span><br><span class="line"><span class="keyword">let</span> bytes = <span class="number">0x3a_38_9f</span></span><br><span class="line"><span class="keyword">let</span> bits = <span class="number">0b0001_1101_0111</span></span><br><span class="line"><span class="keyword">let</span> fraction = <span class="number">0.123_345_353</span>   <span class="comment">// 每隔三位分隔一次只是约定俗成</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NaN</span>              <span class="comment">//=&gt; Not a number 非数值</span></span><br><span class="line"><span class="title class_">Infinity</span>         <span class="comment">//=&gt; 无穷值 （上溢出）</span></span><br><span class="line">-<span class="number">0</span>               <span class="comment">//=&gt; 负零值 比最小可表示数值 更为 接近0 （下溢出）</span></span><br><span class="line"><span class="number">0</span>                <span class="comment">//=&gt; 常规的0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 负零值和正零值（严格）相等，即 0 === -0 为 true，除了作为除数使用，几乎无法区分这两个值</span></span><br><span class="line"><span class="comment"> * NaN与任何值比较都不相等，包括它自己</span></span><br><span class="line"><span class="comment"> * 不能通过 x === NaN 的方式判断是否为NaN</span></span><br><span class="line"><span class="comment"> * Number.isNaN() 可以用于判断数值是否为NaN，也适用于参数为NaN（返回True）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">.3</span> - <span class="number">.2</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">.3</span> - <span class="number">.2</span>;</span><br><span class="line">x === y;         <span class="comment">//=&gt; false JavaScript中也存在这种问题，所以尽量避免去比较类似的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在字面量后跟小写字母n，表示BigInt字面量(ES2020新增) </span></span><br><span class="line"><span class="comment"> * 默认基数是10，可以通过前缀来表示其他进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="number">1234n</span>            </span><br><span class="line"><span class="number">0b111111n</span></span><br><span class="line"><span class="number">0o723n</span>           </span><br><span class="line"><span class="number">1000n</span> / <span class="number">330n</span>     <span class="comment">//=&gt; 3n 只有 / 运算会舍弃余数并向下取商，其它运算和常规JavaScript类似</span></span><br><span class="line"><span class="number">1000n</span> + <span class="number">123</span>      <span class="comment">//   JavaScript不允许BigInt操作数和常规JavaScript操作数混用，</span></span><br><span class="line"><span class="number">0</span> === <span class="number">0n</span>         <span class="comment">//=&gt; false 但比较远运算符例外</span></span><br></pre></td></tr></table></figure><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p><code>JavaScript</code>中表示文本的类型是<code>String</code>，即字符串。字符串是<strong>16位值的不可修改的有序序列</strong>，其中每个值都表示一个<code>Unicode</code>字符。字符串的<code>length</code>属性是它<strong>包含的16位值的个数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 有些超出16位范围的Unicode字符（surrogate pair “代理对”），就需要长度为2的JavaScript字符串来表示了</span></span><br><span class="line"><span class="comment"> * 以此类推，JavaScript字符串的操作方法，一般操作的都是16位值，而不是字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="string">`abc`</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>        <span class="comment">//   JavaScript中单引号、双引号和反引号(ES6新增)，都可以用来包含字符串字面量</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//   JavaScript将换行符、回车和回车 `/`换行序列识别为行终止符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;handong&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">`hi! <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模板字面量 </span></span><br><span class="line"><span class="comment"> * $&#123;表达式&#125; </span></span><br><span class="line"><span class="comment"> /</span></span><br><span class="line"><span class="comment">String.raw`\n`.length  //=&gt; 2 非常特殊的情况下，反引号`可以充当函数括号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一对斜杠之间的文本构成正则表达式字面量（RegExp）</span></span><br><span class="line"><span class="comment"> * 这对斜杠的第二个后面还可以跟一个或多个字母，用于修改模式的含义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="regexp">/^HTML/</span>;      <span class="comment">//   匹配字符串开头的字母HTML</span></span><br></pre></td></tr></table></figure><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>这个类型只有两个值：<code>ture</code>和<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaScript中的任何值都可以转换为布尔值，或者当成布尔值使用，称为假性值falsy、真性值truthy</span></span><br><span class="line"><span class="comment"> * false: undefined null 0 -0 NaN 空字符串</span></span><br><span class="line"><span class="comment"> * true: 除了false的所有其他值</span></span><br><span class="line"><span class="comment"> * 唯一的API: toString() 将自己转换为字符串&quot;true&quot;或&quot;false&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a><code>null</code>和<code>undefined</code></h2><p><code>null</code>是一个语言关键字，可以看成该特殊类型的唯一成员，是一种特殊对象，用于表示一个值不存在。<br><code>undefined</code>也表示值不存在（更深层次的不存在），可以说，变量的值未初始化时就是<code>undefined</code>，也视为该特殊类型的唯一成员</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>符号 是<code>ES6</code>新增的原始类型，符号没有字面量语法，只能通过<code>Symbol()</code>函数创建，其接受一个字符串参数，返回一个唯一的符号值</p><p>实践中，通常作为一种语言拓展机制，之后再了解</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局对象：</span></span><br><span class="line"><span class="comment"> * 全局对象的属性是全局性定义的标识符，可以在JavaScript程序的任何地方使用</span></span><br><span class="line"><span class="comment"> * JavaScript解释器启动后（或每次浏览器加载页面），都会创建一个新的全局对象并初始化一组属性</span></span><br><span class="line"><span class="comment"> * ES2020最终定义了globalThis来作为引用全局对象的标准方式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对象有时候被称为引用类型（reference type），以区别于JavaScript的原始类型</span></span><br><span class="line"><span class="comment"> * 对象值就是引用，对象的比较就是按引用比较的，引用同一个底层对象才视为相等</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaScript会根据需要把你提供的值转为布尔值，但有时也会转换为字符串、数字或NaN</span></span><br><span class="line"><span class="comment"> * | 你提供的值 | 转换为字符串 | 转换为数值 | 转换为布尔值 |</span></span><br><span class="line"><span class="comment"> * 更多内容见《JavaScript权威指南 李松峰译 原书第七版》p44</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * == 会在比较之前按需进行类型转换，但绝不会将操作数转换为布尔值 </span></span><br><span class="line"><span class="comment"> * 可以用函数显示转换，比如Boolean() Number() String() 等等</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对象转换为原始类型：p49（比较繁琐和细节） </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="变量的声明与赋值"><a href="#变量的声明与赋值" class="headerlink" title="变量的声明与赋值"></a>变量的声明与赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaScript的标识符的命名：首字母必须以字母、`_`或`$`开头，后续字符可以是字母、数字、下划线或美元符号</span></span><br><span class="line"><span class="comment"> * 常量用`const`声明，变量用`let`声明</span></span><br><span class="line"><span class="comment"> * const 必须在声明时初始化常量，前后续不可更改（否则引起TypeError）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解构赋值：let [x,y] = [1,2];  //=&gt; x = 1, y = 2 </span></span><br><span class="line"><span class="comment"> *          两侧的变量和值数量不等时，要么被忽略，要么被设置为undefined</span></span><br><span class="line"><span class="comment"> *          左侧的变量列表中，可以包含额外的逗号，以跳过右侧的某些值</span></span><br><span class="line"><span class="comment"> *          把右侧未使用或剩余的收集，就在左侧的最后一变量名前加上三个点...</span></span><br><span class="line"><span class="comment"> *          支持嵌套解构</span></span><br><span class="line"><span class="comment"> *          右侧值的类型数组、字符串、对象都适用</span></span><br><span class="line"><span class="comment"> *          当右侧为对象时，左侧的变量名则会自动和对象的属性名对应（否则被设置为undefined）。当然，这样就局限了变量的命名，所以可以在属性名后加上冒号，填写自定义的变量名</span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">const</span> &#123;<span class="attr">cos</span>: myCos, <span class="attr">sin</span>: mySin&#125; = <span class="title class_">Math</span>; <span class="comment">//=&gt;const myCos = Math.cos, mySin = Math.sin;</span></span><br></pre></td></tr></table></figure><h1 id="表达式与操作符"><a href="#表达式与操作符" class="headerlink" title="表达式与操作符"></a>表达式与操作符</h1><h2 id="主表达式（primary-expression）"><a href="#主表达式（primary-expression）" class="headerlink" title="主表达式（primary expression）"></a>主表达式（primary expression）</h2><p>定义：独立存在，不再包含更简单的表达式的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line">/^some/      <span class="comment">// 字面量</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="variable language_">this</span>         <span class="comment">// 保留字</span></span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">sum</span><br><span class="line"><span class="literal">undefined</span>    <span class="comment">// 变量、常量、全局对象属性的引用</span></span><br></pre></td></tr></table></figure><h2 id="对象和数组初始化程序"><a href="#对象和数组初始化程序" class="headerlink" title="对象和数组初始化程序"></a>对象和数组初始化程序</h2><p>也属于表达式，但不是主表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些初始化程序，有时也称 数组字面量、对象字面量</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数定义表达式"><a href="#函数定义表达式" class="headerlink" title="函数定义表达式"></a>函数定义表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="keyword">return</span> x*x;&#125;;    <span class="comment">// 关键字function 参数列表 函数体 （匿名函数例外）</span></span><br></pre></td></tr></table></figure><h2 id="属性访问表达式"><a href="#属性访问表达式" class="headerlink" title="属性访问表达式"></a>属性访问表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * expression . identifier</span></span><br><span class="line"><span class="comment"> * expression [ identifier ]</span></span><br><span class="line"><span class="comment"> * 句点 中括号 前面的表达式都会先求值，若为null | undefined，则抛出TypeError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">x.<span class="property">pos</span></span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line">dic[<span class="string">&quot;name&quot;</span>]    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ES2020 新增两种属性访问表达式</span></span><br><span class="line"><span class="comment"> * expression ?.  identifier</span></span><br><span class="line"><span class="comment"> * expression ?.[ identifier ]</span></span><br><span class="line"><span class="comment"> * 这两种表达式，当前面的表达式为null | undefined 时，返回undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="调用表达式"><a href="#调用表达式" class="headerlink" title="调用表达式"></a>调用表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * expression([args,,,])    中括号部分为可选内容</span></span><br><span class="line"><span class="comment"> * 括号前面的表达式都会先求值，若不为函数（包括null undefined的情况），则抛出TypeError</span></span><br><span class="line"><span class="comment"> * 要么为函数体return的值，要么为undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">3</span>)</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ES2020 新增条件式调用表达式</span></span><br><span class="line"><span class="comment"> * expression ?.()</span></span><br><span class="line"><span class="comment"> * 仅当 前面的表达式为null | undefined 时，不执行函数，返回undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对象创建表达式"><a href="#对象创建表达式" class="headerlink" title="对象创建表达式"></a>对象创建表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Pos</span>(<span class="number">3</span>,<span class="number">3</span>)    <span class="comment">// 自动执行对象的构造函数来初始化</span></span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>具体表格见《JavaScript权威指南–李松峰译–书第七版》p66<br>左值：一个可以合法地出现在赋值表达式左侧的表达式<br>JavaScript中，变量、对象属性和数组元素都是“左值”</p><h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//《JavaScript权威指南--李松峰译--书第七版》p70</span></span><br><span class="line"><span class="comment">// 相关细节很多，建议看书</span></span><br></pre></td></tr></table></figure><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 严格相等 ===</span></span><br><span class="line"><span class="comment"> * 两个值类型不同                               =&gt; false</span></span><br><span class="line"><span class="comment"> * 两个值都为null，或都为undefined              =&gt; true</span></span><br><span class="line"><span class="comment"> * 两个值中有NaN(1或2个)                        =&gt; false</span></span><br><span class="line"><span class="comment"> * 两个值都是数值且值相等                       =&gt; true</span></span><br><span class="line"><span class="comment"> * 0 = -0                                      =&gt; true</span></span><br><span class="line"><span class="comment"> * 两个值都是字符串且相同位置的16位值完全相同    =&gt; true</span></span><br><span class="line"><span class="comment"> * 两个值都是引用的同一对象、数组或函数          =&gt; true</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 不满足的严格相等的， !== 就为true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于类型转换的相等 ==</span></span><br><span class="line"><span class="comment"> * 如果两个值的 类型不同，它会尝试做类型转换</span></span><br><span class="line"><span class="comment"> * 如果两个值的 类型相同（本来就相同 或 转换后相同），它会按照严格相等来进行比较</span></span><br><span class="line"><span class="comment"> * 类型转换细则(下面的?表示代指，无意义)：</span></span><br><span class="line"><span class="comment"> *     特殊：null == undefined   =&gt; true</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     ?  == 字符串   --&gt;  ? == 数值</span></span><br><span class="line"><span class="comment"> *     ?  == true     --&gt;  ? == 1</span></span><br><span class="line"><span class="comment"> *     ?  == false    --&gt;  ? == 0</span></span><br><span class="line"><span class="comment"> *     ?  == 对象     --&gt;  ? == 原始值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 关于对象如何转换为原始值：</span></span><br><span class="line"><span class="comment"> *     JavaScript会尝试使用对象内的toString()方法，或者使用valueOf()方法</span></span><br><span class="line"><span class="comment"> *     通常一般的对象都会优先使用valueOf()，但Date类是例外，它优先执行toString()</span></span><br><span class="line"><span class="comment"> *     前者失败（或不存在该方法）后，再考虑toString() | valueOf()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 不满足基于类型转换的相等的， != 就为true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较操作符</span></span><br><span class="line"><span class="comment"> * 只能比较数值和字符串（若不是则会进行转换，再比较</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * JavaScript字符串是16位整数值的序列，而字符串比较是比较两个字符串的数值序列</span></span><br><span class="line"><span class="comment"> * Unicode定义的数值编码顺序会受不同地区和特定语言使用的传统 校正顺序（collation order）匹配</span></span><br><span class="line"><span class="comment"> * 不同地区比如不同国家</span></span><br><span class="line"><span class="comment"> * 特定语言，比如ASCII，它的 大写字母的数值 排在 小写字母前（这样的话 Z &gt; a 反而成立）</span></span><br><span class="line"><span class="comment"> * 可以考虑String.localeCompare()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * = 和 &lt;= 不依赖于之前的等于比较符，仅代表 &gt; 或 &lt; 相反情况的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * in 操作符</span></span><br><span class="line"><span class="comment"> * in期待左侧是可以转换成字符串的任何值，右侧是对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;0&quot;</span> <span class="keyword">in</span> data        <span class="comment">//=&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pos = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line">x <span class="keyword">in</span> pos           <span class="comment">//=&gt; true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * instanceof 操作符</span></span><br><span class="line"><span class="comment"> * 左侧操作数为对象，右侧操作数是对象类的标识</span></span><br><span class="line"><span class="comment"> * 当左侧的对象 是 右侧类 的 实例 时，返回true，否则为false</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">let</span> d = <span class="title class_">Date</span>()</span><br><span class="line"> d <span class="keyword">instanceof</span> <span class="title class_">Date</span>    <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &amp;&amp;</span></span><br><span class="line"><span class="comment"> * 总是返回真值或假值（注意，这个范围很大）</span></span><br><span class="line"><span class="comment"> * 它不要求左右两侧操作数为布尔值（比如真/假性值），也并不总是返回true或false</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当左侧操作数为假值，右侧操作数不会被求值，返回左侧的操作数的值</span></span><br><span class="line"><span class="comment"> * 当左侧操作数为真值，返回右侧操作数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * || 同上（相反）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="string">&quot;a&quot;</span> &amp;&amp; <span class="string">&quot;b&quot;</span>    <span class="comment">//=&gt; &quot;b&quot;</span></span><br><span class="line"> <span class="string">&quot;a&quot;</span> &amp;&amp; <span class="number">0</span>      <span class="comment">//=&gt; 0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ! 逻辑非</span></span><br><span class="line"><span class="comment"> * 总是返回布尔值：true或false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>         <span class="comment">// 普遍情况</span></span><br><span class="line">a = b = c = <span class="number">1</span> <span class="comment">// 连续赋值的简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 拼接操作符</span></span><br><span class="line"><span class="comment"> * += -= **= 等等</span></span><br><span class="line"><span class="comment"> * 唯一不同的是，拼接后，左操作数只会被求值一次，而原来会被求值两次</span></span><br><span class="line"><span class="comment"> * 这可能会带来负效应</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line">a[i++] += <span class="number">1</span>        </span><br><span class="line">a[i++]  = a[i++] + <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>eval操作符（也是函数）：<br>相关细节见p84</p><p>其它操作符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 条件操作符： </span></span><br><span class="line"><span class="comment"> * ?: </span></span><br><span class="line"><span class="comment"> * expr1 ? expr2 : expr3</span></span><br><span class="line"><span class="comment"> * expr1 为true时，返回expr3，否则返回expr3</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;hi,&quot;</span> + (name ? name : <span class="string">&quot;there&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 先定义（first-defined）操作符</span></span><br><span class="line"><span class="comment"> * ES2020新增，正式名为缺值合并（nullish coalescing）操作符</span></span><br><span class="line"><span class="comment"> * ??</span></span><br><span class="line"><span class="comment"> * expr1 ?? expr2</span></span><br><span class="line"><span class="comment"> * 只有在expr1 为null或undefined时 才会返回第二个操作数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * typeof 操作符，总是返回如下值</span></span><br><span class="line"><span class="comment"> *     &quot;undefined&quot; </span></span><br><span class="line"><span class="comment"> *     &quot;object&quot;</span></span><br><span class="line"><span class="comment"> *     &quot;boolean&quot;</span></span><br><span class="line"><span class="comment"> *     &quot;number&quot;</span></span><br><span class="line"><span class="comment"> *     &quot;bigint&quot;</span></span><br><span class="line"><span class="comment"> *     &quot;string&quot;</span></span><br><span class="line"><span class="comment"> *     &quot;symbol&quot;</span></span><br><span class="line"><span class="comment"> *     &quot;function&quot;</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>    <span class="comment">//=&gt; &quot;object&quot;: 所以要区分对象和null，需要显式测试</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * delete 操作符</span></span><br><span class="line"><span class="comment"> * 删除对象属性（包括数组元素），将属性设置为undefined的同时，该属性也不存在了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"> <span class="keyword">delete</span> a[<span class="number">2</span>]    <span class="comment">// 删除数组最后一个元素</span></span><br><span class="line"> a.<span class="property">length</span>       <span class="comment">//=&gt; 3:长度不变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * await 操作符</span></span><br><span class="line"><span class="comment"> * ES2017新增，期待一个Promise对象作为唯一操作数</span></span><br><span class="line"><span class="comment"> * 只能出现在已经通过async关键字声明为异步的函数中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * void 操作符</span></span><br><span class="line"><span class="comment"> * 它可以放在任意类型的操作数前面，求值这个操作数，返回undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> i++;</span><br><span class="line"> <span class="title function_">f</span>();    <span class="comment">//=&gt; undefined</span></span><br><span class="line"> i       <span class="comment">//=&gt; 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * , 逗号操作符</span></span><br><span class="line"><span class="comment"> * 求值左侧操作数然后丢弃，再求值右侧操作数并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>JavaScript程序就是一系列语句，以分号分隔</p><h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>定义：有<strong>副效应</strong>的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i++;      <span class="comment">// 赋值表达式</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">myFun</span>();  <span class="comment">// 调用表达式</span></span><br></pre></td></tr></table></figure><h2 id="复合语句和空语句"><a href="#复合语句和空语句" class="headerlink" title="复合语句和空语句"></a>复合语句和空语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i++,j++,c++;    <span class="comment">// 复合语句</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  i++;</span><br><span class="line">  j++;</span><br><span class="line">  c++;          <span class="comment">// 语句块，也是复合语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;               <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr) </span><br><span class="line">statement;    <span class="comment">// expr为真值，则执行statement；反之</span></span><br><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="comment">// else if (expr2) &#123;statement1;statement2;&#125;</span></span><br><span class="line"><span class="comment">// else &#123;statement3;statement4;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(expr)&#123;</span><br><span class="line">statement;</span><br><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="comment">// case expr1:</span></span><br><span class="line"><span class="comment">//     statement2;</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">// default:</span></span><br><span class="line"><span class="comment">//     statement3;</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line">&#125;                 <span class="comment">// 其中case的使用，是以===来判断相等的，这个例子里是比较expr===expr1</span></span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expr)&#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">while</span>(expr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(init; test; increment)</span><br><span class="line">statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6新增 for/of 专门用于可迭代对象（与for关键字完全不同）</span></span><br><span class="line"><span class="keyword">let</span> myArr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> myArr)</span><br><span class="line">statement;                  <span class="comment">// 数组属于可迭代对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr = <span class="string">&quot;abcdefg&quot;</span>;          <span class="comment">// 字符串是按 码点 迭代的，而不是16位值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>&#125;;      <span class="comment">// 对象默认不可迭代</span></span><br><span class="line">    <span class="comment">// 需要用Object.keys()、Object.values()或Object.entries()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>,<span class="string">&quot;one&quot;</span>],[<span class="number">2</span>,<span class="string">&quot;two&quot;</span>]]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2018新增 异步迭代器 和 异步迭代器的for/await循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFun</span>(<span class="params">str</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">let</span> s <span class="keyword">in</span> str</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for/in循环 适用于任意对象，循环指定对象的属性名</span></span><br><span class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span> object)</span><br><span class="line">statement;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * javascript首先对object求值，若为null 或 undefined则会跳过循环，执行下文语句</span></span><br><span class="line"><span class="comment"> * 但并不会枚举对象中的所有属性，比如符号类的不可枚举等等</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 常见的continue break return throw yield </span></span><br><span class="line"><span class="comment"> * 它们都具有跳转功能，让JavaScript解释器跳转到新的代码位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句标签，给语句起个名字，可以在程序的其它地方通过这个名字引用它</span></span><br><span class="line"><span class="comment">// 标签 和 变量与函数 不在同一个命名空间</span></span><br><span class="line"><span class="attr">identifier</span>: statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// break 只在循环和switch中使用，达到跳出的作用，</span></span><br><span class="line"><span class="comment">// break 后可以接语句标签，达到跳出后，跳转到该语句标签的作用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// return 只在函数体中使用，返回的值作为函数的值，若没有则为undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// yield 之用在ES6新增的生成器函数中</span></span><br><span class="line"><span class="comment">// 它非常类似return，详见第12章（迭代器和生成器）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// throw 抛出异常，可用try/catch/finally捕获</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// try/catch/finally JavaScript的异常处理机制</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123;<span class="comment">// ES2019 可以省略 (e)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// with 用于创建临时作用域</span></span><br><span class="line"><span class="comment">// 基本被废弃，不推荐使用</span></span><br><span class="line"><span class="title function_">with</span>(object)</span><br><span class="line">statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// debugger 像一个断点，执行时JavaScript会停止，我们可以查看调用栈等信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>    <span class="comment">// 属于 指令（和语句很相近）</span></span><br><span class="line"><span class="comment">// 具体作用见p115</span></span><br></pre></td></tr></table></figure><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>（看起来很像语句，一并介绍）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * const let var function class import export 这些关键严格来讲都是声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>     <span class="comment">// 声明常量</span></span><br><span class="line"><span class="keyword">let</span>       <span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">var</span>       <span class="comment">// ES6之前唯一的声明变量方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="comment">// 用于定义函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * class 用于创建一个新类</span></span><br><span class="line"><span class="comment"> * 注意，类不会被“提升”，不能在类被声明之前使用它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">init1</span>)&#123;<span class="variable language_">this</span>.<span class="property">init1</span>=init1&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * import </span></span><br><span class="line"><span class="comment"> * 每一个js文件都是一个模块，之间完全无关，</span></span><br><span class="line"><span class="comment"> * import可以将其他模块的值导入，从而可以使用其他模块的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * export</span></span><br><span class="line"><span class="comment"> * 每一个js文件中的值都是 私有的，除非被显式导出，否则其他模块无法导入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;xx,yy&#125; <span class="keyword">from</span> <span class="string">&#x27;./xyz.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xyz.js</span></span><br><span class="line"><span class="keyword">const</span> xx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> yy = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;xx,yy&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h1><p>对象是一个 属性的无序集合，每个属性都有名字和值 和 三个属性特性（property attribute）</p><ul><li>可写（writable）</li><li>可枚举（enumerable）</li><li>可配置（configurable）</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDict = &#123;&#125;                         <span class="comment">// 通过字面量创建 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>()                    <span class="comment">// 通过new关键字创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 几乎所有对象都有 原型，但只有少数对象有prototype属性。</span></span><br><span class="line"><span class="comment"> * 正是这些有prototype属性的对象为所有其他对象定义了 原型</span></span><br><span class="line"><span class="comment"> * Object.prototype是为数不多的没有原型的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>&#125;)   <span class="comment">// 通过Object.create()创建</span></span><br></pre></td></tr></table></figure><h2 id="查询和设置属性"><a href="#查询和设置属性" class="headerlink" title="查询和设置属性"></a>查询和设置属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">o.<span class="property">property</span></span><br><span class="line">o.[<span class="string">&quot;property&quot;</span>]   <span class="comment">// 要求方括号中是字符串或可以转换成字符串的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaScript的对象可以视为 关联数组，可以动态添加属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaScript的对象支持继承，参考“原型链”的概念</span></span><br><span class="line"><span class="comment"> * 同时，JavaScript只在查询时会用到原型链，而设置属性时不影响原型链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myName = <span class="keyword">class</span>?.<span class="property">student</span>?.<span class="property">name</span>    <span class="comment">// 访问属性时，</span></span><br><span class="line">                                     <span class="comment">// 对象为null或undefined时，报错TypeError</span></span><br><span class="line">                                     <span class="comment">// 属性不存在时，返回undefined</span></span><br><span class="line">                                     </span><br><span class="line">                                     <span class="comment">// 同理，设置属性时，</span></span><br><span class="line">                                     <span class="comment">// 对象为null或undefined时，报错TypeError</span></span><br><span class="line">                                     <span class="comment">// 以及对象不允许添加新属性时，也会报错</span></span><br><span class="line">                                     <span class="comment">// 还有其他较复杂的情况，参考p128</span></span><br></pre></td></tr></table></figure><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete 情况同上 见p128</span></span><br></pre></td></tr></table></figure><h2 id="测试属性"><a href="#测试属性" class="headerlink" title="测试属性"></a>测试属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> </span><br><span class="line"><span class="title function_">hasOwnProperty</span>()</span><br><span class="line"><span class="title function_">propertyIsEnumerable</span>()</span><br><span class="line">!= <span class="literal">undefined</span>                    <span class="comment">// 都可以用来判断某对象是否含有某属性</span></span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>/<span class="keyword">in</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>() + <span class="keyword">for</span>/<span class="keyword">of</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>()</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>()</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">ownKeys</span>()                <span class="comment">// 都可以用来枚举对象的属性</span></span><br></pre></td></tr></table></figure><h2 id="拓展对象"><a href="#拓展对象" class="headerlink" title="拓展对象"></a>拓展对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：手动设置属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：ES6新增 Object.assign()</span></span><br></pre></td></tr></table></figure><h2 id="序列化对象-serialization"><a href="#序列化对象-serialization" class="headerlink" title="序列化对象(serialization)"></a>序列化对象(serialization)</h2><p>定义：把对象转为字符串，之后可以从中恢复对象的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>()  <span class="comment">// 序列化</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>()      <span class="comment">// 恢复</span></span><br><span class="line">                  <span class="comment">// JSON是Javascript语法的子集，有些对象是不支持的</span></span><br></pre></td></tr></table></figure><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>()</span><br><span class="line"><span class="title function_">valueOf</span>()</span><br><span class="line"><span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="title function_">toJson</span>()           <span class="comment">// 可以由JavaScript本身提供，也可以自己去重写或新增</span></span><br></pre></td></tr></table></figure><h2 id="对象字面量拓展语法"><a href="#对象字面量拓展语法" class="headerlink" title="对象字面量拓展语法"></a>对象字面量拓展语法</h2><p>（<code>ES6</code>新增）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性名和变量名一样，可以简写</span></span><br><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>,y=<span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;x,y&#125;   <span class="comment">// o.x=1 o.y=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算的属性名 动态的计算出属性名 以下是一个通过代码来设置版本的例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROPERTY_NAME</span>=<span class="string">&quot;version&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computePropertyName</span>(<span class="params">s</span>)&#123;<span class="keyword">return</span> s + <span class="string">&quot; &quot;</span> + <span class="variable constant_">PROPERTY_NAME</span>&#125;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">[<span class="variable constant_">PROPERTY_NAME</span>]:<span class="number">0.1</span>,</span><br><span class="line">[<span class="title function_">computePropertyName</span>(<span class="string">&quot;dev&quot;</span>)]:<span class="number">0.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号作为属性名"><a href="#符号作为属性名" class="headerlink" title="符号作为属性名"></a>符号作为属性名</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上，该拓展语法也可用于符号类属性</span></span><br><span class="line"><span class="keyword">const</span> extensionProperty = <span class="title class_">Symbol</span>(<span class="string">&quot;my extension symbol property&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">[extensionProperty]: &#123;<span class="comment">/*你的数据*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">o[extensionProperty].<span class="property">x</span> = <span class="comment">/*你的值*/</span> <span class="comment">// 这样的话，这种属性就不会和当前的任何属性冲突了</span></span><br></pre></td></tr></table></figure><h2 id="拓展操作符"><a href="#拓展操作符" class="headerlink" title="拓展操作符"></a>拓展操作符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 三个点，当用于字面的对象时，可以起到这样的作用，所以称为“拓展操作符”</span></span><br><span class="line"><span class="comment">// 但放在其它场景的作用会完全不同</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">z</span>:<span class="number">3</span>,<span class="attr">p</span>:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">let</span> o3 = &#123;...o1, ...o2&#125; <span class="comment">//=&gt; o3 = &#123;x:1,y:2,z:3,p:5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意性能，单次拓展属性O(n)，循环则是O(n^2) !!!</span></span><br></pre></td></tr></table></figure><h2 id="简写方法（属性）"><a href="#简写方法（属性）" class="headerlink" title="简写方法（属性）"></a>简写方法（属性）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"><span class="attr">area</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;, <span class="comment">// 简写 area()&#123;return 0;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">o.<span class="title function_">area</span>() <span class="comment">//=&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持符号、计算的属性名</span></span><br><span class="line"><span class="keyword">const</span> extensionProperty = <span class="title class_">Symbol</span>(<span class="string">&quot;my extension symbol property&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">[extensionProperty]()&#123;<span class="comment">/*你的函数体*/</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性的获取和设置方法"><a href="#属性的获取和设置方法" class="headerlink" title="属性的获取和设置方法"></a>属性的获取和设置方法</h2><p>（<code>ES5</code>引入，<code>ES6</code>支持字面量拓展）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaScript还支持为对象定义 访问器属性（accessor property）</span></span><br><span class="line"><span class="comment"> * 这种属性不是值，而是多个访问器方法</span></span><br><span class="line"><span class="comment"> * 获取方法：getter</span></span><br><span class="line"><span class="comment"> * 设置方法：setter</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当访问一个对象的属性时，就会调用对应的获取方法；对应的，设置属性值，调用设置方法</span></span><br><span class="line"><span class="comment"> * 若没有设置方法，则该属性不可写；对应的，若没有读取方法，则该属性不可读；都有，则可读写</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 只需要在属性前加上set 或 get，然后跟定义方法属性一样</span></span><br><span class="line"><span class="comment"> * 支持符号和计算的属性名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"><span class="attr">x</span>:<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">p1</span>()&#123;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>&#125;,</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">p1</span>(<span class="params">x</span>)&#123;<span class="variable language_">this</span>.<span class="property">x</span> = x;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">p2</span>()&#123;<span class="comment">/**/</span>&#125;,</span><br><span class="line"><span class="comment">// 可以有多个，也可以没有</span></span><br><span class="line">&#125;;</span><br><span class="line">o.<span class="property">p1</span>      <span class="comment">//=&gt; 1</span></span><br><span class="line">o.<span class="title function_">p1</span>(<span class="number">5</span>)   <span class="comment">//=&gt; o.p1 = 5</span></span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组可以看成特殊的对象，只不过<strong>属性名刚好是整数</strong>，也正是该特性让其访问起来效率比一般的对象更高<br>ES6推出了<strong>定型数组</strong>（typed Array），要求固定长度和固定数值元素类型。它性能极高，支持二进制可访问字节级的数据</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数组字面量</span></span><br><span class="line"><span class="comment"> * 逗号之间没有元素，就是稀疏数组，访问该位置返回undefined</span></span><br><span class="line"><span class="comment"> * 可以嵌套</span></span><br><span class="line"><span class="comment"> * 元素类型可以不一样，甚至可以是表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,,,<span class="number">3</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对可迭代对象使用...拓展符(ES6新增)</span></span><br><span class="line"><span class="comment"> * 用来包含另一个数组（字符串或集合等可迭代对象）的所有元素</span></span><br><span class="line"><span class="comment"> * 实质是使用for/of，迭代元素并创建（浅）副本</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  (忽略该数组最后一个元素后的逗号）当包含[1,2,]或[1,2]效果是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">5</span>,...a,<span class="number">7</span>]      <span class="comment">// =&gt; b = [5,1,,,3,7]</span></span><br><span class="line"><span class="keyword">let</span> c = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...<span class="string">&quot;hahaha&quot;</span>])]  <span class="comment">// =&gt; c = [&#x27;h&#x27;,&#x27;a&#x27;]：包含了字符串、集合以及去重等示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array()构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>)       <span class="comment">// 指定长度为10的数组（此时，甚至索引0,1,2等都没有定义）</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Array</span>(...<span class="string">&quot;abc&quot;</span>) <span class="comment">// =&gt; g = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂方法Array.of()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> h = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>)         <span class="comment">// =&gt; h = [1]:</span></span><br><span class="line">    <span class="comment">// 弥补了Array()不能创建只含有一个数值元素的数组的缺陷</span></span><br><span class="line">    <span class="comment">// 其余功能和Array()构造函数一样</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂方法Array.from()</span></span><br><span class="line"><span class="comment"> * 第一个参数：可迭代对象 或 类数组对象</span></span><br><span class="line"><span class="comment"> *     当为可迭代对象时，同...</span></span><br><span class="line"><span class="comment"> *     当为类数组对象（有length属性，每个属性的键也是整数），作用是创建真正的数组副本</span></span><br><span class="line"><span class="comment"> * 第二个参数：函数</span></span><br><span class="line"><span class="comment"> *     把前者的每一元素传给这个函数，函数的返回值为新数组的元素</span></span><br><span class="line"><span class="comment"> *     （推荐在构建数组时就处理好，而不是用这个函数）</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="keyword">let</span> i = <span class="title class_">Array</span>.<span class="title function_">from</span>(h)       <span class="comment">// =&gt; i = [1] </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读写数组元素"><a href="#读写数组元素" class="headerlink" title="读写数组元素"></a>读写数组元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 [] 访问数组元素，方括号左侧是数组的引用，方括号中是非负整数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数组是一种特殊的对象，用方括号访问数组元素和用方括号访问对象属性是类似的</span></span><br><span class="line"><span class="comment"> * JavaScript会把数组索引（整数）转为字符串，作为属性名</span></span><br><span class="line"><span class="comment"> * 数组所有索引都是属性名，但只有介于0~2^32-2之间的整数属性名才是索引</span></span><br><span class="line"><span class="comment"> * 可以给数组新建不属于索引范围内的属性名，比如a[-10]=9 =&gt; &#123;&quot;-10&quot;:9&#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数组长度由JavaScript内部自动维护，只对索引有效，其他属性名不会被统计在内</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = [...<span class="string">&quot;abc&quot;</span>]</span><br><span class="line">a[<span class="number">1</span>]                  <span class="comment">// =&gt; &#x27;b&#x27;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">1</span>]                  <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 即使中间含有多个undefined元素，长度仍以最高索引为准</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = [,]         <span class="comment">// =&gt; a没有元素，但a.length=1，且此时索引都没有被定义 0 in a = false</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="literal">undefined</span>] <span class="comment">// =&gt; a有一个元素undefined，且a.length=1，索引被定义了 0 in b = true</span></span><br></pre></td></tr></table></figure><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任何情况，数组索引都不会大于或等于数组长度</span></span><br><span class="line"><span class="comment"> * 可以修改数组length属性：</span></span><br><span class="line"><span class="comment"> *     要么删除所有等于或大于length的索引对应的数组元素</span></span><br><span class="line"><span class="comment"> *     要么在末尾增加一堆的undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="增加-x2F-删除数组元素"><a href="#增加-x2F-删除数组元素" class="headerlink" title="增加&#x2F;删除数组元素"></a>增加&#x2F;删除数组元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 主要注意，是否会修改length，以及元素的值和索引的变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>         <span class="comment">// =&gt; a = [1]</span></span><br><span class="line">                 <span class="comment">//    a.length=1</span></span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>)  <span class="comment">// =&gt; a = [1,&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line">                 <span class="comment">//    a.length=3</span></span><br><span class="line">a.<span class="title function_">pop</span>()          <span class="comment">// =&gt; 返回&#x27;b&#x27;</span></span><br><span class="line">                 <span class="comment">//    a=[1,&#x27;a&#x27;]</span></span><br><span class="line">                 <span class="comment">//    a.length=2</span></span><br><span class="line"></span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="string">&quot;c&quot;</span>)   <span class="comment">// =&gt; a = [&#x27;c&#x27;,1,&#x27;a&#x27;]</span></span><br><span class="line">                 <span class="comment">//    a.length=3</span></span><br><span class="line">a.<span class="title function_">shift</span>()        <span class="comment">// =&gt; 返回&#x27;c&#x27;</span></span><br><span class="line">                 <span class="comment">//    a=[1,&#x27;a&#x27;]</span></span><br><span class="line">                 <span class="comment">//    a.length=2</span></span><br><span class="line"> <span class="keyword">delete</span> a[<span class="number">1</span>]     <span class="comment">// 删除索引2（也意味着删除了数组元素）</span></span><br><span class="line">                 <span class="comment">// a=[1,undefined]</span></span><br><span class="line">                 <span class="comment">// a.length=2 不影响数组长度</span></span><br></pre></td></tr></table></figure><h2 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">&quot;abc&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * for/of</span></span><br><span class="line"><span class="comment"> * forEach()</span></span><br><span class="line"><span class="comment"> * 除了用法不一致，两者对稀疏数组的处理不一样：</span></span><br><span class="line"><span class="comment"> *     前者对稀疏数组无感，若不存在便会得到undefined，后者则不会对undefined调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组提供的一种用于自身迭代的函数式方法：forEach</span></span><br><span class="line"><span class="comment">// 它接收一个函数作为参数，数组的每一个元素都会调用这个函数</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(i);&#125;)、</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老式的for循环 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>, len=arr.<span class="property">length</span>; i&lt;len; i++)&#123;<span class="comment">/*循环体*/</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p><code>JavaScript</code>不支持真正的多维数组，只能通过数组的数组来模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 循环建立二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    t[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环赋值数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; t[i].<span class="property">length</span>; j++)&#123;</span><br><span class="line">        t[i][j]=i*j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问二维数组</span></span><br><span class="line">t[<span class="number">1</span>][<span class="number">5</span>] <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>操作数组的基本语法，主要涉及<code>Array</code>类定义的方法，不同点在于有的方法会修改调用他们的数组，有的则返回新数组或者只是引用。</p><h3 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h3><p>迭代器方法是一类方法的总称，这类方法用于迭代数组元素，按顺序把数组的每个元素传给调用者提供的方法，对数组元素进行操作。</p><p>该类方法的特点是都<strong>接收一个函数作为第一个参数</strong>，对数组的<strong>每个</strong>元素（稀疏数组中不存在的元素除外）都<strong>调用</strong>这个函数，该函数被调用时会被<strong>传入三个参数</strong>，分别为<strong>数组元素的值、数组元素的索引和数组本身</strong>。</p><p>（不常用）该类方法可选接收第二个参数，作为第一个参数传入的函数的内部<code>this</code>值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], sum=<span class="number">0</span></span><br><span class="line"><span class="comment">// forEach()</span></span><br><span class="line"><span class="comment">// 唯一要注意的是该方法没有提供终止迭代的方式</span></span><br><span class="line">data.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;sum+=value&#125;) <span class="comment">// =&gt; sum==15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="comment">// 返回作为第一个参数的函数的返回值构成的数组。对于稀疏数组，则同样返回稀疏数组</span></span><br><span class="line">data.<span class="title function_">map</span>(<span class="function"><span class="params">x</span>=&gt;</span>x*x) <span class="comment">// =&gt; [1,4,9,16,25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter()</span></span><br><span class="line"><span class="comment">// 返回调用它的数组的子数组。传入的第一个参数必须是一个断言函数，返回断言为true的值组成的数组</span></span><br><span class="line"><span class="comment">// 返回的始终是稠密数组，即跳过缺失元素</span></span><br><span class="line">data.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span>=&gt;</span>x&lt;<span class="number">3</span>) <span class="comment">// =&gt; [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="comment">// 同样传入一个断言函数，在找到第一个断言为true的元素后返回 匹配的元素 并停止迭代，若没找到则返回undefined</span></span><br><span class="line">data.<span class="title function_">find</span>(<span class="function"><span class="params">x</span>=&gt;</span>x===<span class="number">3</span>) <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line"><span class="comment">// 同样传入一个断言函数，在找到第一个断言为true的元素后返回 元素的索引 并停止迭代，若没找到则返回-1</span></span><br><span class="line">data.<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span>=&gt;</span>x===<span class="number">3</span>) <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every() 和 some()</span></span><br><span class="line"><span class="comment">// 被称为 数组断言方法，相当于离散数学中的集合的 全称量词 / 存在量词。同样传入一个断言函数，整个方法的返回结果为true 或 false</span></span><br><span class="line">data.<span class="title function_">every</span>(<span class="function"><span class="params">x</span>=&gt;</span>x&gt;<span class="number">0</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce() 和 reduceRight()</span></span><br><span class="line"><span class="comment">// 将第一个参数传入的函数用于归并数组元素，第二个参数则传入初始值（若为指定，则默认以数组第一个遍历的元素作为初始值）。</span></span><br><span class="line"><span class="comment">// 两者不同点是两者遍历方向相反（前者从前往后）</span></span><br><span class="line"><span class="comment">// 这两个方法与之前的不同点是，第一个参数传入的函数它的第一个参数是目前为止归并操作累积的结果，第二、第三、第四个参数才是数组值、数组索引和数组本身</span></span><br><span class="line">data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;x+y&#125;,<span class="number">0</span>) <span class="comment">// =&gt; 15</span></span><br><span class="line">data.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;x+y&#125;) <span class="comment">// =&gt; 15</span></span><br></pre></td></tr></table></figure><h3 id="打平数组"><a href="#打平数组" class="headerlink" title="打平数组"></a>打平数组</h3><p><code>ES2019</code>中，<code>flat()</code>方法用于创建并返回一个新数组，这个新数组包含调用它的数组的相同的元素，只不过<strong>其中任何本身也是数组的元素</strong>会被<strong>“打平”</strong>填充到返回的数组（<strong>空数组打平后是没有元素的</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]].<span class="title function_">flat</span>() <span class="comment">// =&gt; [1,2,3]</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>]]].<span class="title function_">flat</span>() <span class="comment">// =&gt; [1, 2, [3]]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>也有”打平“数组的功能，且同时拥有<code>map()</code>的功能，可以看成<strong>将<code>map()</code>返回的数组自动“打平”</strong>的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span> ,<span class="number">2</span>].<span class="title function_">flatMap</span>(<span class="function"><span class="params">x</span>=&gt;</span>x&lt;<span class="number">0</span> ? [] : x) <span class="comment">// =&gt; [1, 2]</span></span><br></pre></td></tr></table></figure><h3 id="添加数组"><a href="#添加数组" class="headerlink" title="添加数组"></a>添加数组</h3><p><code>concat()</code>方法创建并返回一个新数组，新数组包含调用<code>concat()</code>方法的数组的元素和传入的数组元素，默认打平</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">concat</span>([<span class="number">4</span>,<span class="number">5</span>],[[<span class="number">6</span>]]) <span class="comment">// =&gt; [1,2,3,4,5,[6]]</span></span><br></pre></td></tr></table></figure><h3 id="栈和队列操作"><a href="#栈和队列操作" class="headerlink" title="栈和队列操作"></a>栈和队列操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 栈操作</span></span><br><span class="line">data.<span class="title function_">push</span>(<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// data==[1,2,3,4,5]</span></span><br><span class="line">data.<span class="title function_">pop</span>() <span class="comment">// =&gt; 5，此时data==[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">data.<span class="title function_">unshift</span>(<span class="number">0</span>) <span class="comment">// data==[0,1,2,3,4]</span></span><br><span class="line">data.<span class="title function_">shift</span>() <span class="comment">// =&gt; 0，此时data==[1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>注意，<code>unshift shift</code>效率不高，不过<code>unshift</code>会<strong>一次性</strong>把参数放到数组开头，比如<code>[].unshift(1,2,3) // =&gt; [1,2,3]</code></p><h3 id="处理连续区域"><a href="#处理连续区域" class="headerlink" title="处理连续区域"></a>处理连续区域</h3><p>这类方法用于处理连续区域，也叫处理子数组、数组“切片”，比如提取、替换、剪切和复制切片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice()</span></span><br><span class="line"><span class="comment">// 接收两个参数，作为切片的起止索引，返回的切片数组结果包含起始索引，但不包含终止索引。</span></span><br><span class="line"><span class="comment">// 若只传入一个参数，则默认包含起始位置到数组末尾的所有元素</span></span><br><span class="line"><span class="comment">// 可以传入负数</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// =&gt; [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice()</span></span><br><span class="line"><span class="comment">// 用于删除或增加元素，修改调用该方法的数组，返回值则是删除元素的数组， 若没有删除元素则返回空数组</span></span><br><span class="line"><span class="comment">// 接收两个参数，第一个参数作为操作的起点索引，第二个参数作为从数组中切割出的元素个数（如果省略，则默认删除所有到数组末尾的元素）</span></span><br><span class="line"><span class="comment">// 这两个参数后，接收任意多个参数，作为 插入 到起始索引的元素。特点是插入数组本身，不会打平</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment">// a==[1,3]</span></span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>) <span class="comment">// a==[1,2,4,3]</span></span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">0</span>,[<span class="number">11</span>]) <span class="comment">// a==[1,[11],2,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fill()</span></span><br><span class="line"><span class="comment">// 用于将数组中切片位置设置为指定的值，修改并返回调用该方法的数组</span></span><br><span class="line"><span class="comment">// 接收三个参数，第一个是要设置的值，第二个是起始索引（可选，默认从0开始），第三个是终止索引（可选，默认是数组末尾）</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">// a==[0,0,0,0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copyWithin()</span></span><br><span class="line"><span class="comment">// 用于把数组中切片复制到数组中的新位置，修改调用该方法的数组，返回修改后的数组。特点是数组长度不会改变</span></span><br><span class="line"><span class="comment">// 接收三个参数，第一个是粘贴位置的起始索引，第二个是复制切片的起始索引（默认为0），第三个是复制切片的终止索引（默认为数组长度）</span></span><br><span class="line"><span class="comment">// 后切片中的元素（不包含终止索引）就会从粘贴的初始索引处，顺序覆盖原数组</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.<span class="title function_">copyWithin</span>(<span class="number">1</span>) <span class="comment">// =&gt; a==[1,1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="数组索引和排序方法"><a href="#数组索引和排序方法" class="headerlink" title="数组索引和排序方法"></a>数组索引和排序方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indexOf() 和 lastIndexOf()</span></span><br><span class="line"><span class="comment">// 用于从数组中搜索指定的值，并返回第一个找到的元素的索引。两者搜索顺序不一样，前者是从前往后</span></span><br><span class="line"><span class="comment">// 接收两个参数，第一个参数是要搜索的元素（使用===来判断），第二个参数是搜索的起始位置索引（支持负数索引）</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="number">1</span>) <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// includes()</span></span><br><span class="line"><span class="comment">// 用于判断数组是否包含要搜索的值，返回true或false。可以检测是否包含NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort()</span></span><br><span class="line"><span class="comment">// 用于就地排序数组，返回排序后的数组</span></span><br><span class="line"><span class="comment">// （可选）接收一个函数作为参数，该函数接收两个参数，代表被排序的数组元素。该函数的返回值代表这两个参数的相对位置，第一个参数在第二个参数前面，则应该返回一个小于0的数值，反之。若等于0则代表此时相等或顺序不重要</span></span><br><span class="line"><span class="comment">// 如果不传任何参数，则按照字母顺序进行排序</span></span><br><span class="line"><span class="comment">// 未被定义的数组元素会放到数组末尾</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">a.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;a-b&#125;) <span class="comment">// a==[1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="数组到字符串的转换"><a href="#数组到字符串的转换" class="headerlink" title="数组到字符串的转换"></a>数组到字符串的转换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join()</span></span><br><span class="line"><span class="comment">// 把数组中的所有元素转换为字符串，然后拼接起来并返回结果字符串。</span></span><br><span class="line"><span class="comment">// 接收一个可选参数，作为拼接的分隔字符</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) <span class="comment">// =&gt; &quot;1 2 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString()，此时相当于没有参数的join()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toLocaleString，是toString()的本地版本</span></span><br></pre></td></tr></table></figure><h3 id="静态数组函数"><a href="#静态数组函数" class="headerlink" title="静态数组函数"></a>静态数组函数</h3><p><code>Array.isArray()</code>用于确定一个未知值是不是数组，返回值为<code>true / false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>事实上，只要对象有一个数值属性<code>length</code>，而且有相应的<strong>非负整数属性</strong>，那么完全可以视同为数组。所以很多时候，虽然<strong>不</strong>能在类数组对象上<strong>直接</strong>调用数组方法（可以用<code>Function.call()</code>间接调用），但我们可以真正的数组算法来遍历类数组对象。</p><h2 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h2><p>除了使用<code>charAt()</code>访问个别字符，也可通过方括号语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// =&gt; &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数可分为形参和函数体，同时<code>JavaScript</code>中的函数是对象，可以把自己赋值给变量，传给其他函数，也可以在函数上设置属性，甚至调用函数的方法。</p><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>组成：<code>function (参数列表) &#123; /*函数体*/ &#125;</code></p><p>函数声明的<strong>本质</strong>是声明了一个变量（即<strong>函数的名字</strong>），然后<strong>把函数对象赋值给这个变量</strong>。而且函数声明语句会<strong>被“提升”</strong>到包含脚本、函数或代码块的<strong>顶部</strong>   </p><p>以下是三种特殊情况：</p><ul><li>类似<code>name:value</code>对象字面量语法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123;</span><br><span class="line">    <span class="attr">f</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> c = &#123;</span><br><span class="line">    <span class="title function_">f</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get和set定义的特殊<strong>获取和设置方法</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">val</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>&#125;</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">val</span>(<span class="params">value</span>) &#123;  <span class="variable language_">this</span>.<span class="property">x</span> = value&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数表达式，将函数赋给另一个变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="keyword">return</span> x*x;&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>这种情况，函数名是可选的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带函数名--适用于需要使用到函数的情况，比如递归</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">function</span> <span class="title function_">fact</span>(<span class="params">x</span>)&#123;<span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">else</span> <span class="keyword">return</span> x*<span class="title function_">fact</span>(x-<span class="number">1</span>);&#125;;</span><br><span class="line"><span class="comment">// 可以不带函数名</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="keyword">return</span> x*x;&#125;;</span><br><span class="line"><span class="comment">//直接作为参数</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-<span class="number">1</span>;&#125;)</span><br><span class="line"><span class="comment">//定义并立即调用</span></span><br><span class="line"><span class="keyword">let</span> sq = (<span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="keyword">return</span> x*x;&#125;(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>定义：使用<strong>箭头<code>=&gt;</code>分隔函数的参数和函数体</strong>，因为箭头函数<strong>是表达式而不是语句</strong>，所以<strong>不用使用<code>function</code>关键字，也不用函数名</strong>。</p><p>重点：箭头函数<strong>从定义自己的环境中继承</strong><code>this</code>关键字的值，以及它没有<code>prototype</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较标准完整的例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>)=&gt;&#123;<span class="keyword">return</span> x+y;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写 / 特殊情况</span></span><br><span class="line"><span class="comment">// 函数体仅包含一个return语句，则可以将函数体写成一个表达式，它的值将被返回。若表达式同时是一个对象字面量，则需要放在圆括号()中，不然解释器会默认把花括号解释为函数体</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>)=&gt;x+y;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x=&gt;(&#123;<span class="attr">value</span>: x&#125;);</span><br><span class="line"><span class="comment">// 参数只有一个，可以省略括号()</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x =&gt; x*<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 没有参数，则必须要用括号()</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">c</span> = (<span class="params"></span>) =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p><code>JavaScript</code>支持在函数中嵌套函数，被嵌套的函数可以访问包含自己的函数的参数和变量</p><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>构成函数体的代码只在被调用时执行，被调用的情况一般分为5种：函数、方法、构造函数、<code>call() apply()</code>和隐式调用</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>函数是通过<strong>调用表达式</strong>被作为函数或方法调用的。</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法也是函数，只不过它保存为对象的属性而已，通过<strong>属性访问表达式</strong>被调用。</p><p>重点：方法调用的<strong>上下文是</strong>方法所归属的<strong>对象</strong>，可以通过<code>this</code>关键字引用这个对象。任何用作方法的函数实际上都会隐式收到一个参数，即调用它的对象。</p><blockquote><p>方法调用链：这是一种编程风格，即规定所写的方法若没有自己的返回值，则考虑让它们都返回<code>this</code>，那么基于这个方法调用的返回值还可以继续调用其他方法，这样就会表现为一系列方法调用。</p></blockquote><p><code>this</code>是一个关键字，不能被赋值，也不具有变量那样的作用域机制。除了箭头函数，<strong>嵌套函数是不会继承包含函数的<code>this</code>值</strong>，这在对象方法的嵌套函数中表现得尤为明显，下面举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> selft = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span> === o; <span class="comment">// =&gt; true，即this是对象o</span></span><br><span class="line">        <span class="title function_">f</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span> === o; <span class="comment">// =&gt; false 可以看出是不会继承这个方法的调用上下文的this值的</span></span><br><span class="line">            self === o; <span class="comment">// =&gt; true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这个例子是<code>javascript</code>的历史缺陷之一，解决办法之一是将此嵌套函数用箭头函数代替，只不过需要注意将函数声明手动提升到调用之前。另一个解决办法是调用嵌套函数的<code>bind()</code>方法。</p><h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p> 如果函数或方法调用前面加了一个关键字<code>new</code>，那么它就是构造函数调用。</p><p>若构造函数没有参数列表，则在调用时<strong>可以省略圆括号</strong><code>let o = new obj();</code>等价于<code>let o = new obj;</code></p><p>构造函数调用会<strong>返回一个新的空对象，并用作函数的调用上下文</strong>，即便看起来像方法调用。换句话说，<code>new o.m()</code>表达式中，<code>o</code>不会用做调用上下文。</p><p>构造函数中若显式地使用<code>return</code>语句返回某个对象，则该对象就会变成调用表达式的值，否则默认返回初始化的新对象。</p><h3 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h3><p><code>javascript</code>中的函数本身也是对象，是具有方法的。其中<code>call() apply()</code>方法可以用来间接调用函数，这两个函数允许指定调用时的<code>this</code>值，在理论上支持将任意函数作为任意对象的方法来调用。</p><h3 id="隐式函数调用"><a href="#隐式函数调用" class="headerlink" title="隐式函数调用"></a>隐式函数调用</h3><p>有一些<code>JavaScript</code>语言特性看起来不像函数调用，但实际上会导致某些函数被调用。通常这些特性导致<code>bug</code>也会更加难以排查。</p><p>比如获取方法和设置方法、对象的<code>toString()</code>方法、标签模板字面量等等</p><h2 id="函数实参与形参"><a href="#函数实参与形参" class="headerlink" title="函数实参与形参"></a>函数实参与形参</h2><h3 id="可选形参与默认值"><a href="#可选形参与默认值" class="headerlink" title="可选形参与默认值"></a>可选形参与默认值</h3><p>当调用函数时传入的实参个数大于形参时，额外的参数默认为<code>undefined</code>。也可以在函数定义时的参数列表中手动指定默认值。比较有意思的情况，参数列表中可以使用前面的参数的值来定义后面参数的默认值。</p><h3 id="剩余形参与可变长度实参列表"><a href="#剩余形参与可变长度实参列表" class="headerlink" title="剩余形参与可变长度实参列表"></a>剩余形参与可变长度实参列表</h3><p>剩余形参前面有三个点<code>...</code>，且必须是函数声明中的最后一个参数，不能被定义默认值，其类型始终是一个数组，用作接收比形参多的任意数量的实参。这样的函数也被称为<strong>变长函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params">first=-<span class="literal">Infinity</span>, ...rest</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> maxV = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> rest)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; maxV)&#123;</span><br><span class="line">            maxV = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arguments对象"><a href="#Arguments对象" class="headerlink" title="Arguments对象"></a><code>Arguments</code>对象</h3><p>在剩余实参之前，变长函数的实现是靠标识符<code>arguments</code>引用该次调用的<code>Arguments</code>类数组对象，它允许通过数值取得传给函数的参数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> maxV = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">arguments</span>[i] &gt; maxV)&#123;</span><br><span class="line">            maxV = <span class="variable language_">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在函数调用中使用拓展操作符"><a href="#在函数调用中使用拓展操作符" class="headerlink" title="在函数调用中使用拓展操作符"></a>在函数调用中使用拓展操作符</h3><p>和之前讲的剩余形参中的拓展操作符不同，我们在调用函数时也可以是使用拓展操作符<code>...</code>，用作展开数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...nums)</span><br></pre></td></tr></table></figure><h3 id="把函数实参解构为形参"><a href="#把函数实参解构为形参" class="headerlink" title="把函数实参解构为形参"></a>把函数实参解构为形参</h3><p>当我们调用函数时，传入的实参列表都会被赋给函数定义时所声明的形参，这个初始化赋值阶段和变量赋值类似，故也可以用到<strong>解构赋值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addVec</span>(<span class="params">[x1,y1], [x2,y2]</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [x1+x2, y1+y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">addVec</span>([<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>])  </span><br></pre></td></tr></table></figure><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p><code>JavaScript</code>方法的参数没有预定义的类型，在调用传参时也没有类型检查，切会按需执行任意的类型转换。当然，可以自行接入语言拓展来引入类型检查能力，或者自己在函数体内写类型检查的代码和处理逻辑。</p><h2 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h2><p>在<code>JavaScript</code>中，函数不仅是语法，也是值，可以被赋值给变量、保存为对象的属性或者数组的元素。它不是原始值，而是一种特殊的对象，<strong>可以定义自己的属性</strong>，用于保存函数运行时产生的数据。</p><h2 id="函数作为命名空间"><a href="#函数作为命名空间" class="headerlink" title="函数作为命名空间"></a>函数作为命名空间</h2><p>在函数体内声明的变量在函数外部不可见，因此可以在函数内部定义变量，并将此作为临时的命名空间。</p><p>通过<strong>立即调用函数表达式</strong>，甚至函数名都可以省略，例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*函数体*/</span>&#125;())</span><br></pre></td></tr></table></figure><p>上式最外层的圆括号一定要加，否则会被解释为函数声明语句。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><code>JavaScript</code>使用<strong>词法作用域</strong>，即<strong>函数执行</strong>时使用的时<strong>定义函数时</strong>生效的变量作用域，而<strong>不是调用函数时</strong>生效的变量作用域。为此，<code>JavaScript</code>函数对象不仅要包括函数体，<strong>也要包括对函数定义所在作用域的引用</strong>。这种函数对象与作用域（即一组变量绑定）组合起来<strong>解析函数变量的机制</strong>，在计算机科学文献中被称作<strong>闭包</strong>。</p><p>严格来讲，所有<code>JavaScript</code>函数都是闭包，但是多数函数的调用与定义都在同一作用域内，所以对于这类情况，闭包的存在无关紧要。值得关注的情况是，<strong>函数定义与调用的作用域是不同的时候</strong>，比如一个函数返回了其内部包含的嵌套函数。这种情况下，牢记<strong>词法作用域的基本规则</strong>：<code>Javascript</code><strong>函数是使用定义它们的作用域来执行的</strong>。</p><p>其次，就是每次调用函数都会创建一个新作用域（与之前函数调用时创建的的作用域相互独立），同时包含新的作用域中的变量，可以理解为创建了不同的函数对象，它们的作用域是互相独立的。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:<span class="function">()=&gt;</span>n++&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="title function_">f</span>(), n = <span class="title function_">f</span>();</span><br><span class="line">m.<span class="title function_">count</span>() <span class="comment">// =&gt; 0</span></span><br><span class="line">n.<span class="title function_">count</span>() <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>再者需要注意，同一个作用域的多个嵌套函数是可以共享变量的。但是要注意<strong>什么时候不应该共享</strong>，比如使用<code>var</code>定义变量而不是<code>let const</code>来定义变量，会导致意想不到的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fs=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        fs[i]=<span class="function">()=&gt;</span>i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fs = <span class="title function_">f</span>();</span><br><span class="line">fs[<span class="number">5</span>]() <span class="comment">// =&gt; 10 结果不是5，是因为通过var声明的变量在整个函数作用域内都有定义。若改成let来声明i则问题立马解决</span></span><br></pre></td></tr></table></figure><p>再牢记一点：<strong>与闭包关联的作用域是“活的”</strong>。嵌套函数不会创建作用域的私有副本或截取变量绑定的静态快照。</p><p>最后，写闭包时如需操作<code>this</code>值，需要在返回闭包前使用箭头函数或<code>bind()</code>，或者把外部的<code>this</code>值手动赋值给闭包中的某个变量。</p><h2 id="函数属性、方法和构造函数"><a href="#函数属性、方法和构造函数" class="headerlink" title="函数属性、方法和构造函数"></a>函数属性、方法和构造函数</h2><p><code>JavaScript</code>函数是对象，<code>typeof</code>返回值为<code>function</code>，可以通过<code>Function()</code>构造函数来创建新函数对象。</p><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a><code>length</code>属性</h3><p>函数有一个<code>length</code>属性（只读），表示函数的元数（在函数参数列表中声明的形参个数）。剩余形参不包括在内。</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><code>name</code>属性</h3><p>函数有一个<code>name</code>属性（只读），表示定义函数时使用的名字，对于未命名函数，则表示第一次创建这个函数时赋给该函数的变量名或属性名。</p><h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a><code>prototype</code>属性</h3><p>除了箭头函数，所有函数都有一个<code>prototype</code>属性，这个属性引用一个被称为原型对象的对象。</p><h3 id="call-和apply-方法"><a href="#call-和apply-方法" class="headerlink" title="call()和apply()方法"></a><code>call()</code>和<code>apply()</code>方法</h3><p>这两个方法允许间接调用一个函数，它们的<strong>第一个参数都是函数的调用上下文</strong>，在函数体内会变成<code>this</code>关键字的值，通常都是传入要在其上调用这个函数的对象。</p><p><strong>箭头函数</strong>例外，箭头的<code>this</code>值不能通过<code>call() apply()</code>方法重写，如果硬调用的话，那<strong>第一个参数实际上会被忽略</strong>（当然，其他参数不会被忽略）</p><p>这两个方法的后续参数都会传给被调用的函数，不同地方是，传给<code>apply()</code>方法的参数要以数组的形式提供，而<code>call()</code>则不用这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="title function_">call</span>(o,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">f.<span class="title function_">apply</span>(o,[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a><code>bind()</code>方法</h3><p><code>bind()</code>方法的主要目的是<strong>把函数绑定到对象，并返回一个新函数</strong>。如果<strong>调用这个新函数</strong>，就会像被绑定的对象的方法一样<strong>调用原始函数</strong>，且传给这个新函数的所有参数都会传给原始函数。也就是说，<strong>这个新函数会在指定的上下文中调用原始函数</strong>。</p><p>另外一个用处是，在第一个参数之后传给<code>bind()</code>的参数<strong>也</strong>会随<code>this</code>值<strong>一起被绑定</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y,z</span>)&#123;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>+y+z&#125;</span><br><span class="line"><span class="keyword">let</span> g = f.<span class="title function_">bind</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, <span class="number">2</span>)</span><br><span class="line"><span class="title function_">g</span>(<span class="number">3</span>) <span class="comment">// =&gt; 6，this.x绑定到1，y绑定到2，z是3</span></span><br></pre></td></tr></table></figure><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h3><p>和所有<code>JavaScript</code>方法一样，函数也有<code>toString()</code>方法，要求返回一个符合函数声明语句的字符串，通常是返回函数完整的源代码。</p><h3 id="Function构造函数"><a href="#Function构造函数" class="headerlink" title="Function构造函数"></a><code>Function</code>构造函数</h3><p>该构造函数接受任意多个字符串参数，最后一个参数是<strong>函数体的文本</strong>（语句以分号分隔），<strong>其余</strong>参数都用于指定新函数的<strong>参数名</strong>，<strong>不接受</strong>任何指定新<strong>函数名字</strong>的参数。</p><p>需要注意，<code>Function()</code>允许在运行时动态创建和编译<code>JavaScript</code>函数。它创建的函数不适用词法作用域，而是<strong>始终编译为如同顶级函数一样</strong>。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>虽然<code>JavaScript</code>不是<code>Lisp</code>或<code>Haskell</code>那样的函数式编程语言，但<strong>函数也是对象</strong>这个机制意味着可以在<code>JavaScript</code>中实现函数式编程技巧。</p><h3 id="使用函数处理数组"><a href="#使用函数处理数组" class="headerlink" title="使用函数处理数组"></a>使用函数处理数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>)=&gt;x+y</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x=&gt;x*x</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">function</span>(<span class="params">a,...args</span>)&#123;<span class="keyword">return</span> a.<span class="title function_">map</span>(...args)&#125;</span><br><span class="line"><span class="keyword">const</span> reduce = <span class="keyword">function</span>(<span class="params">a,...args</span>)&#123;<span class="keyword">return</span> a.<span class="title function_">reduce</span>(...args)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> mean=<span class="title function_">reduce</span>(data,sum)/data.<span class="property">length</span></span><br><span class="line"><span class="keyword">let</span> deviations=<span class="title function_">map</span>(data,<span class="function"><span class="params">x</span>=&gt;</span>x-mean)</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title function_">reduce</span>(<span class="title function_">map</span>(deviations,square),sum)/(data.<span class="property">length</span>-<span class="number">1</span>))</span><br><span class="line">stddev <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>定义：操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数</p><h3 id="函数的部分应用"><a href="#函数的部分应用" class="headerlink" title="函数的部分应用"></a>函数的部分应用</h3><p>将<code>bind()</code>和高阶函数组合，可以在已定义的函数基础上轻松定义更有意思的函数。</p><h3 id="函数记忆"><a href="#函数记忆" class="headerlink" title="函数记忆"></a>函数记忆</h3><p>在函数式编程中，在闭包中缓存中间数据也被称为“函数记忆”</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><code>JavaScript</code>中的类和<strong>基于原型的继承</strong>机制与<code>Java</code>等语言中类和<strong>基于类的继承</strong>机制有着<strong>本质区别</strong>。</p><h2 id="类和原型"><a href="#类和原型" class="headerlink" title="类和原型"></a>类和原型</h2><p>原型对象是类的核心特征，类意味着一组对象<strong>从同一个原型对象继承属性</strong></p><h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><p>构造函数是一种专门用于<strong>初始化新对象的状态</strong>的函数，当使用<code>new</code>关键字调用时<strong>，才会自动创建新对象</strong>，并<strong>将构造函数的<code>prototype</code>属性作为新对象的原型</strong>。也就是说，**构造函数本身并没有（且不需要）创建返回任何新对象，仅仅需要初始化<code>this</code>**，它（通过<code>new</code>）调用会自动创建新对象。一般构造函数都是由<code>new</code>关键字来调用的，若当成普通方法调用通常 会有些问题。</p><p>之前提到，<strong>几乎所有对象都有原型，但只有少数对象有<code>prototype</code>属性</strong>。同时只有函数对象有<code>prototype</code>属性，所以使用同一构造函数创建的所有对象都继承同一个对象，是同属于一个类的。</p><p>我们可以手动编写构造函数的<code>prototype</code>属性，<code>prototype</code>这个属性名是强制性的，会在创建新对象时被默认解释为要继承的原型。</p><h3 id="构造函数、类标识和instanceof"><a href="#构造函数、类标识和instanceof" class="headerlink" title="构造函数、类标识和instanceof"></a>构造函数、类标识和<code>instanceof</code></h3><p><strong>原型对象是类标识的基本</strong>，但构造函数不是（因为两个不同的构造函数的<code>prototype</code>属性可能同时指向同一个原型对象）。但是<strong>构造函数是类的公共标识</strong>，构造函数的名称一般也是类名。</p><p><code>instanceof</code>的右操作数代表某个类的构造函数，<strong>实质是检查对象</strong>（或对象所继承的对象中）<strong>是否继承该构造函数的<code>prototype</code>属性</strong></p><h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a><code>constructor</code>属性</h3><p>每个<code>JavaScript</code>函数（除了箭头函数、生成器函数和异步函数）都可以作为构造函数，并自动拥有一个<code>prototype</code>属性，这个属性的值是一个对象，<strong>有一个不可枚举的<code>constructor</code>属性，而这个<code>constructor</code>属性的值就是该函数对象</strong>。</p><h2 id="使用class关键字的类"><a href="#使用class关键字的类" class="headerlink" title="使用class关键字的类"></a>使用<code>class</code>关键字的类</h2><p><code>ES6</code>引入了<code>class</code>关键字，使类的创建更加的简便，可以看成语法糖，它并未改变<code>JavaScript</code>类基于原型的本质，并且由<code>class</code>声明的类的对象<strong>只是一个构造函数</strong>。</p><p>继承则需要使用<code>extends</code>关键字</p><p>需要注意以下几点：</p><ul><li><p>类体中不支持名&#x2F;值对形式的属性定义</p></li><li><p>类体中一般使用对象字面量简写形式定义方法，方法间是<strong>不用逗号分隔的</strong></p></li><li><p>关键字<code>constructor</code>用于定义类的构造函数，但<strong>实际定义的函数并不叫<code>constructor</code><strong>。<code>class</code>声明语句会定义一个新变量（名称为类名），并</strong>将这个特殊构造函数的值赋给该变量</strong>。</p></li><li><p>与函数定义表达式类似，也有类定义表达式（不常用）</p></li><li><p>即使没有<code>use strict</code>指令，类体中所有代码默认处于严格模式</p></li><li><p>类声明<strong>不会“提升”</strong></p></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>把<code>static</code>关键字放在方法声明前面可以定义静态方法，作为<strong>构造函数而非原型对象的属性</strong>定义的。</p><h3 id="获取方法、设置方法及其他方法的方法"><a href="#获取方法、设置方法及其他方法的方法" class="headerlink" title="获取方法、设置方法及其他方法的方法"></a>获取方法、设置方法及其他方法的方法</h3><p>在<code>class</code>体内，对象字面支持的所有间歇方法定义语法都可以在类体中使用，包括获取方法、设置方法及其他方法的方法</p><h3 id="公有、私有和静态字段"><a href="#公有、私有和静态字段" class="headerlink" title="公有、私有和静态字段"></a>公有、私有和静态字段</h3><p>拓展类语法以支持定义实例和静态标准化过程还在继续，目前可以这样定义字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>&#123;</span><br><span class="line">    len = <span class="number">0</span></span><br><span class="line">    size = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有实例字段则需要在字段名声明前带<code>#</code>前缀，私有字段对类体外部代码不可见、不可访问（因此无法修改），只能在类内部访问，可以通过获取函数实现读取。但需要在类体中声明私有字段后，才可以通过<code>this</code>访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>&#123;</span><br><span class="line">    #len = <span class="number">0</span></span><br><span class="line">    size = <span class="number">10</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">len</span>()&#123;<span class="keyword">return</span> <span class="variable language_">this</span>.#len;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态字段则是在声明字段名前加上<code>static</code>关键字</p><h2 id="为已有类添加方法"><a href="#为已有类添加方法" class="headerlink" title="为已有类添加方法"></a>为已有类添加方法</h2><p><code>JavaScript</code>基于原型的继承机制是动态的，即对象所继承的原型对象的属性发生变化后，则<strong>对象继承修改后的属性</strong>。理论上我们可以通过修改原型对象，来增强<code>JavaScript</code>类（但一般不推荐在内置类型的原型上添加方法，可能造成兼容性问题）</p><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><h3 id="子类与原型"><a href="#子类与原型" class="headerlink" title="子类与原型"></a>子类与原型</h3><p>定义子类时，让其通过父类的<code>prototype</code>属性创建一个对象，就能通过原型实现继承了，但<strong>这样并不能支持子类调用父类的方法和构造函数</strong></p><h3 id="通过extends和super创建子类"><a href="#通过extends和super创建子类" class="headerlink" title="通过extends和super创建子类"></a>通过<code>extends</code>和<code>super</code>创建子类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArr</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span>&#123;</span><br><span class="line">    <span class="comment">/*类体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种声明类的方式支持使用<code>super</code>关键字调用父类构造函数和父类的方法。<code>super</code>关键字很像<code>this</code>，它引用当前对象，但允许访问父类定义的被覆盖的方法。</p><h3 id="委托而不是继承"><a href="#委托而不是继承" class="headerlink" title="委托而不是继承"></a>委托而不是继承</h3><p>在你的类中创建另一个类的实例，并在需要时委托该实例去做你希望的事反而比新创建一个类更方便，这种策略也被称为“组合”（能组合就不继承）</p><h3 id="类层次与抽象类"><a href="#类层次与抽象类" class="headerlink" title="类层次与抽象类"></a>类层次与抽象类</h3><p>尽管使用组合代替继承是一个良好的准则，但有些情况仍需要多级子类来实现。<code>JavaScript</code>没有正式定义抽象方法或抽象类的语法，但我们可以手动模拟定义抽象类以及多个子类。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块化编程的目的是能够用不同的作者和来源不同的代码模块组装成大型程序，并正常运行。</p><h2 id="基于类、对象和闭包的模块"><a href="#基于类、对象和闭包的模块" class="headerlink" title="基于类、对象和闭包的模块"></a>基于类、对象和闭包的模块</h2><p>类之所以称为模块，是因为对象是模块：<strong>给对象添加属性不影响程序的全局命名空间，也不影响其他对象的属性</strong>。但是基于类和对象实现模块的方式<strong>不支持隐藏内部实现细节</strong>。但<strong>闭包和立即调用函数表达式</strong>实现模块可以将实现细节和辅助函数隐藏。（隐藏指的是对模块使用用户不可见）</p><h3 id="基于闭包的自动模块化"><a href="#基于闭包的自动模块化" class="headerlink" title="基于闭包的自动模块化"></a>基于闭包的自动模块化</h3><p>编写<code>JavaScript</code>代码文件并手动转为立即调用表达式，来转为模块，这一过程是可预见的、重复的。</p><p>可以想象有一个工具，它可以自动解析代码，<strong>将每个文件的内容包装在一个立即调用表达式中</strong>，还可以跟踪每个函数的返回值，并将所有内容<strong>拼接为一个大文件</strong>，这样就能实现自动模块化</p><h2 id="Node中的模块"><a href="#Node中的模块" class="headerlink" title="Node中的模块"></a><code>Node</code>中的模块</h2><p>与浏览器不同，编写<code>Node</code>程序时，每个文件都是一个拥有私有命名空间的独立模块。除非文件主动导出，且被另一模块显式导入，否则是不可用的。</p><p><code>Node</code>模块使用<code>require()</code>函数导入其他模块，使用<code>module.exports</code>或<code>Exports</code>对象的属性导出公共<code>API</code></p><h3 id="Node的导出"><a href="#Node的导出" class="headerlink" title="Node的导出"></a><code>Node</code>的导出</h3><p><code>Node</code>定义了一个全局对象<code>exports</code>对象，这个对象始终有定义，如果要编写导出一个或多个值的<code>Node</code>模块，可以给<code>export</code>设置属性或直接设置<code>module.export</code>对象。他们两引用的是同一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>)=&gt;x+y;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">nav</span> = (<span class="params">x</span>)=&gt;-x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">export</span>.<span class="property">sum</span> = sum</span><br><span class="line"><span class="keyword">export</span>.<span class="property">nav</span> = nav</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;sum, nav&#125;</span><br></pre></td></tr></table></figure><h3 id="Node的导入"><a href="#Node的导入" class="headerlink" title="Node的导入"></a><code>Node</code>的导入</h3><p><code>Node</code>模块通过调用<code>require()</code>函数导入其他模块，该函数的参数是要导入的模块的名称，返回值是该模块导出的值</p><p>需要注意，导入<code>Node</code>内置的模块或通过包管理器安装到系统上的模块，可以直接写该模块名导入。若是导入自己代码中的模块，则需要写相对路径和模块文件名（可以省略后缀名<code>.js</code>，但不推荐）。</p><p>然后，取得调用<code>require()</code>的返回值，可以导入整个对象，也可以使用解构赋值导出指定属性。</p><h2 id="ES6中的模块"><a href="#ES6中的模块" class="headerlink" title="ES6中的模块"></a><code>ES6</code>中的模块</h2><p><code>ES6</code>为<code>JavaScript</code>添加了<code>import</code>和<code>export</code>关键字，意味着将模块作为核心语言特性来支持。本质和<code>Node</code>模块没有区别，<strong>只是在语法上有些不同</strong>。</p><p>此外，<code>ES6</code>模块和<code>JavaScript</code>普通脚本有很大区别，前者的每个文件都有自己的上下文，且自动应用严格模式。</p><h3 id="ES6的导出"><a href="#ES6的导出" class="headerlink" title="ES6的导出"></a><code>ES6</code>的导出</h3><ul><li>普通导出，只需要在变量&#x2F;函数&#x2F;类的声明前加上<code>export</code>关键字即可</li><li>导出多个，在文件末尾添加一句：<code>export &#123; /*逗号分隔的标识符列表*/ &#125;</code></li><li>只导出一个，将<code>export</code>替换为<code>export default</code>即可。而且默认导出支持任意表达式，包括匿名函数表达式、对象字面量等。这种情况下，如果后面接花括号<code>&#123;&#125;</code>包括起来的代码，会被认为是导出对象字面量。</li></ul><p>注意<code>export</code>关键字只能出现在<code>JavaScript</code>代码的顶层，而不能在循环、函数、类当中</p><h3 id="ES6的导入"><a href="#ES6的导入" class="headerlink" title="ES6的导入"></a><code>ES6</code>的导入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最通用的导入写法</span></span><br><span class="line"><span class="keyword">import</span> 标识符 <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="comment">/*标识符列表*/</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 全部一次性导入到一个对象当中</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> 标识符 <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 导入没有返回值的模块，一般是只需要运行该模块中的内容时，会这样做。因为首次导入模块会运行一次（再导入则什么都不做）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./xxx.js&quot;</span></span><br></pre></td></tr></table></figure><ul><li>导出的值会变成当前模块指定的标识符的值，它是一个常量。</li><li>导入语句会被自动<strong>提升</strong>到顶部，不允许出现在类、函数、循环体等语句当中，只能出现在模块顶部。</li><li>导入到模块以字符串字面量形式给出，但不能出现在反引号中。且写法一定得是相对路径、绝对路径、<code>URL</code>中的一种，而不能直接写一个文件名，否则会找不到。即使是同一目录下也不能写成类似<code>xxx.js</code>，而要写成<code>./xxx.js</code></li></ul><h3 id="导入和导出时重命名"><a href="#导入和导出时重命名" class="headerlink" title="导入和导出时重命名"></a>导入和导出时重命名</h3><p>当遇到命名冲突，或想要精简命名，又或导入默认导出的情况时，可以配合<code>as</code>关键字，来<strong>为导入&#x2F;导出的标识符进行重命名</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum <span class="keyword">as</span> sss&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认导出，则另外再配合default关键字</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> sss&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">sum <span class="keyword">as</span> sss</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再导出"><a href="#再导出" class="headerlink" title="再导出"></a>再导出</h3><p>当多个文件想要同时导入相同的几个模块时，有可能造成代码体积膨胀。所以<code>ES6</code>模块支持<strong>将导入和导出二合一</strong>，通过<code>export from</code>两个关键字构造一条”再导出”语句：<strong>从另一文件导入后作为本模块的导出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常做法</span></span><br><span class="line"><span class="keyword">export</span> &#123;mean&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 导入/导出所有</span></span><br><span class="line"><span class="keyword">export</span> * frmo <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;mean <span class="keyword">as</span> average&#125; frmo <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 导入默认模块并导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> mean&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 作为当前模块默认导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;mean <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"><span class="comment">// 导入默认并作为默认导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="在网页中使用JavaScript模块"><a href="#在网页中使用JavaScript模块" class="headerlink" title="在网页中使用JavaScript模块"></a>在网页中使用<code>JavaScript</code>模块</h3><p>必须通过<code>&lt;script type=&#39;module&#39;&gt;</code>标签告诉浏览器你的代码是一个模块。<code>ES6</code>模块的一个<strong>核心特性是每个模块的导入都是静态的</strong>，意味着只要有一个起始模块，浏览器就可以加载它导入的所有模块。</p><p>支持<code>&lt;script type=&#39;module&#39;&gt;</code>的浏览器也必然支持<code>&lt;script nomodule&gt;</code>，这样就能很好解决某些浏览器不兼容<code>ES6</code>模块的问题了。因为支持该标签的浏览器会忽略带有<code>nomodule</code>属性的脚本，而不支持该标签的浏览器会因为不认识<code>nomodule</code>属性，而直接忽略，并运行代码。综上，这样做可以实现用<code>&lt;script type=&#39;module&#39;&gt;</code>来加载现代<code>JavaScript</code>代码。</p><p>由于<code>&lt;script type=&#39;module&#39;&gt;</code>增加了跨源加载的限制，其带来的副作用之一是<strong>不能在开发模式下使用<code>file:URL</code>来测试<code>ES6</code>模块</strong>。为此，需要启动一个静态<code>Web</code>服务器来测试。</p><h3 id="通过import-动态导入"><a href="#通过import-动态导入" class="headerlink" title="通过import()动态导入"></a>通过<code>import()</code>动态导入</h3><p><code>import()</code><strong>是一个操作符，圆括号是这个操作符语法的必须部分</strong>，它的参数应该是一个模块标识符，跟静态<code>import</code>指令中的完全一样，只不过没有字符串字面量的限制。</p><p>调用<code>import()</code>会<strong>返回一个期约对象</strong>，表示加载和运行指定模块的异步过程，加载完成后期约兑现，返回模块的导出对象，需要搭配<code>then</code>或<code>async await</code>来使用。合理地使用它，可以实现将比较大的文件拆分，按需加载。</p><h3 id="import-meta-url"><a href="#import-meta-url" class="headerlink" title="import.meta.url"></a><code>import.meta.url</code></h3><p><code>import.meta</code>引用了一个对象，包含当前执行模块的元数据，其中<code>url</code>属性是加载模块时使用的<code>URL</code>。可以配合使用来加载与模块位于同一（或相对）目录的其他资源。</p><h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>可迭代对象及其相关的迭代器、生成器都是<code>ES6</code>的新特性</p><h2 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h2><p>理解<code>JavaScript</code>中的迭代，必须理解3个不同的类型，首先是<strong>可迭代对象</strong>（类似<code>Array Set</code>等）。其次是<strong>迭代器对象</strong>，用于执行迭代。最后是<strong>可迭代对象</strong>，保存每次迭代的结果，三者定义如下：</p><ul><li><p>可迭代对象指的是任何<strong>具有专用迭代器方法</strong>，且该方法返回迭代器对象的对象</p></li><li><p>迭代器对象是指任何<strong>具有<code>next()</code>方法</strong>，且该方法返回迭代结果对象的对象</p></li><li><p>迭代结果对象是<strong>具有属性<code>value</code>和<code>done</code>的对象</strong></p></li></ul><p>迭代一个可迭代对象的过程如下：</p><ol><li>调用其迭代器方法，获得一个迭代器对象</li><li>然后重复调用这个迭代器对象的<code>next()</code>方法</li><li>直至返回<code>done</code>属性为<code>true</code>的迭代结果对象</li></ol><blockquote><p>迭代器方法没有使用惯用名称，而是使用了<code>Symbol.iterator</code>作为名字</p><p>内置可迭代数据类型的迭代器对象本身也是可迭代的，即他们的迭代器对象本身也有一个名为<code>Symbol.iterator</code>的方法，返回他们自己</p></blockquote><h2 id="实现可迭代对象"><a href="#实现可迭代对象" class="headerlink" title="实现可迭代对象"></a>实现可迭代对象</h2><p>只要你的数据类型表示某种可迭代的结构，就应该考虑把他们实现为可迭代对象。</p><p><strong>创建可迭代对象</strong>，除了使用生成器，可以通过给类在定义基础的构造函数和方法上，再<strong>定义<code>[Symbol.iterator]()&#123;/*返回迭代器对象*/&#125;</code>方法</strong>，其中迭代器对象<strong>一定要包含<code>next()</code>方法返回迭代结果</strong>，<strong>可选包含</strong><code>[Symbol.iterator]()&#123;return this;&#125;</code>表示让迭代器本身也可迭代。</p><p>定义返回可迭代值的函数也同样重要且常用，原理是一样的，让函数返回一个可迭代的迭代器对象即可。</p><p><strong>“关闭”迭代器：<code>return()</code>方法</strong>：</p><p>尽管<code>next()</code>很常用，但是在某些情况，比如需要提前终止迭代（文件异常关闭、主动<code>break</code>等），此时解释器会检查迭代器对象是否有<code>return()</code>方法，有的话就会调用它（不传参数），那么此时就有机会处理一些必要的事务，比如关闭文件、保存数据、释放内存等等。该<code>return()</code>方法必须返回一个迭代结果对象，但其属性会被忽略，且返回非对象会导致报错。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器可以极大地简化自定义迭代器的创建，特别适合要迭代的值是某个计算结果的场景。</p><p>创建生成器，首先要定义一个生成器函数，该函数在语法上同普通的<code>javaScript</code>函数，但关键字<strong>需要多加一个<code>*</code>号，加在<code>function</code>之后，函数名之前</strong>。</p><p><strong>调用生成器函数</strong>并<strong>不会实际执行</strong>函数体的代码，而是<strong>得到一个生成器对象，同时也是一个迭代器</strong>，调用其<code>next()</code>方法才会导致生成器函数的函数体<strong>从头（或当前位置）</strong>开始，执行直至<strong>遇到一个<code>yield</code>语句停止</strong>。<code>yield</code>也是<code>ES6</code>的新特性，类似<code>return</code>，<strong>该语句的值</strong>会成为调用<strong>迭代器的<code>next()</code>方法的返回值</strong>。</p><h3 id="生成器示例"><a href="#生成器示例" class="headerlink" title="生成器示例"></a>生成器示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*斐波那契数列*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">feibonaqi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="number">0</span>,y=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">yield</span> y;</span><br><span class="line">        [x,y]=[y,x+y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//注意不要用...来调用该函数，否则会无限循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fi</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> f <span class="keyword">of</span> <span class="title function_">feibonaqi</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(n--&lt;=<span class="number">0</span>)<span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//在for/of中使用即可</span></span><br></pre></td></tr></table></figure><h3 id="yield-与递归生成器"><a href="#yield-与递归生成器" class="headerlink" title="yield*与递归生成器"></a><code>yield*</code>与递归生成器</h3><p><code>yield*</code>和<code>yield</code>类似，它不是会送一个值，而是<strong>迭代</strong>可迭代对象并回送<strong>得到的每个值</strong>，两者相同的就是<strong>只能在生成器函数中使用</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funtion* <span class="title function_">sequence</span>(<span class="params">...iterables</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> iterable <span class="keyword">of</span> iterables)&#123;</span><br><span class="line">        <span class="keyword">yield</span>* iterable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">oneDigitPrimes</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">[...<span class="title function_">sequence</span>(<span class="string">&quot;abc&quot;</span>,<span class="title function_">oneDigitPrimes</span>())] <span class="comment">// =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,2,3,5]</span></span><br></pre></td></tr></table></figure><p><code>yield*</code>可以用来迭代任何可迭代对象，包括通过生成器生成的，意味着我们可以编写递归生成器。</p><h2 id="高级生成器特性"><a href="#高级生成器特性" class="headerlink" title="高级生成器特性"></a>高级生成器特性</h2><h3 id="生成器返回函数的值"><a href="#生成器返回函数的值" class="headerlink" title="生成器返回函数的值"></a>生成器返回函数的值</h3><p>生成器函数也可以有<code>return</code>返回值，但只会在手工迭代时显式调用<code>next()</code>才能看到，其他情况则会被忽略。 </p><h3 id="yield表达式的值"><a href="#yield表达式的值" class="headerlink" title="yield表达式的值"></a><code>yield</code>表达式的值</h3><p><code>yield</code>关键字后面的表达式的值会成为调用<code>next()</code>方法时返回值。</p><p>而<code>yield</code>语句<strong>本身也是有值</strong>的，该值是<strong>下一次</strong>调用<code>next</code>方法时，传给<code>next()</code>的参数值。也就是说，只有<strong>再次</strong>调用<code>next</code>，<strong>才能得到且访问</strong>到上一次暂停处<code>yield</code>语句的值。</p><p>生成器和调用者是两个<strong>独立</strong>的执行流，它们<strong>交替传值</strong>（和控制权）。</p><h3 id="生成器的return-和throw-方法"><a href="#生成器的return-和throw-方法" class="headerlink" title="生成器的return()和throw()方法"></a>生成器的<code>return()</code>和<code>throw()</code>方法</h3><p>对与生成器，我们无法定义一个<code>return()</code>方法，但我们可以在生成器函数中使用<code>try/throw/finally</code>语句块中作必要的清理工作，生成函数<strong>内置</strong>的<code>return()</code>方法<strong>会保证</strong>这些清理代码运行。</p><p>而且，当生成器函数中使用<code>yield*</code>回送其它可迭代对象时，<strong>调用生成器的</strong><code>next()</code>方法会<strong>导致调用该可迭代对象的</strong><code>next()</code>方法，<strong>同理</strong><code>return()</code>和<code>throw()</code>也会相应被调用（如果该可迭代对象有定义这两个方法的话）。</p><h1 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a>异步<code>JavaScript</code></h1><p>异步编程在计算机领域中是司空见惯的，特别是网络应用。<code>JavaScript</code>中提供了三个特性（期约、<code>async/await</code>语法糖关键字、<code>for/await</code>语法糖），让异步代码的编写更加容易。</p><h2 id="使用回调的异步编程"><a href="#使用回调的异步编程" class="headerlink" title="使用回调的异步编程"></a>使用回调的异步编程</h2><p>在<strong>最基本</strong>的层面，<code>JavaScript</code>异步编程是基于<strong>回调实现</strong>的。回调就是函数（某些情况也是一种行为），它可以传给其他函数，而其他函数会在满足某个条件（或某个事件发生）时，调用（“回调”）这个函数。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>setTimeout()</code>函数算是最简单的异步操作了，在一定时间后运行某些代码。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>客户端<code>JavaScript</code>编程几乎都是事件驱动的，浏览器<strong>响应</strong>用户的动作，<strong>生成事件</strong>，然后在特定上下文中为特定类型时间<strong>注册回调函数</strong>，当事件发生时就<strong>调用</strong>这些函数。这些回调函数叫做事件处理程序或事件监听器，是通过<code>addEventListener()</code>注册的。</p><h3 id="网络事件"><a href="#网络事件" class="headerlink" title="网络事件"></a>网络事件</h3><p>网络请求也是一种常见的异步操作，大多数<code>Web API</code>都支持在网络请求对象上调用<code>addEventListener()</code>来定义事件处理程序</p><h3 id="Node中的回调与事件"><a href="#Node中的回调与事件" class="headerlink" title="Node中的回调与事件"></a><code>Node</code>中的回调与事件</h3><p><code>Node.js</code>服务端<code>JavaScript</code>环境底层就是异步的，定义了很多使用回调和事件的<code>API</code>，比如读取文件、读取网络请求的内容</p><h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><p>期约是一种为简化异步编程而设计的核心语言特性，它是一个<strong>对象，表示异步操作的结果</strong>。这个结果可能就绪，也可能未就绪，也就是说我们<strong>无法同步拿到结果</strong>，但是期约<code>API</code>支持<strong>在期约对象上注册</strong>事件处理程序，也属于处理回调的一种方式。</p><p>期约可以<strong>避免多层嵌套</strong>的回调，让异步编程易于阅读，同时<strong>标准化了异步错误处理</strong>。</p><h3 id="使用期约"><a href="#使用期约" class="headerlink" title="使用期约"></a>使用期约</h3><p>期约对象有一个实例方法叫<code>then()</code>，是期约独有的特性。该方法<strong>类似</strong><code>addEventListener()</code>，接收事件处理程序作为参数，并在<strong>预期计算完成后被调用</strong>，但<strong>只会被调用一次</strong>，即使通过<code>then</code>注册了多次同一个函数。</p><blockquote><p>期约有几种状态：得到兑现、被拒绝、既未兑现也为被拒绝时的<strong>待定</strong>状态、得到兑现或被拒绝时的<strong>落定</strong>状态</p></blockquote><p><strong>使用期约处理错误：</strong></p><p>对期约而言，异步计算<strong>结果</strong>会在正常结束后传给<code>then()</code>的第<strong>一</strong>个参数的函数，而把<strong>异常</strong>传给<code>then()</code>的第<strong>二</strong>个参数的函数，但一般<strong>很少</strong>这样用，而<strong>更多使用<code>catch()</code><strong>，这个方法只是对调用<code>then()</code>时以<code>null</code>作为第一个参数，以指定错误处理函数作为第二个参数的一种</strong>简写形式</strong>。</p><h3 id="期约链"><a href="#期约链" class="headerlink" title="期约链"></a>期约链</h3><p>期约有一个最重要的优点，就是以线性<code>then()</code>方法<strong>调用链的形式</strong>表达一连串异步操作，而<strong>无须</strong>把每个操作<strong>嵌套</strong>在前一个操作的内部， 也就是说我们可以在一个表达式中调用多个方法，也被称为方法链，以一个期约为例：<code>fetch().then().then()</code>。</p><p>我们之前提到的方法链中，都只有一个对象，每个方法均返回处理后的对象本身。但是基于期约的方法链略有不同，每个<code>then()</code>会<strong>返回一个新的期约对象</strong>，并在传给<code>then()</code>的函数<strong>执行完才会兑现</strong>。</p><p><code>then()</code>方法会把我们的回调函数保存在某个地方，并<strong>返回一个新期约，并将该回调函数的返回值用于兑现</strong>这个新期约。</p><h3 id="解决期约"><a href="#解决期约" class="headerlink" title="解决期约"></a>解决期约</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c1</span>(<span class="params">response</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p4 = response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c2</span>(<span class="params">profile</span>)&#123;</span><br><span class="line">    <span class="title function_">displayUserInfo</span>(profile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">fetch</span>(<span class="string">&quot;/api/user/info&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(c1)</span><br><span class="line"><span class="keyword">let</span> p3 = p2.<span class="title function_">then</span>(c2)</span><br></pre></td></tr></table></figure><p>我们将上一小节的期约链例子中的函数单独写出来，会更直观一些。我们发现，除了<code>p1 p2 p3</code>三个期约，函数<code>c1</code>返回的也是一个期约（假设返回值为<code>v</code>），并用于兑现期约<code>p2</code>。</p><p>此时，如果<code>v</code>未兑现，就会以期约的类型返回，此时<code>p2</code>会得到一个<strong>期约类型的返回值</strong>，那么称<code>p2</code>以<code>v</code>这个值<strong>得到解决</strong>。如果过段时间，<code>v</code>得到兑现，以一个<strong>非期约类型</strong>的值得以解决时，则<code>p2</code>同样以相同的值<strong>兑现</strong>。同理，若<code>v</code>被拒绝，则<code>p2</code>会以相同的理由被拒绝。这就是期约得到了<strong>“解决”</strong>的意思，即完全拒绝于另一个期约。</p><h3 id="再谈期约和错误"><a href="#再谈期约和错误" class="headerlink" title="再谈期约和错误"></a>再谈期约和错误</h3><p>细致的错误处理在异步编程中非常重要，<code>.catch()</code>作为<code>.then()</code>的特殊简写形式，让异常捕获的代码可读性更高。<code>.catch()</code>只有在上一<strong>环</strong>（不是指上一<strong>个</strong>）的回调中抛出错误时<strong>才会被调用</strong>，否则会被忽略，之前回调返回的值会成为下一个<code>.then()</code>的回调的输入。<code>.catch()</code>回调捕获到错误会<strong>使之停止在期约链中向下</strong>传递，同时<strong>也可以抛出新</strong>错误。如果<code>.catch()</code>回调<strong>正常返回</strong>，则<strong>返回值就会用于</strong>解决或兑换<strong>与之关联</strong>的期约（比如下一个<code>.then()</code>或<code>.catch()</code>回调）</p><p>同时，期约对象也定义了一个<code>.finally()</code>方法，类似<code>try/catch</code>中的<code>finally</code>子句，会<strong>在期约落定时调用</strong>，而且<code>finally()</code>的回调<strong>不需要参数</strong>，若该回调发生错误，则<code>finally()</code>期约会被以<strong>相同的错误理由被拒绝</strong>。</p><h3 id="并行期约"><a href="#并行期约" class="headerlink" title="并行期约"></a>并行期约</h3><p>函数<code>Promise.all()</code>可以做到并行多个异步操作，它接收一个<strong>期约对象的数组作为输入，返回一个期约</strong>，当遇到输入期约中某个被拒绝了，会<strong>立即返回被拒绝的期约</strong>，即使输入期约中还有的是待定状态。否则，返回的期约会以<strong>每个输入期约的兑现值</strong>的数组兑现。注意，输入输入组<strong>可以包含非期约值</strong>，会被认为已兑现期约的值，且会被原封不动地复制到输出数组中。</p><p>函数<code>Promise.allSettled()</code>类似，也能实现并行多个异步操作，但它会<strong>等所有输入期约全部落定后兑现</strong>，返回的期约解决为一个<strong>对象数组，数组元素分别对应输入期约</strong>，并且视情况包含<code>status value</code>属性或<code>status reason</code>属性，表示输入期约正常兑现和值，或被拒绝和拒绝理由。</p><p>若想在输入的期约数组中，有一个期约兑现或拒绝则立马兑现或拒绝，则可以使用<code>Promise.race()</code> </p><h3 id="创建期约"><a href="#创建期约" class="headerlink" title="创建期约"></a>创建期约</h3><p><strong>基于其它期约的期约</strong>：</p><p>顾名思义，调用一个返回期约的函数的<code>.then()</code>方法，就可以返回一个新期约了</p><p><strong>基于同步值的期约</strong>：</p><p>静态方法<code>Promise.resolve() Promise.reject()</code>接收一个值作为参数，并在当前<strong>同步代码块运行结束后立即</strong>返回一个会立即（但异步）以该值<strong>兑现&#x2F;作为理由拒绝</strong>的期约。若传入的值也是一个期约，则返回的期约会被<strong>立即解决</strong>，但得等到参数期约兑现&#x2F;被拒绝后才会兑现&#x2F;被拒绝。</p><p>适用场景之一就是编写一个<code>API</code>，实际执行的计算属于同步代码，但又想从函数回期约。</p><p><strong>从头开始创建期约</strong>：</p><p>调用<code>Promise()</code>构造函数，给它传入一个函数作为唯一参数，该函数需要写成接收两个参数，这两个参数需要按惯例命名为<code>resolve reject</code>。构造函数会同步调用这两个参数，并为这两个参数传入对应的函数值（一般是非期约值），并以该函数值作为被解决&#x2F;被拒绝的值。</p><p><strong>串行期约</strong>：</p><p>有两种思路，一是<strong>动态创建期约链</strong>，需要时就往之前的期约<strong>链上加一个</strong><code>.then()</code>，调用返回一个期约即可；二是使用<strong>伪递归</strong>，递归创建<strong>上一级期约回调中的期约</strong>，合理设置返回条件和中间变量保存结果即可，原理就是顶级期约一定会等回调被兑现&#x2F;拒绝才会相应兑现&#x2F;拒绝的。</p><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a><code>async</code>和<code>await</code></h2><p>这是<code>ES2017</code>新增的两个关键字，极大简化了期约的使用，甚至可以像编写同步代码一样，感受不到期约的存在了。但是理解期约的工作原理仍为重要。</p><h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a><code>await</code>表达式</h3><p><code>await</code>关键字接收一个期约并将其转化为一个返回值或一个抛出的异常，该表达式会一直等到期约落定。并且任何使用<code>await</code>的代码本身都是异步的，不用担心会在期约落定之前被阻塞。</p><h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a><code>async</code>函数</h3><p><strong>只</strong>能在以<code>async</code>关键字声明的函数<strong>内部</strong>使用<code>await</code>关键字，且这样的函数的<strong>返回值将是一个期约</strong>。如果<code>async</code>函数会正常返回，那么作为该函数真正返回值的期约对象<strong>将解决为这个明显的返回值</strong>。</p><p>可以对<strong>任何</strong>函数使用<code>async</code>关键字，包括函数表达式、箭头函数。</p><h3 id="等候多个期约"><a href="#等候多个期约" class="headerlink" title="等候多个期约"></a>等候多个期约</h3><p>使用<code>await</code>的连续调用相同函数的语句，是并发执行的。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>以<code>async</code>声明的函数，可以<strong>理解为它被包装在一个返回期约的包装函数中</strong>。子函数则相当于<strong>传给被<code>await</code>标记的期约的<code>then()</code>方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;<span class="comment">/*函数体*/</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// async声明的函数可以理解为以下代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>((<span class="keyword">function</span>(<span class="params">x</span>)&#123;<span class="comment">/*函数体*/</span>&#125;)(x))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h2><p>期约只适合单次运行的异步计算，不适合与重复性异步事件来源一起使用，也就是无法用于连续的异步事件。</p><h3 id="for-await循环"><a href="#for-await循环" class="headerlink" title="for/await循环"></a><code>for/await</code>循环</h3><p>与常规的<code>await</code>表达式类似，<code>for/await</code>循环也是基于期约的，只是把<code>await</code>调用内置在了循环中，从而让代码更加整洁。换句话说，该异步迭代器会产生一个期约，<code>for/await</code>循环等待该期约兑现，<strong>将兑现值赋给循环变量</strong>，然后执行循环体。</p><p>以下两段代码是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises)&#123;</span><br><span class="line">    response = <span class="keyword">await</span> promise;</span><br><span class="line">    <span class="title function_">handle</span>(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> response <span class="keyword">of</span> promises)&#123;</span><br><span class="line">    <span class="title function_">handle</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>异步迭代器和之前讲的常规迭代器非常类似，但有两点不同：</p><ul><li>异步可迭代对象以符号名字<code>Symbol.asyncIterator</code>实现一个方法。<code>for/await</code>兼容常规迭代器，但仍会优先尝试<code>Symbol.asyncIterator</code>方法</li><li>异步迭代器的<code>next()</code>方法<strong>返回一个期约，解决为迭代器对象结果</strong>。</li></ul><h3 id="异步生成器"><a href="#异步生成器" class="headerlink" title="异步生成器"></a>异步生成器</h3><p>异步生成器既有异步函数的特点（比如<code>async</code>声明），也有生成器的特点（比如使用<code>yield</code>），使用<code>async function*</code>进行声明。</p><h3 id="实现异步迭代器"><a href="#实现异步迭代器" class="headerlink" title="实现异步迭代器"></a>实现异步迭代器</h3><p>除了用异步生成器实现异步迭代器，还可以直接实现。这需要定义一个包含<code>Symbol.asyncIterator()</code>方法的对象，该方法要返回一个包含<code>next()</code>方法的对象，而这个<code>next()</code>方法要返回解决为一个迭代器结果对象的期约。                                                                             </p><p>异步迭代器的优点 是它允许我们表示<strong>异步事件流</strong>或<strong>数据流</strong>。</p><p>异步迭代器的编写难度，一部分取决于它的异步性来源。任何异步迭代器方法都必须能在<strong>内部维护一个期约队列</strong>，让这些期约按照异步事件发生的顺序<strong>依次解决</strong>。</p><h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><p>一些<code>JavaScript</code>特性可以宽泛地归类为“元编程”特性。如果说常规编程是写代码去操作数据，那么元编程就是<strong>写代码去操作其他代码</strong>。</p><h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p> <code>JavaScript</code>属性有名字和值，但每个属性也有3个关联的特性，用于指定指定属性的行为：</p><ul><li><code>writable</code>可写</li><li><code>enumerable</code>可枚举（在<code>for/in</code>和<code>Objects.keys()</code>枚举）</li><li><code>configurable</code>可配置（是否可以删除、修改属性）</li></ul><p>不仅如此，属性的值（<code>value</code>）也可以看成特性，这样每个<code>JavaScript</code>属性都有<strong>4个特性</strong>。但是，<strong>访问器属性</strong>较为特殊，它没有<code>value</code>和<code>writable</code>特性，但<strong>相应有<code>get</code>、<code>set</code>特性</strong>（这两个特性是函数值）</p><p>调用<code>Object.getOwnPropertyDescriptor()</code>可以获得特定对象的某个属性的<strong>属性描述符（拥有与它所描述的属性的特性相同的属性名）</strong>，该方法第一个参数为指定的对象，第二个为属性名（字符字面量类型）。注意，该方法<strong>只对自有属性有效</strong>，不能查询继承属性。</p><p>调用<code>Object.defineProperty()</code>方法可以<strong>设置</strong>属性的特性或<strong>创建</strong>一个<strong>具有指定特性的属性</strong>。该方法第一个参数是指定对象，第二个参数是属性名，第三个是属性描述符对象（省略的属性默认为<code>false</code>或<code>undefined</code>，或保持不变）。</p><p><strong>一次性</strong>创建或修改<strong>多</strong>个属性，则可以调用<code>Object.defineProperties()</code>，第一参数是指定对象，第二个参数是包含<strong>“属性名:属性描述符”</strong>键值对的对象。</p><p><code>Object.Create()</code>接收第二个可选参数，和<code>Object.defineProperties()</code>的第二个参数一样。      </p><blockquote><p>可修改和可配置是不同的，不可修改但是可配置，一样能进行修改。</p><p><code>Object.assign()</code>只复制可枚举属性和属性值，但不复制属性的特性，需要特别注意一下。</p></blockquote><h2 id="对象的可拓展能力"><a href="#对象的可拓展能力" class="headerlink" title="对象的可拓展能力"></a>对象的可拓展能力</h2><p> 定义：是否可以给对象<strong>添加新</strong>属性（普通<code>JavaScript</code>对象默认是可拓展的）</p><p><code>Object.isExtensible()</code>接收一个对象作为参数，用于<strong>确定</strong>该对象<strong>是否可拓展</strong>。</p><p><code>Object.preventExtensions()</code>接收一个对象作为参数，让该对象不可拓展，这个过程是<strong>不可逆</strong>的。（注意，这个函数只影响对象<strong>本身</strong>的<strong>可拓展能力</strong>，但是可以<strong>正常继承</strong>。也就是说给一个不可拓展对象<strong>的原型</strong>添加新属性是可以的，并且该不可拓展对象<strong>仍可以继承</strong>这些新属性）</p><p><code>Object.seal()</code>不仅可以让<strong>对象</strong>不可拓展，也会让<strong>对象的</strong>所有<strong>自有属性</strong>不可拓展。不过，可写的已有属性仍可写。<code>Object.isSealed()</code>用于确定对象是否封存。</p><p><code>Object.freeze()</code>不仅可以让<strong>对象</strong>不可拓展，也会它的<strong>属性不可配置</strong>，还会把对象的所有<strong>自有</strong>属性<strong>变成只读</strong>的。但<strong>不</strong>会影响访问器属性。<code>Object.isFrozen()</code>可以确定对象是否被冻结</p><p>注意，在提到<code>seal() freeze()</code>都特别加重了“自有属性”，这是这两个方法的关键：只影响传给自己（这两个方法）的对象，而不影响对象的原型。另外，加上<code>preventExtensions()</code>，他们全都返回传给它们的对象，能方便地支持嵌套使用。</p><h2 id="prototype特性"><a href="#prototype特性" class="headerlink" title="prototype特性"></a><code>prototype</code>特性</h2><p>对象的<code>prototype</code>特性指定对象从哪里继承属性，一般被称为对象的<strong>原型</strong>，而不说是对象的<code>prototype</code>特性。特别要注意，当<code>prototype</code>以代码字体出现时，它指的是一个普通对象的属性，而不是<code>prototype</code>特性</p><p>对象的<code>prototype</code>特性是<strong>对象被创建时设定</strong>的，下面是几个常见的<strong>原型设定</strong>方式以及特点：</p><ul><li>使用对象字面量创建对象，则该对象原型是<code>Object.prototype</code></li><li>使用<code>new</code>创建对象，则该对象的原型是该对象的构造函数的<code>prototype</code>属性的值</li><li>使用<code>Object.create()</code>创建的对象，则原型是传给它的第一个参数（可能是<code>null</code>）</li></ul><p>下面是其它有关原型查询、设置和修改的一些接口：</p><ul><li><code>isPrototypeOf()</code>：确定一个对象是不是另一个对象的原型（或原型链上的一环），功能和<code>intanceOf</code>类似</li><li><code>Object.setPrototypeOf()</code>：修改对象原型，一般很少使用</li><li><code>__proto_</code>：暴露对象的<code>prototype</code>属性，已废弃（不推荐使用）</li></ul><h2 id="公认符号"><a href="#公认符号" class="headerlink" title="公认符号"></a>公认符号</h2><p><code>Symbol</code>类型是<code>ES6</code>推出的，旨在拓展<code>JavaScript</code>的同时，也不影响现有<code>Web</code>向后兼容。之前提到的迭代器那一章中，<code>Symbol.iterator</code>就是一个“公认符号”–<code>Symbol()</code>工厂函数的一组属性，同时也是一组符号值，用来控制<code>JavaScript</code>对象和类的某些底层行为</p><h3 id="Symbol-iterator和Symbol-asyncIterator"><a href="#Symbol-iterator和Symbol-asyncIterator" class="headerlink" title="Symbol.iterator和Symbol.asyncIterator"></a><code>Symbol.iterator</code>和<code>Symbol.asyncIterator</code></h3><p>这两个符号可以让类或对象自己变成可迭代对象和异步可迭代对象</p><h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a><code>Symbol.hasInstance</code></h3><p>如果<code>instanceof</code>的<strong>右侧</strong>是一个有<code>[Symbol.hasInstance]</code>方法的<strong>对象</strong>，那么就会以<strong>左侧的值</strong>作为参数来<strong>调用</strong>这个方法并返回这个方法的值，返回值会被转化为布尔值，作为<code>instanceof</code>操作符的值。用处就是可以自己定义<strong>伪</strong>类型对象来做一些<strong>类型检查</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uint8 = &#123;</span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](x)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(x) &amp;&amp; x&gt;=<span class="number">0</span> &amp;&amp; x&lt;=<span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">128</span> <span class="keyword">instanceof</span> uint8 <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a><code>Symbol.toStringTag</code></h3><p>该符号和一般<code>JavaScript</code>对象的<code>toString()</code>方法联系不大。</p><p>但是如果调用内置类型实例的方法相同的<code>Object.prototype.toString().call()</code>就完全不同了，传入一个任意<code>JavaScript</code>值，<strong>都可以获取该值的“类特性”</strong>（这是<code>typeof</code>操作符远不及的），以下是几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>().<span class="title function_">call</span>([])    <span class="comment">// =&gt; &quot;[Object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>().<span class="title function_">call</span>(<span class="string">&quot;&quot;</span>)    <span class="comment">// =&gt; &quot;[Object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>().<span class="title function_">call</span>(<span class="literal">false</span>) <span class="comment">// =&gt; &quot;[Object Boolean]&quot;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code>之后，该方法不仅可以对内置类型的实例生效，也可以用于自己定义的类。</p><p>只需要在类中定义一个属性的符号名为<code>Symbol.toStringTag</code>，这是属性的值就会作为<code>Object.prototype.toString()</code>的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    get [<span class="title class_">Symbol</span>.<span class="title function_">toStringTag</span>()] &#123;<span class="keyword">return</span> <span class="string">&quot;MyClass&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>().<span class="title function_">call</span>(c) <span class="comment">// =&gt; &quot;[Object MyClass]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a><code>Symbol.species</code></h3><p><code>ES6</code>中，我们可以使用<code>class extends</code>关键字来拓展任何<strong>内置</strong>类，同时也包括<strong>继承</strong>有关的规范。比如继承<code>Array</code>，那么调用子类<strong>从父类继承</strong>下来的<code>map slice</code>等方法，<code>ES6</code>规定将（默认）<strong>返回子类的实例</strong>（而不是父类），实现过程如下：</p><ol><li><code>ES6</code>推出后，<code>Array()</code><strong>构造函数</strong>会有一个名字为<code>Symbol.species</code><strong>符号属性</strong></li><li>使用<code>extends</code>创建子类时，<strong>子类构造</strong>函数会从<strong>超类构造</strong>函数继承属性（包括<code>Symbol.species</code>），这是一种<strong>特殊的继承</strong>。</li><li><code>Array</code>的<code>map() slice()</code>等创建并返回新数组的这些方法，在<code>ES6</code>中被修改了部分功能，也就是它们不仅创建一个常规的<code>Array</code>，还（实际上）会调用<code>new  this.constructor[Symbol.species]()</code>创建新数组</li><li>接下来才是<strong>重点</strong>：<ol><li><code>Array[Symbol.species]</code>是一个只读的访问器属性，其获取函数简单地返回<code>this</code>，可以通过<code>defineProperty()</code>来赋值，也可以在定义子类时顺便给重写了。</li><li><strong>子类构造</strong>函数会<strong>继承</strong><code>Array[Symbol.species]</code>的<strong>获取函数</strong>，也被称为“子类构造函数<strong>作为</strong>超类的<strong>物种</strong>，并继承了这个获取函数”</li></ol></li></ol><p>综上可以发现，通过这个机制可以更灵活的创建<code>Array</code>的子类，比如确定<strong>对返回的数组使用哪个构造函数</strong>。但该符号不止用在<code>Array</code>的子类拓展中，其它地方也会被用到，比如定型数组的<code>slice()</code>方法</p><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a><code>Symbol.isConcatSpreadable</code></h3><p>上一小节提到的符号适用于<code>Array</code>的<code>concat filter map slice splice</code>5个方法，这一节将讲到<code>concat()</code>方法，它还会用另一<code>Symbol.isConcatSpreadable()</code>符号来控制该函数的特定行为。</p><p><code>concat</code>方法会默认将<code>this</code>数组和参数中的<strong>数组打平或“展开”</strong>，而非数组类型只是简单地添加到末尾，这个行为是通过<code>JavaScript</code>解释器是否将要连接的<strong>值当作数组来对待</strong>决定的。</p><p><code>ES6</code>之前，使用<code>Array.isArray()</code>来判断，<code>ES6</code>推出后，那么则优先根据要连接的值<strong>是一个对象且包含</strong><code>Symbol.isConcatSpreadable</code>符号属性，以该属性的<strong>布尔值</strong>（<code>true/false</code>）来确定<strong>是否</strong>应该<strong>展开</strong>参数。</p><p>使用场景有：让自定义的类数组对象赋予也能用<code>concat</code>进行连接、或让自定义的数组子类不能使用<code>concat</code></p><h3 id="模式匹配符号"><a href="#模式匹配符号" class="headerlink" title="模式匹配符号"></a>模式匹配符号</h3><p><code>ES6</code>之后，除了能够使用<code>RegExp</code>对象执行模式匹配操作，也能使用任何具有<strong>定义了模式匹配行为的符号属性</strong>的对象，也就是说，类似<code>match matchAll search</code>等<code>String</code>匹配方法，都会有类似的公认符号<code>Symbol.match Symbol.search</code>等等，两者之间的<strong>转化</strong>关系如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在调用字符串的匹配方法时 */</span></span><br><span class="line">string.<span class="title function_">method</span>(pattern,arg)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 该调用会转化为 对模式对象上相应的符号化命名方法的调用*/</span></span><br><span class="line">pattern[symbol](string,arg)</span><br></pre></td></tr></table></figure><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><code>Symbol.toPrimitive</code></h3><p><code>ES6</code>中，该公认符号允许我们覆盖默认的<strong>对象到原始值</strong>的<strong>转换行为</strong>，完全自定义自己的类实例如何转换为原始值。根据该接口编写相应的符号属性方法即可。</p><h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a><code>Symbol.unscopables</code></h3><p>该公认符号是针对废弃的<code>with</code>语句所导致的兼容性问题所引入的。有点难理解，大致意思就是能够将<code>Symbol.unscopables</code>中的属性在模拟<code>with</code>作用域时忽略。</p><h2 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h2><p>在这之前，我们得复习一下<strong>“模板字面量”</strong>–位于反引号之间的字符串，如果一个求值为<strong>函数的表达式</strong>后紧接一个模板字面量，那就换转换为一个<strong>函数调用</strong>–也被称为<strong>“标签化模板字面量”</strong>，其中被调用的函数也被称为<strong>标签函数</strong>，并看成是<strong>元编程</strong>之一</p><p>如果此时模板字面量中有<code>n</code>个插值，那么标签函数在被调用后会收到<code>n+1</code>个参数，第一个参数是一个包含<code>n+1</code>个字符串的数组，其余<code>n</code>个参数是要插入的值，顺序为他们出现在模板字面量中的顺序。</p><h2 id="反射API"><a href="#反射API" class="headerlink" title="反射API"></a>反射<code>API</code></h2><p>与<code>Math</code>对象类似，<code>Reflect</code>对象<strong>不是类</strong>，它的属性这是定义了一组相关函数，下面列举几个<code>API</code>以及相应的常规写法：</p><table><thead><tr><th>常规写法</th><th>反射<code>API</code></th></tr></thead><tbody><tr><td><code>f.apply(o,args)</code></td><td><code>Reflect.apply(f,o,args)</code></td></tr><tr><td><code>new c(...args)</code></td><td><code>Reflect.construct(c,args,newTarget)</code></td></tr><tr><td><code>Object.defineProperty(o,name,descriptor)</code></td><td><code>Reflect.defineProperty(o,name,descriptor)</code></td></tr><tr><td><code>o[name]</code></td><td><code>Reflect.get(o,name,receiver)</code></td></tr></tbody></table><p>以上只列举几个反射<code>API</code>，虽然并<strong>没有提供新</strong>特性，但它们用一个方便的<code>API</code>筛选出了一组特性，即支持对<code>JavaScript</code>对象执行基础的操作。</p><h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><p>  <code>ES6</code>及之后的版本的<code>Proxy</code>类是一项强大的元编程特性，让我们能够自己实现基础操作，并创建具有普通对象无法企及能力的代理对象。</p><p><strong>创建</strong>代理对象时，需要<strong>指定另外两个</strong>对象，即<strong>目标</strong>对象和<strong>处理器</strong>对象。得到的代理对象<strong>没有自己的状态或行为</strong>，只是把自己要执行的操作（比如读属性、写属性等等）<strong>发送给</strong>处理器对象或目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlers)</span><br></pre></td></tr></table></figure><p>代理对象支持的操作<strong>就是反射<code>API</code>定义的那些操作</strong>。对所以基础操作，代理对象都<strong>这样处理</strong>：如果处理器对象上<strong>存在</strong>相应的方法，代理<strong>就调用该方法</strong>执行相应操作（这里的<strong>方法和签名</strong>和之前<strong>反射<code>API</code><strong>介绍的</strong>完全相同</strong>）。如果处理其对象<strong>不存在</strong>对应方法，则代理<strong>就在目标对象</strong>上执行基础操作。</p><p>当处理对象是<strong>空</strong>时，代理对象本质就是目标对象的一个透明包装器，大多时候这都是没有必要的，除了用于可撤销代理。</p><p> <strong>可撤销代理</strong>：使用<code>Proxy.revocable()</code>工厂函数<strong>而不是</strong><code>Proxy()</code>来创建一个可撤销代理，返回值中包含一个代理对象和一个<code>revoke()</code>函数。一旦调用<code>revoke</code>函数，代理<strong>立马失效</strong>。如此看来，可撤销代理可以充当某种<strong>代码隔离</strong>的机制，比如将某个函数传给一个不信任的第三方库，并在使用完这个库之后撤销代理，防止第三方库一直持有对你函数的引用，并在不知情的时候调用它，这在<strong>防御式编程</strong>中并不罕见。</p><p>当处理对象<strong>非空</strong>时，我们就需要好好地<strong>定义处理器</strong>了，以<strong>实现自定义行为</strong>，这样就和底层目标对象<strong>本质上变得不相干</strong>了。这时代理的应用范围变得非常灵活和广泛，比如实现一个只读包装器、一个（更为底层的）日志代理等等。 </p><p><strong>代理不变式</strong>：代理对象是可以和目标对象的状态不一致的，比如代理对象被设置为冻结状态，但实际上目标对象没有冻结的话，仍然可以通过<code>Reflect</code>接口修改属性值。至于如何保证两者的不一致不会太离谱，实际上，<code>Proxy</code>类会在转发完操作后<strong>对结果执行合理性检查</strong>，如果<strong>违背了重要的<code>JavaScript</code>不变式</strong>，则会抛出<code>TypeError</code>（不让继续操作）</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><code>BOM</code></h1><p><strong>浏览器对象模型</strong>（<code>BOM -- Browser Object Model</code>）是一个应用编程接口（<code>API</code>），用于支持访问和操作浏览器的窗口</p><h1 id="浏览器中的JavaScript"><a href="#浏览器中的JavaScript" class="headerlink" title="浏览器中的JavaScript"></a>浏览器中的<code>JavaScript</code></h1><p><code>JavaScript</code>其最初目的就是为浏览器显示的文档赋予<strong>动态</strong>行为，随着技术发展，不仅<code>JavaScript</code>经历了多次重大改变，**<code>Web</code>平台<strong>的能力也出现了爆炸式的增长，可以算是一个完善的</strong>应用开发平台**了。</p><p>浏览器专注于格式化文本与图片的显示，但其同原生操作系统一样，具有许多<strong>操作系统级别</strong>的能力，包括图形、视频、音频、网络等等</p><p><code>JavaScript</code>能够<strong>使</strong><code>Web</code>应用<strong>使用</strong><code>Web</code>平台提供的<strong>服务</strong>，这就<strong>包括</strong>本节的标题–浏览器中的<code>JavaScript</code></p><blockquote><p><code>Web API</code>是通过主要浏览器厂商的共识来定义的，<code>Web API</code>官方文档就是一系列规范，其受众是实现它们的<code>C++</code>程序员，而不是使用这些<code>API</code>的<code>JavaScript</code>程序员</p><p>好在<code>Mozilla</code>的<code>MDN Web</code>文档提供了可靠的、全面的<code>Web API</code>文档–<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API" >Web API 接口参考 | MDN (mozilla.org)<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="Web编程基础"><a href="#Web编程基础" class="headerlink" title="Web编程基础"></a><code>Web</code>编程基础</h2><p><code>Web</code>编程中很重要的一部分就是编写<code>Web</code>应用中的<code>JavaScript</code>程序，以及将这部分程序加载到浏览器、获取输入输出和响应事件。\</p><h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><p>使用<code>VSCode</code>进行开发时，行注释：<code>//</code>（<code>ctrl+/</code>）、块注释：<code>/**/</code>（<code>Shift+alt+a</code>）</p><h3 id="语句结束符"><a href="#语句结束符" class="headerlink" title="语句结束符"></a>语句结束符</h3><p>即分号<code>;</code>，结束符分号会被<strong>自动推断</strong>，所以可写可不写，但也要注意可能导致<strong>上下文解析出问题</strong>的情况，要酌情加分号。当然，也得看团队开发风格和规范</p><h3 id="lt-script-gt-标签"><a href="#lt-script-gt-标签" class="headerlink" title="&lt;script&gt;标签"></a><code>&lt;script&gt;标签</code></h3><p><code>JavaScript</code>需要嵌入<code>HTML</code>才能被浏览器执行，需要将<code>JavaScript</code>代码放在<code>&lt;script&gt;</code> 标签中，</p><ul><li><p><strong><code>src</code>属性</strong>：</p><ul><li>设置<code>&lt;script&gt;</code>的<code>src</code>属性外部引用路径（推荐），而不用在<code>HTML</code>文档中直接写具体代码</li></ul></li><li><p><code>type</code>属性：</p><ul><li>用于指定脚本是模块–<code>type=&quot;module&quot;</code>；在网页嵌入数据但不显示</li></ul></li><li><p><code>async</code>与<code>defer</code>：</p><ul><li>这两个属性只对使用<code>src</code>属性的<code>&lt;script&gt;</code>标签起作用，若同时设置默认只<code>async</code>生效</li><li>浏览器默认解析<code>&lt;script&gt;</code>标签时必须运行脚本，以免漏掉<code>document.wirte()</code>所生成的内容，才能继续渲染，<code>async</code>和<code>defer</code>会明确告诉浏览器，当前链接的脚本没有使用<code>document.wirte()</code></li><li><code>async</code>会让浏览器<strong>尽早</strong>运行脚本，但在脚本<strong>下载期间不会阻塞</strong>文档解析。由于是尽早执行的机制，所以这类方式引入的脚本一加载完就会执行，<strong>执行顺序无从预测</strong></li><li><code>defer</code>会让浏览器<strong>完全</strong>加载和解析完文档<strong>后</strong>才执行，这类方式引入的脚本的<strong>执行顺序</strong>是按照其出现在<strong>文档中的顺序</strong>执行的</li></ul></li></ul><blockquote><p>将<code>&lt;script&gt;</code>标签<strong>放在文档的什么位置</strong>，需要开发者结合执行机制来考虑让其在<strong>什么时机执行</strong>。比如涉及操控文档节点的代码，则需要在文档完全加载和解析后的时机执行，一般为<code>HTML</code>文件末尾</p><p>有的则会有默认执行顺序，比如<code>alert()</code>和<code>prompt()</code>会跳过页面渲染先被执行，<code>type=module</code>的会在文档加载完毕后执行（可以通过设置<code>async</code>属性，让其尽早执行–一加载完所有依赖就执行）、</p></blockquote><h3 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h3><p><strong>文档对象模型</strong>（<code>DOM -- Document Object Model</code>）是一个应用编程接口（<code>API</code>），用于在<code>HTML</code>中使用拓展的<code>XML</code>。<code>Document</code>对象是<code>JavaScript</code>编程中最重要的对象之一，它代表浏览器窗口或标签页显示的<code>HTML</code>文档</p><p>文档中的每一个<code>HTML</code><strong>标签</strong>都是一个<code>JavaScript Element</code>对象，其中的每一行文本是一个<code>Text</code>对象，这些对象相当于一个<code>Node</code>，构成了一个<code>DOM</code>树，<code>DOM API</code>赋予<code>JavaScript</code>对这棵树进行查询和遍历。且每个<strong>标签类型</strong>都对应一个<code>JavaScript</code>类</p><h3 id="浏览器中的全局对象"><a href="#浏览器中的全局对象" class="headerlink" title="浏览器中的全局对象"></a>浏览器中的全局对象</h3><p>每个浏览器窗口或标签页都有一个全局对象，其上定义了<code>JavaScript</code>标准库以及许多<code>Web API</code>属性（比如浏览器浏览记录<code>history</code>、窗口像素宽度<code>innerWidth</code>、**全局对象本身<code>window</code>**等等）</p><h3 id="脚本共享命名空间"><a href="#脚本共享命名空间" class="headerlink" title="脚本共享命名空间"></a>脚本共享命名空间</h3><p>模块中的常量、函数、类等，如果需要被其他脚本使用，需要明确地导出和导入，但在<strong>非模块脚本中，情况完全不同</strong>。</p><p>如果在顶级脚本中定义了一个类、函数等，则该声明对<strong>同一文档中的所有脚本可见</strong>，但这样对于大型程序来说，避免<strong>命名冲突</strong>会很麻烦，尤其是引入了<strong>第三方库</strong>，更是棘手。不得不提一个历史遗留问题（现已有替代方案），**<code>var</code>和<code>function</code>会在共享的全局对象上创建属性<strong>，而<code>ES6</code>中的<code>const let class</code>则</strong>不会<strong>在共享的全局对象上创建属性–<strong>这类声明</strong>会被</strong>共享<strong>且拥有</strong>相同的文档作用域<strong>，但它们</strong>不作为**<code>JavaScript</code>可以访问到的任何对象（比如<code>window</code>）的属性存在。</p><p>综上，模块脚本和非模块脚本的共享命名空间不同，同时注意<code>var function const let class</code>的特殊性。</p><p>你 </p><h3 id="JavaScript程序的执行"><a href="#JavaScript程序的执行" class="headerlink" title="JavaScript程序的执行"></a><code>JavaScript</code>程序的执行</h3><p>首先，<code>JavaScript</code>程序的边界在哪里并没有正式的定义。其次，我们可以把<code>JavaScript</code>程序的执行想象成发生在两个阶段：</p><ul><li>第一阶段，文档内容加载完成，<code>&lt;script&gt;</code>指定的代码（外部&amp;内部）执行</li><li>第二阶段：第一阶段文档加载完毕及所有代码运行之后，就是第二阶段。这个阶段是异步的、<strong>事件驱动</strong>的。</li></ul><p><code>JavaScript</code>是<strong>单线程语言</strong>，所以客户端的程序一定要保证不会长时间运行，否则<strong>代码执行期间停止响应用户输入</strong>，严重影响体验，但这在有些情况下（比如计算密集型任务）是不可避免的。当然，<code>Web</code>平台提供了一种<strong>安全线程机制</strong>，补充了<code>JavaScript</code>这点的不足。</p><p>客户端<code>JavaScript</code>时间线–之前粗略分的两个阶段可以进一步细化：</p><ol><li>浏览器创建<code>Document</code>对象并解析网页，不断添加<code>Element</code>对象和<code>Text</code>节点，此时<code>document.readyState=&quot;loading&quot;</code></li><li>对没有<code>async defer 或 type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>标签，会先将其添加到文档，再执行其中的代码。若代码中有<code>document.write()</code>，会暂停解析。注意此时的（没有<code>async defer 或 type=&quot;module&quot;</code>）<code>&lt;script&gt;</code>标签只能看到自己和之前已解析的文档内容</li><li>对有<code>async</code>的<code>&lt;script&gt;</code>标签，会下载完全后并执行，但解析器不会暂停等待下载，这类标签能看到自己和之前已解析的文档内容，也有可能看到更多的内容</li><li>文档解析完成后，<code>document.readyState=&quot;interactive&quot;</code></li><li>对有<code>defer</code>和没有<code>async</code>的模块脚本，会按照其在文档中的出现顺序进行执行，这类标签能看到完整的文档内容</li><li>浏览器在<code>Document</code>对象上派发<code>DOMContentLoaded</code>事件，标志第二阶段开始</li><li>此时文档已完全解析，但浏览器会一直等所有外部资源（图片、音频等）都加载完，且所有<code>async</code>脚本都加载并执行完后，<code>document.readyState=&quot;complete&quot;</code>，并在<code>Window</code>对象派发<code>load</code>事件</li><li>浏览器开始异步调用事件处理程序–即从这一刻起，对用户输入事件、网络事件、定时器超时等响应</li></ol><h3 id="程序输入与输出"><a href="#程序输入与输出" class="headerlink" title="程序输入与输出"></a>程序输入与输出</h3><p><strong>输入</strong>的来源有文档内容本身、事件形式的用户输入、全局<code>navigator</code>属性等等</p><p><strong>输出</strong>的方式有<code>DOM API</code>、<code>React</code>等高级框架、<code>console.log()</code>等，但是这种输出<strong>只</strong>面向开发者用于<strong>调试</strong>，不能作为对用户的输出。</p><h3 id="程序错误"><a href="#程序错误" class="headerlink" title="程序错误"></a>程序错误</h3><p><strong>在浏览器运行的</strong><code>JavaScript</code>程序并<strong>不会真正“崩溃”</strong>，如果出现异常，其它没问题的已注册的函数会照常执行，当然，开发者可以自行编写错误处理程序，但那并不经常必需。</p><h3 id="Web安全模型"><a href="#Web安全模型" class="headerlink" title="Web安全模型"></a><code>Web</code>安全模型</h3><p>由于理论上<code>JavaScript</code>可以在用户的私人设备执行任意代码，因此存在明显的安全隐患，但<code>Web</code>应用的不断蓬勃发展是不可避免的，各浏览器厂商也在努力平衡两者。以下是解决安全隐患的一些策略 ：</p><ul><li>限制<code>JavaScript</code>的能力，比如不能像客户端删除或者写入文件</li><li>同源策略，指对<code>JavaScript</code>代码能够访问和操作什么<code>Web</code>内容有一整套限制</li><li>跨站点脚本（<code>Cross-Site Scripting -- XSS</code>）是一种攻击方式，需要程序员对此有所了解</li></ul><h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><p><code>JavaScript</code>使用<strong>异步事件驱动</strong>的编程模型，在这种编程风格下，浏览器会对尽可能多的对象在发生任何值得关注的事情时<strong>生成事件</strong>，比如点击、敲击键盘。这并非<code>Web</code>编程的专利，这是任何具有图形界面的应用都应该这么设计。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>类型上是<strong>字符串</strong>，表示发生了什么事，例如<code>mousemove keydown</code>等，也被称为<strong>事件名称</strong></p><ul><li>设备相关输入事件</li><li>设备无关输入事件</li><li>用户界面事件</li><li>状态变化事件</li><li><code>API</code>特定事件</li></ul><h3 id="事件目标"><a href="#事件目标" class="headerlink" title="事件目标"></a>事件目标</h3><p>是一个对象，事件<strong>发生在</strong>该对象上或者与该对象<strong>有关</strong></p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>是与特定事件<strong>关联</strong>的对象，包含有关该事件的<strong>细节</strong>，事件对象<strong>作为</strong>事件处理器程序的<strong>参数</strong>传入，且所有事件对象<strong>都</strong>包含<code>type</code>和<code>target</code>属性，分别表示事件类型和事件目标</p><h3 id="事件处理器（-x2F-监听器）"><a href="#事件处理器（-x2F-监听器）" class="headerlink" title="事件处理器（&#x2F;监听器）"></a>事件处理器（&#x2F;监听器）</h3><p>是一个函数，负责处理或响应事件，由应用通过浏览器注册，需要指明事件类型和事件目标，有两种注册事件处理器的方式：</p><ul><li><p>早期，设置为事件目标的对象或文档元素的一个<strong>属性</strong>，比如<code>onload onclick</code>等等：</p><ul><li><p>设置对象属性：例<code>window.onload=function()&#123;/*处理程序的代码*/&#125;</code>，但这样每个属性<strong>最多绑定一个</strong>事件处理程序</p></li><li><p>设置文档元素属性：例<code>&lt;button onclick=&quot;console.log(&#39;Clicked!&#39;);&gt;Click me&lt;/button&gt;&quot;，</code>注意<code>HTML</code>属性中的<code>JavaScript</code>代码<strong>没有严格一说</strong>，可能存在意外变量的环境中执行，不容易排查bug（<strong>不推荐</strong>）</p></li></ul></li><li><p>通过<code>addEventListener()</code>将事件处理程序传给对象&#x2F;元素–任何可以作为事件目标的对象，都有这个方法：</p><ul><li>该方法接受三个参数：第一个是<strong>事件类型</strong>、第二个是事件发生时<strong>触发的函数</strong>、第三个<strong>可选</strong>–是一个布尔值或对象</li><li>多次调用<code>addEventListener()</code>可以为同一对象同一事件类型<strong>绑定多个</strong>处理程序，执行顺序按注册顺序执行</li><li>可选参数为布尔值时，代表注册为捕获事件处理程序；为对象时，规定以该形式：<code>&#123;capture: 布尔值, once: 布尔值, passive: 布尔值&#125;</code><ul><li><code>capture</code>为<code>true</code>，代表注册为捕获事件处理程序</li><li><code>once</code>为<code>true</code>，代表被触发一次后会自动移除</li><li><code>passive</code>为<code>true</code>，代表事件处理程序永远不调用<code>preventDefault()</code>取消默认动作</li><li>以上若不设置，默认为false</li></ul></li></ul></li></ul><p>除此，需要注意事件处理程序被调用时会接收一个<code>Event</code>对象作为唯一的参数，整个对象提供了事件的详细信息：</p><ul><li><code>type</code></li><li><code>target</code></li><li><code>currentTarget</code></li><li><code>timeStamp</code></li><li><code>isTrusted</code></li><li>等等</li></ul><blockquote><p><strong>取消注册</strong>的方法是<code>removeEventListener()</code>，参数和注册函数<strong>一模一样</strong>，只是第三个参数中只有<code>capture</code>有效–用于取消<strong>对应的事件捕获</strong>程序</p></blockquote><h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><p>是一个过程，浏览器会决定在这个过程中，让<strong>哪些对象触发事件处理程序</strong>。如果事件的目标是<code>Window</code>或其他<strong>独立对象</strong>，浏览器对这个事件的响应就是简单地调用该对象上对应的事件处理程序，但如果事件目标是<code>Document</code>或其它<strong>文档元素</strong>，就没有那么简单。</p><p>事件传播可以分为<strong>三个阶段</strong>：</p><ol><li>事件捕获：提供了把事件发送<strong>到目标之前先行处理</strong>的机会，最先调用的是<code>Window</code>对象上注册的捕获处理程序，然后才是<code>Document</code>，一直沿<code>DOM</code>树往下</li><li>调用目标对象<strong>本身</strong>的事件处理程序</li><li>事件冒泡：和捕获正好相反，沿<code>DOM</code>树网上直到<code>Window</code>，调用父节点&#x2F;元素的事件处理程序</li></ol><h3 id="事件取消"><a href="#事件取消" class="headerlink" title="事件取消"></a>事件取消</h3><ul><li><p>浏览器默认会对很多用户事件做出响应，比如点击链接会跳转、滑动滚轮浏览器会滚动等等，如果你需要为这些时间绑定自定义的处理程序，则可以调用<strong>事件对象</strong>的<code>preventDefault()</code>方法</p></li><li><p><code>stopPropagation()</code>：停止冒泡，阻止事件在 DOM 中继续冒泡</p></li><li><p><code>stopImmediatePropagation()</code>：与第二点类似</p></li></ul><h3 id="派发自定义事件"><a href="#派发自定义事件" class="headerlink" title="派发自定义事件"></a>派发自定义事件</h3><p>如果一个<code>JavaScirpt</code>对象有<code>addEventListener()</code>方法，那么它就是一个“事件对象”，那么就同样会有一个<code>dispatchEvent()</code>方法–该方法会向一个指定的事件目标<strong>派发</strong>一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a></p><p>我们可以使用<code>CustomEvent()</code>构造函数创建一个自定义对象，然后传给<code>dispatchEvent()</code>方法</p><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作<code>DOM</code></h2><p><code>DOM API</code>将文档组织成一个<code>Node</code>对象树，其中<code>Node</code>可以是<code>Document</code>、<code> Element</code>、 <code>Text</code>节点或者<code>Comment</code>节点。客户端<code>JavaScript</code>程序操作文档中的一个或多个元素，首先是要<strong>以某种方式获取或选择表示该元素的<code>Element</code>对象</strong></p><h3 id="选择Document元素"><a href="#选择Document元素" class="headerlink" title="选择Document元素"></a>选择<code>Document</code>元素</h3><ul><li><p>**<code>querySelect()</code>和<code>querySelectAll()</code>**：</p><ul><li><strong>参数</strong>：<code>CSS</code>选择符（例<code>querySelect(&#39;button, input[type=&quot;button&quot;]&#39;)</code>）</li><li>特点：<code>Element</code>类和<code>Document</code>类都提供了<code>querySelect()</code>和<code>querySelectAll()</code>方法来选取元素，当在<strong>元素上调用</strong>时，只返回其<strong>后代</strong>中的元素（可以理解为沿<code>DOM</code>树向下）</li><li><strong>返回结果</strong>：<ul><li><code>querySelect()</code>返回的是一个**<code>Element</code>对象**或<code>null</code></li><li><code>querySelectAll()</code>返回的不是<code>Element</code>对象数组，而是一个类似数组的<code>NodeList</code>对象（可以理解为<strong>伪数组</strong>），但要注意该<code>NodeList</code>的<code>length</code>属性和其中包含的元素<strong>不会</strong>随着文档内容或结构的变化而变化</li></ul></li><li><strong>注意</strong>：对于伪元素<code>::first-line、::first-letter</code>，该接口什么都找不到；同时，很多浏览器也拒绝对<code>:link、:visited</code>伪类返回结果，以保护用户隐私</li></ul></li><li><p>**<code>closest()</code>**：</p><ul><li>该方法是由<code>Element</code>类定义的，以<strong>选择符</strong>作为唯一参数，返回匹配的<strong>最近祖先</strong>元素（可以理解为沿<code>DOM</code>树向上匹配）</li></ul></li><li><p><strong>其它选择元素的方法</strong></p><ul><li>类似<code>getElementById()、getElementByName()</code>等方法，如今可以算<strong>废弃</strong>状态，不推荐使用</li></ul></li></ul><h3 id="文档结构与遍历"><a href="#文档结构与遍历" class="headerlink" title="文档结构与遍历"></a>文档结构与遍历</h3><p>在选择完的<code>Element</code>元素后，常常需要继续查找与其相关的部分（父亲、孩子、同辈），以下是常用的<strong>属性</strong>–可以引用其他节点：</p><ul><li><p>只有<code>Element</code>对象才有的属性–返回结果为<code>Element</code>对象或<code>null</code>–可以理解为在遍历一个<code>Element</code>对象树（<strong>会忽略文本</strong><code>Text</code>节点）：</p><ul><li><p><code>childElementCount</code></p></li><li><p><code>firstElementChild</code></p></li><li><p><code>lastElementChild</code></p></li><li><p><code>previousElementSibling</code></p></li><li><p><code>nextElementSibling</code></p></li></ul></li><li><p>所有<code>Node</code>节点都定义了的属性–<strong>不想忽略文本</strong>则使用如下属性：</p><ul><li><p><code>parentNode</code></p></li><li><p><code>childNodes</code></p></li><li><p><code>firstChild</code></p></li><li><p><code>lastChild</code></p></li><li><p><code>previousSibling</code></p></li><li><p><code>nextSibling</code></p></li><li><p><code>nodeType</code></p></li><li><p><code>nodeValue</code></p></li><li><p><code>nodeName</code></p></li></ul></li></ul><blockquote><p>若<strong>只</strong>需要关心文档中的<code>Element</code>对象，<strong>不关心</strong>其中的<strong>文本</strong><code>Text</code>，使用<code>Element</code>对象才有的属性，会<strong>忽略</strong>文档树中的<code>Text</code>、<code>Comment</code>节点</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>HTML</code>标签中的属性键值对，我们一般操作的方式有如下几种：</p><ul><li>使用<code>Element</code>类提供的<code>getAttribute() \ setAttribute() \ hasAttribute() \ removeAttribute()</code>，用于查询、设置、检测和<strong>删除</strong>元素的属性，但是<strong>略显麻烦</strong></li><li>所有标准的<code>HTML</code>元素的<strong>标准属性</strong>，在对应的**<code>HTMLElement</code>对象<strong>上也有</strong>相应的<code>JavaScript</code>属性<strong>（且属性的</strong>值的数据类型**不变），此时使用<code>JavaScript</code>访问会更为便捷。（但是不能用<code>delete</code>来删除属性，一般用<code>removeAttribute()</code>）</li><li><strong>自定义</strong>的<code>HTML</code>元素属性一般规定以<code>data-</code>开头（小写），<code>Element</code>对象定义了<code>dataset</code>对象来保存这些自定义的<code>HTML</code>属性。例如<code>dataset.x</code>对应<code>data-x</code>的值，多个单词时–<code>dataset.sectionNumber</code>对应<code>data-section-number</code>的值<strong>（重要）</strong></li></ul><blockquote><p>一般来说，<code>HTML</code>的属性名是<strong>不区分大小写</strong>的，而镜像到<code>JavaScript</code>中要区分大小写（<strong>默认全部小写</strong>–<strong>多个单词</strong>则对应<strong>小驼峰</strong>命名法）</p><p>除去上述的一般情况，还需注意如下不同：</p><ul><li>比如<code>&lt;input&gt;</code>的<code>value</code>属性对应<code>defaultValue</code>，而<code>&lt;input&gt;</code>中用户输入的值才对应<code>value</code></li><li><code>class</code>属性对应<code>className</code>，但考虑更改习惯，<code>Element</code>对象定义了<code>classList</code>属性（类数组对象）和四个方法<code>add() \ remove() \ contains() \ toggle()</code>来修改<code>class</code>类属性</li></ul></blockquote><h3 id="元素内容"><a href="#元素内容" class="headerlink" title="元素内容"></a>元素内容</h3><p>元素的内容一般有两种表示（得看具体场景）：</p><ul><li><code>HTML</code>表示–即标记字符串<ul><li>修改<code>Element</code>对象的<code>innerHTML</code>或<code>outerHTML</code>属性，就可以修改<strong>标签内的</strong>（或<strong>包括标签本身在内的</strong>）元素内容</li><li>或者使用<code>Element</code>方法中的<code>insertAdjacentHTML()</code>，来插入与指定元素<strong>相邻</strong>的任意<code>HTML</code>标记字符串–该方法接受两个参数，第一个参数表示<strong>插入位置</strong>（关键字可选<code>beforebegin \ afterbegin \ beforeend \ afterend</code>），第二个参数则是要出插入到内容</li></ul></li><li>纯文本表示–即不解析&#x2F;不转义<ul><li><code>Node</code>类定义了<code>textContent</code>属性，适用于<code>Text</code>节点和<code>Element</code>节点，<strong>对于后者的返回结果为所有后代元素中的文本</strong></li><li><code>Element</code>类定义了<code>innerText</code>属性，作用类似，但是有些<code>BUG</code>，故不推荐使用</li><li><code>&lt;script&gt;</code>中的文本永远<strong>不会</strong>被浏览器<strong>显示</strong>但是会出现<strong>在文档树中</strong>，<strong>理论上也可以作为嵌入任意文本数据的场所</strong>，只需要设置<code>type</code>属性为某个值，比如<code>text/x-custom-data</code>，然后使用<code>text</code>属性即可访问其保存的数据</li></ul></li></ul><blockquote><p>直接设置<code>innerHTML</code>或<code>outerHTML</code>的<strong>效率很高</strong>，因为浏览器本身就很擅长解析<code>HTML</code>，但是不推荐使用类似<code>+=</code>等操作符来追加文本，因为这要<strong>先序列化</strong>字符串再解析，<strong>效率不高</strong></p></blockquote><h3 id="创建、插入和删除节点"><a href="#创建、插入和删除节点" class="headerlink" title="创建、插入和删除节点"></a>创建、插入和删除节点</h3><p>这里讨论的节点一般指<code>Element</code>对象或<code>Text</code>节点，他们都是节点<code>Node</code>对象：</p><ul><li>创建<code>Element</code>对象：<code>document.createElement()</code></li><li>创建<code>Text</code>节点：<code>document.createTextNode()</code>（很少用）</li></ul><p><code>Node</code>对象有在<code>DOM</code>树中<strong>插入、删除和替换节点</strong>的<strong>方法</strong>：</p><ul><li><code>append()</code>–把参数添加到<strong>孩子列表</strong>的<strong>末尾</strong></li><li><code>prepend()</code>–把参数添加到孩子列表的<strong>开头</strong></li><li><code>after()</code>–在<strong>自身后面</strong>插入新内容</li><li><code>before()</code>–在<strong>自身前面</strong>插入新内容</li><li><code>remove() </code>–<strong>移除</strong>自己</li><li><code>replaceWith()</code>–<strong>替换</strong>自己</li><li><strong>参数</strong>：除了<code>remove()</code>方法不接收参数，其它都接受<strong>任意</strong>多个参数，这些参数为<code>Node</code>对象或字符串（字符串会自动转换为<code>Text</code>节点）</li></ul><blockquote><p>需要注意，<code>append()</code>和<code>prepend()</code>只在<code>Element</code>对象上有定义，<code>after()</code>和<code>before()</code>则同时存在于<code>Element</code>对象和<code>Text</code>节点上。</p><p>被创建的元素<strong>只</strong>能插入到文档的<strong>一个地方</strong>，若重复插入，则以最后一次的新位置。可以使用<code>cloneNode()</code>方法创建<strong>新副本</strong>，传入<code>true</code>以复制全部内容，然后使用副本进行插入。</p><p>像<code>appendChild() insertBefore()</code>等老式<code>DOM API</code>比这里介绍的更难用，不推荐使用它们</p></blockquote><h2 id="操作CSS"><a href="#操作CSS" class="headerlink" title="操作CSS"></a>操作<code>CSS</code></h2><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><ul><li>映射关系：<code>HTML</code>中元素的<code>CSS</code>属性对应<code>Element</code>对象上的<code>style</code>属性，是一个<code>CSSStyleDeclaration</code>对象，该对象的属性对应具体的<code>CSS</code>键值对</li><li>命名约定：<code>CSSStyleDeclaration</code>对象属性名会<strong>剔除连字符</strong>，并将<strong>每个连字符后面的字母变为大写</strong>（例<code>div.style.fontSize</code>）</li><li>属性值类型：<code>CSSStyleDeclaration</code>对象属性的<strong>所有值都是字符串</strong>，需要加上引号（但不需要把分号一起加进去）</li><li>设置方法：直接修改属性值、使用<code>getAttribute() setAttribute()</code>、使用<code>CSSStyleDeclaration</code>对象的<code>cssText</code>属性</li></ul><h3 id="计算样式"><a href="#计算样式" class="headerlink" title="计算样式"></a>计算样式</h3><p>同样以<code>CSSStyleDeclaration</code>对象表示，但有如下不同：</p><ul><li>是<strong>只读的</strong></li><li><code>cssText</code>属性的值是<code>undefined</code></li><li><strong>简写属性不会被计算</strong>（例如<code>margin</code>、<code>border</code>等），需要访问更基础的属性（例如<code>marginLeft</code>、<code>borderLeftWidth</code>等）</li><li>计算样式的属性是<strong>绝对值</strong>，即返回<code>px</code>后缀的值</li></ul><h3 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h3><p>以下是几个常用的修改样式表的操作：</p><ul><li><strong><code>style link</code>标签</strong>对应的<code>Element</code>对象会有一个<code>disable</code>属性（值类型为<strong>布尔</strong>类型），用来<strong>启用&#x2F;禁用</strong>整个样式表</li><li>使用<code>DOM API</code>，创建<code>link</code>标签并设置引用的样式表，然后插入到文档中</li><li>使用标签的<code>classList</code>属性来添加&#x2F;移除样式</li></ul><h3 id="CSS动画和事件"><a href="#CSS动画和事件" class="headerlink" title="CSS动画和事件"></a><code>CSS</code>动画和事件</h3><p><code>JavaScript</code>可以用来<strong>监控</strong><code>CSS</code>过渡动画和复杂动画的进度，实现机制是浏览器在播放过渡动画和复杂动画期间会<strong>派发事件</strong></p><p>过渡动画：</p><ul><li><code>transitionrun</code>（首次出发过渡）</li><li><code>transitionstart</code>（当发生视觉变化–考虑到延时）</li><li><code>transitionend</code>（动画完成）</li><li><code>elapsedTime</code>属性是从<code>transitionstart</code>到结束经过的秒数</li></ul><p>动画<code>animation</code>同上类推</p><h2 id="文档几何与滚动"><a href="#文档几何与滚动" class="headerlink" title="文档几何与滚动"></a>文档几何与滚动</h2><p>对于<code>Web</code>应用–<strong>基于树的抽象文档模型</strong>，对于用户–<strong>基于几何坐标系的文档视图</strong>，下面就是对后者进行详细的介绍：</p><h3 id="文档坐标和视口坐标"><a href="#文档坐标和视口坐标" class="headerlink" title="文档坐标和视口坐标"></a>文档坐标和视口坐标</h3><p>当页面不发生滚动时&#x2F;或文档比视口小，<strong>文档坐标</strong>的左上角和<strong>视口坐标</strong>的左上角是重合的。两者坐标系是相同的，<code>x</code>坐标向右表示增大，<code>y</code>坐标向下表示增大。 在<code>JavaScript</code>中最常用的是视口坐标，两坐标之间的<strong>转换</strong>，必须加上<strong>滚动位移</strong>（<code>scroll offset</code>）</p><p>视口的定义：浏览器窗口实际显示文档内容的区域（不包含浏览器的外框，比如地址栏等）</p><blockquote><p>容器坐标：</p><ul><li>在使用<code>position:fixed</code>显示定位元素时，<code>top left</code>是相对视口坐标</li><li>在使用<code>position:relative</code>相对定位元素时，<code>top left</code>是相对于<strong>没有给它设置</strong><code>position</code>属性<strong>时</strong>的位置进行定位</li><li>在使用<code>position:absolute</code>定位元素时，<code>top left</code>是相对<strong>文档或者最近的包含定位</strong>元素</li></ul><p>这也是为什么有“子绝父相”的定位设计套路</p></blockquote><h3 id="查询元素的几何大小"><a href="#查询元素的几何大小" class="headerlink" title="查询元素的几何大小"></a>查询元素的几何大小</h3><p><code>Element</code>的<code>getBoundingClientRect()</code>方法可有其确定元素的大小，<strong>没有参数，返回结果是一个对象</strong>，有<code>left right</code>等等几何属性</p><p><code>getClientRects()</code>返回的是一个只读的类数组对象，其元素类似<code>getBoundingClientRect()</code>返回的矩形对象</p><h3 id="确定位于某一点的元素"><a href="#确定位于某一点的元素" class="headerlink" title="确定位于某一点的元素"></a>确定位于某一点的元素</h3><p><code>Document</code>的<code>elementFromPoint()</code>方法，接收<strong>一个点</strong>的<code>x</code>和<code>y</code>坐标–<strong>视口</strong>坐标（例如鼠标事件中的<code>clientX</code>和<code>clentY</code>），返回位于<strong>这个点上的元素</strong>（默认是该位置最内部、嵌套最深、最外层、最大<code>z-index</code>的）。</p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p><code>Window</code>对象的<code>scrollTo()</code>方法接收一个点的<code>x</code>和<code>y</code>坐标–<strong>文档</strong>坐标，并设置滚动条的位移。该方法的作用是<strong>将指定的点移动（或尽可能接近）到视口的左上角</strong>。</p><p><code>Window</code>对象的<code>scrollBy()</code>方法作用类似，只不过传入的点是<strong>相对</strong>值，会<strong>加</strong>在<strong>当前滚动位置</strong>之上</p><p>这两个方法都能接收对象作为参数传入，控制更多的效果–下面这个例子则是让其<strong>平滑</strong>地滚动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">top</span>: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">    <span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Element</code>对象的<code>scrollIntoView()</code>方法，会让该元素<strong>移动到视口中可见为止</strong>，默认是让元素<strong>上边</strong>对齐或接近<strong>视口上沿</strong>。该方法接收唯一参数<code>false</code>，使元素<strong>底边</strong>尽量对齐视口<strong>下沿</strong>。</p><p>该方法也接受一个对象作为参数传入，并可以设置更多属性，比如<code>block</code>、<code>inline</code>来设置垂直&#x2F;水平方向的定义效果（关键字为<code>start end nearest center</code>）</p><h3 id="视口大小、内容大小和滚动位置"><a href="#视口大小、内容大小和滚动位置" class="headerlink" title="视口大小、内容大小和滚动位置"></a>视口大小、内容大小和滚动位置</h3><p><strong>视口</strong>大小可以通过<code>Window.innerWidth</code>和<code>Window.innerHeight</code>属性得到</p><p><strong>文档</strong>的整体大小与**<code>&lt;html&gt;</code>元素**相同，即与<code>document.documentElement</code>的大小相同，可以使用该元素的<code>getBoundingClientRect()</code>方法，也可以使用<code>offsetWidth</code>和<code>offsetHeight</code>属性来获取宽高</p><p>文档在视口中的<strong>滚动位移</strong>可以通过<code>Window.scrollX</code>和<code>Window.scrollY</code>获得（<strong>只读</strong>的）</p><p>对于元素来说，情况更复杂一些，<code>Element</code>对象都定义了以下属性：</p><ul><li><code>offsetHeight</code></li><li><code>offsetWidth</code></li><li><code>offsetLeft</code></li><li><code>offsetTop</code></li><li><code>offsetParent</code></li><li><code>clientHeight</code></li><li><code>clientWidth</code></li><li><code>clientLeft</code></li><li><code>clientTop</code></li><li><code>scrollHeight</code></li><li><code>scrollWidth</code></li><li><code>scrollLeft</code>（可写属性）</li><li><code>scrollTop</code>（可写属性）</li></ul><blockquote><p>具体含义可以查<code>MDN</code>文档，但好像不常用</p></blockquote><h2 id="Web组件"><a href="#Web组件" class="headerlink" title="Web组件"></a><code>Web</code>组件</h2><p>组件定义：不断发展的<code>Web</code>标准允许<code>JavaScript</code>使用<strong>新标签</strong>扩展<code>HTML</code>，扩展后的标签就是<strong>自成一体、可重用</strong>的<code>UI</code><strong>组件</strong>（比如一个好看的搜索框）</p><h3 id="使用Web组件"><a href="#使用Web组件" class="headerlink" title="使用Web组件"></a>使用<code>Web</code>组件</h3><p><code>Web</code>组件是在<code>JavaScript</code>中定义，所以在使用之前，需要<strong>引入定义该组件的<code>JS</code>文件</strong>，且经常以<code>JavaScript</code>模块来实现（通过<code>&lt;script type=&quot;module&quot;&gt;</code>标签来引入<code>HTML</code>文件中）。然后详细阅读该<strong>组件的说明文档</strong>，了解使用方法。</p><p>由于<strong>模块</strong>实在<strong>文档内容解析完之后加载</strong>，在此之前浏览器会尝试解析这些<code>UI</code>组件，这很正常，即在<strong>没有定义之前</strong>，浏览器就遇到并尝试解析它，此时浏览器会向<code>DOM</code>树中<strong>添加一个通用的<code>HTMLElement</code><strong>，在加载了其定义后便会</strong>升级</strong>它。</p><p><code>Web</code>组件同样支持子组件，机制是使用插槽<code>slot</code>来传递（后续会详细说明）</p><h3 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a><code>HTML</code>模板</h3><p>定义：当网页中包含多个重复的<code>HTML</code>结构时，可以使用<code>&lt;template&gt;</code>标签定义一次该结构，然后通过<code>JavaScript</code>按需重复使用该结构。虽然它和<code>Web</code>组件关系不大，但也能<strong>对</strong>频繁使用的<strong>组件进行优化</strong>。</p><p>特点：<code>&lt;template&gt;</code>即其子元素永远不会被浏览器渲染，只能在使用<code>JavaScript</code>的网页中使用</p><h3 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h3><p>定义：将一个<code>HTML</code>标签与一个<code>JavaScript</code>类<strong>关联</strong>起来，然后文档中出现的这个<strong>标签</strong>就会在<code>DOM</code>树中转化为相应的<strong>类的实例</strong>。</p><p>做法：使用<code>customElements.define()</code>方法，第一个参数为<code>Web</code>组件的<strong>标签名</strong>（必须包含一个<strong>连字符</strong>），第二个参数为<code>HTMLElement</code>的<strong>子类</strong>（应当进行拓展，而不是使用一个已有的&#x2F;具体的子类，比如<code>HTMLButtonElement</code>，因为<strong>有的浏览器不支持</strong>）</p><p>浏览器会自动调用自定义元素类的特定“生命期方法”：</p><ul><li><code>connectedCallback()</code>（被插入文档时调用）</li><li><code>disconnectedCallback()</code>（从文档中移除时调用）</li><li><code>observedAttributes</code>（静态类型，一个元素均为属性名的数组，具体什么属性由自己定义以及对应的读写方法）</li><li><code>attributeChangeedCallback()</code>（当<code>observedAttributes</code>中任何一个属性被修改时调用，传入属性名、旧值、新值）</li></ul><h3 id="影子DOM"><a href="#影子DOM" class="headerlink" title="影子DOM"></a>影子<code>DOM</code></h3><p><strong>定义</strong>：一个强大的封装机制，允许把一个<strong>“影子根节点”附加给</strong>一个（自定义）<strong>元素</strong>，后者被称为<strong>“影子宿主”</strong>。影子宿主与所有<code>HTML</code>元素不无二致，影子根节点则作为更私密的后代元素的根，仿佛一个迷你文档，<strong>“影子”</strong>则是指在这个<strong>迷你文档中的</strong>所有<strong>后代元素</strong>。（相反，影子<code>DOM</code>之外的<code>DOM</code>树被称为**阳光<code>DOM</code>**）</p><p><strong>区别</strong>：“影子DOM”这个子树并<strong>不属于常规<code>DOM</code>树</strong>，不会出现在常规<code>DOM</code>树的<code>children</code>数组中，对常规<code>DOM API</code>也<strong>不可见</strong>（比如<code>querySeletor()</code>，即<strong>隐藏且独立</strong>的。</p><p><strong>封装机制</strong>（关键特性）：</p><ul><li><p>创建影子根节点并附加于影子宿主时，可以指定<strong>模式为“开放”或“关闭”</strong>。<strong>前</strong>者意味影子宿主会获得一个**<code>shadowRoot</code>属性**，<code>JavaScript</code>可以通过这个属性来访问影子根节点的后代元素。</p></li><li><p>影子根节点之下定义的<strong>样式是私有</strong>的（大多情况是完全独立的），不会影响外部元素。当然也可以被外部样式所<strong>覆盖</strong>。</p></li><li><p>影子<code>DOM</code>中的<strong>事件</strong>部分会<strong>封闭</strong>在影子<code>DOM</code>中（比如<code>load</code>），部分则会<strong>向上冒泡、穿透影子</strong><code>DOM</code>、<code>target</code>发生相应变化（比如<code>focus</code>）。</p></li></ul><p>对于影子宿主来说，它既包含原本的<code>children[]</code>数组，也包含被附加的影子<code>DOM</code>，实现<strong>两者同时显示</strong>的机制如下：</p><ul><li><strong>影子根节点的后代始终显示在影子宿主内</strong></li><li>影子根节点的后代<strong>若包含一个<code>&lt;slot&gt;</code>元素</strong>，则宿主元素的阳光<code>DOM</code>子元素会<strong>作为<code>&lt;slot&gt;</code>的子元素</strong>一样显示，<strong>替代</strong>该插槽<strong>中的任何</strong>影子<code>DOM</code>元素。若此时宿主<strong>没有阳光<code>DOM</code>子元素</strong>，则该插槽中的影子<code>DOM</code>内容作为<strong>默认</strong>内容显示</li><li>影子根节点的后代若<strong>不包含<code>&lt;slot&gt;</code><strong>，则宿主的阳光<code>DOM</code>子元素</strong>永远不会显示</strong></li><li>影子根节点的后代若包含<strong>多个</strong><code>&lt;slot&gt;</code>，且通过<code>name</code>属性为它们命名，则宿主的阳光<code>DOM</code>子元素可以通过<strong>设置<code>slot=&quot;slotname&quot;</code>属性</strong>，来决定自己出现在哪个插槽中。</li></ul><blockquote><p>创建影子根节点并附加于影子宿主，通过调用宿主的<code>attachShadow()</code>方法，传入<code>&#123;mode:&quot;open&quot;&#125;</code>这个唯一的参数即可，返回值是影子根节点对象，同时也是宿主的<code>shadowRoot</code>属性的值，类型是<code>DocumentFragment</code></p></blockquote><h2 id="可伸缩矢量图形"><a href="#可伸缩矢量图形" class="headerlink" title="可伸缩矢量图形"></a>可伸缩矢量图形</h2><p><code>SVG(Scalable Vector Graphics)</code>是一种<strong>图片格式</strong>，<code>SVG</code>图形是对绘制期望图形的精确的、<strong>分辨率无关</strong>的描述，是在**文本文件<code>XML</code>**标记语言描述的。<code>SVG</code>本身有一套语法规则，比较复杂。</p><h3 id="在HTML中使用SVG"><a href="#在HTML中使用SVG" class="headerlink" title="在HTML中使用SVG"></a>在<code>HTML</code>中使用<code>SVG</code></h3><ul><li><code>&lt;img&gt;</code>标签中引入<code>.svg</code>图片</li><li>直接使用<code>&lt;svg&gt;</code>标签嵌入<code>SVG</code>，还可以使用<code>CSS</code>样式控制字体、颜色、线宽等，更多语法可参考文档<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" >SVG：可缩放矢量图形 | MDN (mozilla.org)<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="编程操作SVG"><a href="#编程操作SVG" class="headerlink" title="编程操作SVG"></a>编程操作<code>SVG</code></h3><p>使用<code>&lt;svg&gt;</code>标签的另一作用就是可以配合<code>JavaScript</code>更改状态</p><h3 id="通过JavaScript创建SVG图片"><a href="#通过JavaScript创建SVG图片" class="headerlink" title="通过JavaScript创建SVG图片"></a>通过<code>JavaScript</code>创建<code>SVG</code>图片</h3><p><code>SVG</code>严格来说仍是<code>XML</code>标签，而不是<code>HTML</code>标签，所以创建时应该用<code>createElementNS()</code>，示例<code>createElementNS(&quot;http://www.w3.org/2000/svg&quot;,&quot;svg&quot;)</code>，第一个参数是固定的，表示<code>XML</code>命名空间文字串</p><h2 id="lt-canvas-gt-与图形"><a href="#lt-canvas-gt-与图形" class="headerlink" title="&lt;canvas&gt;与图形"></a><code>&lt;canvas&gt;</code>与图形</h2><p><code>&lt;canvas&gt;</code>标签本身在<code>HTML</code>文档中并不可见，它只是创建了一个绘图表面以及暴露了一套基于<code>JavaScript</code>的<strong>强大的绘图<code>API</code><strong>。与<code>SVG</code>的区别就是要调用方法来绘图，而</strong>不是编辑<code>XML</code>文档</strong></p><p>在调用<code>getContext()</code>时传入<code>&quot;webgl&quot;</code>可以获得一个<code>3D</code>图形上下文，并使用<code>WebGL API</code>来绘制<code>3D</code>图形，实际开发大多使用基于<code>WebGL</code>的<strong>工具库</strong>，而不是直接使用<code>WebGL API</code>。</p><h3 id="路径与多边形"><a href="#路径与多边形" class="headerlink" title="路径与多边形"></a>路径与多边形</h3><p>绘制的思路：在使用<code>canvas</code>对象的<code>getContext()</code>方法<strong>获取图形上下文</strong>后，先<strong>新建</strong>路径，然后确定路径<strong>起点</strong>，再通过线段&#x2F;曲线段<strong>连接到下一个点</strong>（也被称为<strong>子路径</strong>），最后<strong>填充路径上的线</strong>或者被路径<strong>包围的区域</strong></p><p>涉及的<code>API</code>：</p><ul><li><p><code>beginPath()</code>（开始一个新路径）</p></li><li><p><code>moveTo()</code>（开始一个子路径，参数为起点的<code>x y</code>坐标）</p></li><li><p><code>lineTo()</code>（用线段连接下一个点，参数为下一个点的<code>x y</code>坐标）</p></li><li><p><code>closePath()</code>（关闭路径）</p></li><li><p><code>stroke()</code>（绘制路径中的线段）</p></li><li><p><code>fill()</code>（按<strong>路径绘制顺序</strong>的<strong>顺时针方向填充</strong>被路径包围的区域）</p></li></ul><blockquote><p>必须重新建立一个路径才能画新的子路径，否则会一直在当前路径绘制</p></blockquote><h3 id="画布的大小和坐标"><a href="#画布的大小和坐标" class="headerlink" title="画布的大小和坐标"></a>画布的大小和坐标</h3><p>画布的大小就是<code>&lt;canvas&gt;</code>中<code>width</code>乘<code>height</code>，同时也是画布的实际像素数量。所以最好要搭配<code>JavaScript</code><strong>在绘制图形前，将画布大小乘以<code>window.devicePixelRatio</code>来避免图形放大后变模糊。</strong>每个像素在内存中会分配四个字节。</p><p>画布坐标系原点默认画布左上角，<code>x</code>向右增大，<code>y</code>向下增大。</p><p>修改画布大小必须重置整个画布及其所有内容。</p><blockquote><p>（当然了，如果用户主动放大画布也可能导致变模糊）</p></blockquote><h3 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h3><p>同<code>CSS</code>属性一样，绘制时的图形状态由画布的指定属性决定，而不是给绘制方法传入参数，这被称为<strong>图形状态与绘制指令分离</strong>，以下是常用的一些属性：</p><ul><li>线条样式</li><li>颜色、模式与渐变</li><li>文本样式</li><li>阴影</li><li>半透明与合成效果</li><li>保存和恢复图形状态：每个<code>&lt;canvas&gt;</code>元素只有一个上下文对象，<strong>只允许定义一组</strong>图形属性，不过支持<code>save()</code>方法<strong>保存当前</strong>图形状态，<code>restore()</code>方法恢复<strong>最近一次</strong>保存的状态</li></ul><h3 id="画布绘制操作"><a href="#画布绘制操作" class="headerlink" title="画布绘制操作"></a>画布绘制操作</h3><p>除了之前基本的<code>API</code>，<code>canvas</code>还支持矩形、曲线、文本、位图图片等绘制方法</p><h3 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h3><p>每个画布的图形状态中都有一个”<strong>当前变换矩阵</strong>“，这个矩阵定义了画布的当前坐标系。多数画布操作中所指定的点<strong>是相对于当前坐标系的</strong>而不是默认坐标系，然后通过当前坐标变换矩阵<strong>将指定的点转化为默认坐标系中的点</strong>。</p><p>可以使用<code>setTransform()</code>方法更改当前变换矩阵，也可以使用<code>translate() rotate() scale()</code>来变换当前坐标系（更实用） </p><h3 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h3><p><code>clip()</code>方法可以定义一个剪切区域，这个区域外部将不会被绘制。</p><p>特点：当前路径本身会被剪切为当前的剪切区域，同时变为下一次剪切的当前路径，即<strong>剪切区域会越来越小，且没有办法重置剪切区域，所以最好要先保存以便恢复再剪切</strong></p><h3 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h3><p>像素级别的操作，有三个方法：</p><ul><li><code>getImageData()</code></li><li><code>createImageData()</code></li><li><code>putImageData()</code></li></ul><h3 id="Audio-API"><a href="#Audio-API" class="headerlink" title="Audio API"></a><code>Audio API</code></h3><p>想要在<code>HTML</code>文档中播放音乐，不一定要在其中包含<code>&lt;audio&gt;</code>或<code>&lt;video&gt;</code>元素，可以直接使用<code>Audio</code>构造函数动态创建<code>audio</code>元素，然后调用<code>play()</code>方法播放即可</p><h3 id="WebAudio-API"><a href="#WebAudio-API" class="headerlink" title="WebAudio API"></a><code>WebAudio API</code></h3><p>需要了解一定的电子音乐和信号处理知识，自己合成声音并播放</p><h2 id="位置、导航与历史"><a href="#位置、导航与历史" class="headerlink" title="位置、导航与历史"></a>位置、导航与历史</h2><p><code>Window</code>和<code>Document</code>对象的<code>location</code>属性引用的都是<code>Location</code>对象，该对象表示当前窗口显示的文档<code>URL</code>，可以使用<code>protocal hostname</code>等基本属性，也提供了在窗口中加载新文档的<code>API</code>。</p><p>给<code>Location</code>对象赋值一个字符串，会被解释为一个<code>URL</code>，然后浏览器会加载它，替换当前文档。值得注意，这样做会<strong>增加一条历史记录</strong>，而使用该对象的<code>replace()</code>方法则会将当前记录<strong>替换</strong>掉。</p><p><code>Window</code>对象的<code>history</code>属性引用的是当前窗口的<code>History</code>对象，表示当前窗口的文档和文档状态列表。</p><p>管理历史记录：</p><ul><li><code>hashchange</code>事件</li><li><code>history.pushState()</code>方法</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a><code>fetch()</code></h3><ul><li><p>使用步骤：</p><ol><li>调用<code>fetch()</code>，传入需要获取内容的<code>URL</code></li><li>在<code>HTTP</code>相应开始到达时取得第一步<strong>异步返回的响应对象</strong>，然后调用这个对象的某个方法，<strong>读取响应体</strong></li><li>取得第二步<strong>异步返回的响应体</strong>，<strong>按需处理</strong>它</li></ol></li><li><p>处理细节：</p><ul><li><p><code>HTTP</code>状态码、响应头和网络错误</p></li><li><p>设置请求参数 </p></li><li><p>设置请求头部</p></li><li><p>解析响应体</p></li><li><p>流式访问响应体</p></li><li><p>指定请求方法和请求体</p></li><li><p>通过<code>fetch()</code>上传文件</p></li><li><p>跨源请求</p></li><li><p>其他请求选项</p></li></ul></li></ul><h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p> <code>HTTP</code>天生不具备”在服务器发生事件时，接收来自服务器发送的通知“这种特性，但客户端可以选择在发送完请求后，<strong>两端都不关闭连接，此时服务器一旦有时间要通知客户端，可以将数据写入这个连接并保持打开</strong>。若连接关闭，客户端可以再次请求，重新打开一个新连接。</p><p>客户端可以使用<code>EventSource API</code>来实现这种长时间的连接。两端通过<code>SSE(Server-Sent Event,</code>服务器发送事件<code>)</code>协议传输信息。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><code>WebSocket</code></h3><p><code>WebSocket API</code>是一个复杂、强大的网络协议对外暴露的简单接口。</p><p>它与<code>SSE</code>相同的是，客户端必须建立连接，然后服务端才可以异步向客户端发送消息；不同的是，<code>WebSocket</code>支持二进制消息，而且消息可以双向发送</p><p>支持<code>WebSocket</code>的网络协议是对<code>HTTP</code>的拓展，<code>WebSocket</code>的标识连接端点不是<code>IP</code>和端口号，且<code>WebSocket URL</code>是以<code>ws://</code>开头，更重要的是，想要建立<code>WebSocket</code>连接，浏览器首先要建立一个<code>HTTP</code>连接，同时服务器也必须支持<code>WebSocket</code>协议。</p><ul><li>创建、连接和断开协议</li><li>通过<code>WebSocket</code>发送消息、接收消息</li><li>协议协商</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://example.com/stockticker&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><code>Web</code>应用可以使浏览器<code>API</code>在用户计算机本地存储数据，目的为了让浏览器记住一些信息。客户端存储遵守<strong>按照来源隔离</strong>，不同站点的数据互相不可访问，同一站点不同页面的数据可以互通（也算一种通信机制）。下面是客户端存储的几种形式：</p><h3 id="localStorage和sessionStorage"><a href="#localStorage和sessionStorage" class="headerlink" title="localStorage和sessionStorage"></a><code>localStorage</code>和<code>sessionStorage</code></h3><p>这两个属性都是引用的<code>window</code>对象的<code>Storage</code>对象，有以下特点：</p><ul><li><code>Storage</code>对象的属性值必须是字符串</li><li><code>Storage</code>对象中存储的属性是<strong>持久化</strong>的，用户刷新了页面仍可以访问之前存储的信息</li><li>相关方法有<code>getItem() setItem() deleteItem() clear()</code></li></ul><p><strong>生命周期和作用域</strong>：</p><p><code>localStorage</code>的存储周期是<strong>永久</strong>，除非用户手动删除。它的<strong>作用域是所有同源文档</strong>（同源：相同协议、域名和端口），即在作用域内是共享的，不过也会受浏览器限制，不同浏览器访问同一页面，它们的数据是互相不可见的。</p><p><code>sessionStorage</code>的存储周期取决于存储它的脚本所属的<strong>顶级窗口或浏览器标签</strong>，窗口或标签被<strong>永久关闭后，数据也随之删除</strong>。目前浏览器有恢复上次关闭的标签功能，所以数据存储周期看起来会更长一些。<code>sessionStorage</code>的<strong>作用域在窗口或标签页间隔离</strong>。</p><p><strong>存储事件</strong>：存储在<code>localStorage</code>中的数据发生变化时，都会触发<code>Window</code>对象的<code>storage</code>事件，事件范围是所有当前浏览同一网站的窗口。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><code>cookie</code></h3><p><code>cookie</code>是浏览器为特定网页或网站保存的少量命名数据，为服务端编程而设计的，会自动在浏览器与<code>Web</code>服务器之间传输。客户端则使用<code>document.cookie</code>来操作<code>cookie</code>属性</p><p><code>cookie</code>的属性主要是一组键值对，也包括用于控制生命周期和作用域的可选属性，比如<code>max-age</code>表示保存时间（单位秒）</p><p><code>cookie</code>的可见性（即作用域）有文档来源、文档路径决定：</p><ul><li>文档路径是可以通过<code>path</code>属性来设置。默认情况是，<code>cookie</code>关联着创建它的网页，以及与该网页位于相同目录和子目录下的其他网页。</li><li>文档来源则可以通过<code>domain</code>属性来控制，在一些大网站中往往需要跨子域名共享<code>cookie</code>，比如<code>cat.example.com</code>和<code>dog.example.com</code>，则可以设置<code>domain=&quot;.example.com&quot;</code>来实现共享。不可以设置为服务器父域名之外的其他域名。</li></ul><p><code>cookie</code>另一个属性<code>secure</code>，类型为布尔值，用于指定如何通过网路传输<code>cookie</code>值。默认是<code>false</code>，表示<code>cookie</code>是不安全的，会在普通的不安全<code>http</code>连接上传输。相反，那么<strong>就只能</strong>在浏览器与服务器通过<code>https</code>或其他<strong>安全协议连接</strong>时传输。</p><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a><code>IndexedDB</code></h3><p>它是一个<strong>对象数据库</strong>，作用域为包含文档的来源，每个来源可以有<strong>任意多个</strong><code>IndexedDB</code>数据库，但数据库名要唯一。</p><p>对于<code>IndexedDB API</code>来说，数据库就是<strong>一个名为对象存储的集合</strong>，对象存储中存储的是对象。每个对象<strong>必须有一个键</strong>，可以用于排序和检索。也可以在创建对象存储时指定一个属性为<strong>”键路径“</strong>，可以理解为索引，<strong>对象存储上</strong>可以定义<strong>任意数量的索引</strong>。</p><p><code>IndexedDB</code>存储特性之一为<strong>原子</strong>性，查询和更新会按照事务分组，要么全部成功，要么全部失败。、</p><p><strong>操作步骤：</strong></p><ol><li>打 开对应的数据库（通过名字）</li><li>创建一个事务对象（<strong>必须</strong>）</li><li>并使用该事务对象查找数据库中相应的对象存储（通过名字）</li><li>最后通过该对象存储的<code>get()</code>方法查询对象、<code>put()</code>方法存储新对象（会覆盖已有对象）、<code>add()</code>方法添加新对象（不覆盖）</li><li>按范围查询，则需要创建一个<code>IDBRange</code>对象并指定范围边界，然后作为参数传给查询方法<code>get() 、getAll() 或 openCursor()</code></li></ol><p>异步性：</p><p><code>IndexedDB API</code>是<strong>异步且基于事件</strong>，而不是基于期约，所以**不能用<code>async await</code>**来调用<code>API</code>。</p><p>事件：</p><p>除了创建事务、查找对象存储是同步，打开数据库、更新对象存储和查询存储或索引都是异步操作。这些异步方法都会<strong>立即返回一个请求对象</strong>，浏览器会在请求失败&#x2F;成功后触发<strong>失败&#x2F;成功事件<code>onerror/onsuccess</code><strong>，只有成功才能调用</strong>请求对象的<code>result</code>属性，即操作结果</strong>。</p><p>事务成功完成后，<strong>事务对象上会派发<code>complete</code>事件</strong>。</p><p><strong>第一次</strong>打开一个数据库&#x2F;增大一个已有数据库版号时，<code>indexedDB.open()</code>返回的请求对象会触发<code>upgradeneeded</code>事件，这意味着你需要在事件处理程序中手动定义或更新数据库的模式，<strong>比如创建对象存储以及在对象存储上定义索引</strong>。</p><blockquote><p>存储的对象使用<strong>结构化克隆算法</strong>序列化为对象存储，支持对象属性值为<code>Map Set</code>等类型</p></blockquote><h2 id="工作线程和消息传递"><a href="#工作线程和消息传递" class="headerlink" title="工作线程和消息传递"></a>工作线程和消息传递</h2><p><code>JavaScript</code>是<strong>单线程</strong>编程语言，因此浏览器不可能同时运行两个事件处理程序，也不会在运行一个事件处理程序的同时触发其他计时器，这样就<strong>无法并发更新</strong>文档状态或<code>Web</code>应用，且<strong>长时间运行某个函数</strong>，因为会导致<strong>事件循环阻塞</strong>。</p><p>浏览器通过<code>Worker</code>类提供了<strong>能与主线程和事件循环同时运行的线程</strong>，这种线程适合计算&#x2F;执行密集型任务，比如图像处理、实时解析用户输入等任务。</p><p><code>Work</code>类运行于独立的环境，<strong>拥有完全独立的全局对象</strong>，且<strong>只能通过异步消息机制</strong>与主线程通信，<strong>故不能并发修改</strong><code>Window</code>和<code>Document</code>对象，但是能<strong>很好地支持长时间运行的函数</strong>，不必担心阻塞事件循环、卡死浏览器。</p><h3 id="Worker对象"><a href="#Worker对象" class="headerlink" title="Worker对象"></a><code>Worker</code>对象</h3><p>使用步骤：</p><ol><li>创建新的工作线程<ul><li>调用<code>Worker()</code>构造函数，传入<code>URL</code>–指定需要执行的<code>JavaScript</code>代码。（支持相对&#x2F;绝对路径）</li></ul></li><li>向工作线程发送数据<ul><li>使用<code>postMessage()</code>方法，出给该方法的值会被结构化克隆算法复制一份副本，然后通过事件发送给工作线程</li></ul></li><li>从工作线程接收消息<ul><li>使用<code>onmessage</code>或者<code>addEventListener()</code>，消息保存在事件对象的<code>data</code>属性中（同理支持<code>removeEventListener()</code>）</li></ul></li><li>强制停止工作线程<ul><li>这也是<code>Worker</code>对象最后的方法了<code>terminate()</code></li></ul></li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> w = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;utils/testWorker.js&quot;</span>)</span><br><span class="line">w.<span class="title function_">postMessage</span>(<span class="string">&quot;Hello！&quot;</span>)</span><br><span class="line">w.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> stats = e.<span class="property">data</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(stats)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作线程中的全局对象"><a href="#工作线程中的全局对象" class="headerlink" title="工作线程中的全局对象"></a>工作线程中的全局对象</h3><p>在上一节提到，<code>Worker()</code>构造函数中的<code>URL</code>所指定的代码会被放在也给<strong>新的、干净的<code>JavaScript</code>执行环境</strong>中执行，与创建工作线程的脚本<strong>完全隔离</strong>，这个新环境中的全局对象是一个<code>WorkerGlobalScope</code>对象，<strong>组成内容</strong>比<code>JavaScript</code><strong>核心多一些</strong>东西，比客户端**<code>Window</code>对象少一点<strong>东西，也就是说</strong>大部分客户端<code>JavaScript</code>能做的，工作线程里也能做到**，甚至是嵌套创建自己的工作线程。</p><p>和主线程通信：</p><ul><li><p>该全局对象也有<code>postMessage()</code>和<code>onmessage</code>事件处理程序，只不过和<code>Worker</code>对象中的<strong>目标及方向正好相反</strong>。</p></li><li><p><code>Worker()</code>对象支持传入<strong>一个对象作为第二个参数，该对象中的属性会作为<code>WorkerGlobalScope</code>对象的属性</strong></p></li><li><p>该全局对象可以调用<code>close()</code>方法终止自己，效果同<code>terminate()0 </code></p></li></ul><h3 id="在工作线程中导入代码"><a href="#在工作线程中导入代码" class="headerlink" title="在工作线程中导入代码"></a>在工作线程中导入代码</h3><p>浏览器支持<code>Worker</code>的时候，<code>JavaScript</code>还不支持模块系统，所以工作线程有一套独特的导入外部代码机制，即<code>importScripts()</code>方法，参数为需要载入的外部代码文件路径。</p><p><strong>该方法是同步</strong>的，且不会跟踪已加载的脚本，也不会阻止循环依赖</p><p>工作线程也支持<strong>导入模块</strong>，只需要在<code>Worker()</code>构造函数的第二个参数中，设置属性<code>type=&quot;module&quot;</code></p><h3 id="工作线程执行模型"><a href="#工作线程执行模型" class="headerlink" title="工作线程执行模型"></a>工作线程执行模型</h3><p>执行顺序也分同步阶段和异步阶段，前者是自上而下运行自己的代码和导入所有模块及脚本，后者则是开始对事件和定时器进行监听和响应。</p><p>工作线程会在不可能启动新任务的时候，自动安全退出。一般不建议工作线程主动终止自己</p><p>工作线程中的错误，如果没有被捕获且适当处理，则会在全局对象上触发<code>error</code>事件</p><h3 id="消息端口对象"><a href="#消息端口对象" class="headerlink" title="消息端口对象"></a>消息端口对象</h3><p>前几节讲的<code>postMessage()</code>函数<strong>实质</strong>是调用在创建工作线程时<strong>一起创建的一对<code>MessagePort</code>消息端口对象</strong>的<code>postMessage()</code>方法实现通信的，客户端<code>JavaScript</code>无法直接访问这两个端口对象，但是可以通过<code>MessageChannel()</code>构造函数创建一对新的关联端口。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span></span><br><span class="line"><span class="keyword">let</span> userPort = channel.<span class="property">port1</span></span><br><span class="line"><span class="keyword">let</span> workPort = channel.<span class="property">port2</span></span><br></pre></td></tr></table></figure><p><code>MessageChannel</code>对象有两个属性<code>port1 port2</code>，<strong>这两个属性引用一对关联的<code>MessagePort</code>对象，可以互相通信</strong>，即通过<code>postMessage()</code>方法和<code>onmessage</code>事件处理程序。</p><p>通信过程中，所发送的消息会先被存在<strong>一个队列</strong>中，直到端口定义了<code>onmessage</code>属性或者<strong>同时调用了<code>addEventListener()</code>以及<code>start()</code>方法（重要）</strong>，才会被信道的另一端接收。</p><p><code>postMessage()</code>方法支持第二个参数（数组类型），代表把数组中的元素<strong>移动到</strong>（而不是复制）<strong>信道的另一端</strong>。</p><p>这样可以让<strong>多个信道与主线程通信</strong>，只需要<strong>把<code>MessagePort</code>对象通过<code>postMessage()</code>方法移到信道的另一端</strong>，然后通过消息对象取出和使用。需要注意，此时端口对象需要<strong>同时出现</strong>在<code>postMessage()</code>方法的<strong>第一个和第二个参数</strong>中，才能<strong>使该端口对象在主线程失效</strong>。</p><h3 id="通过postMessage-跨源发送消息"><a href="#通过postMessage-跨源发送消息" class="headerlink" title="通过postMessage()跨源发送消息"></a>通过<code>postMessage()</code>跨源发送消息</h3><p>同理，不同源的<code>Window</code>对象也可以使用自带的<code>postMessage()</code>方法互相通信。不过参数列表会有些不同。</p><blockquote><p>即便同源策略阻止脚本访问另一个窗口的内容，仍然可以调用另一个窗口的<code>postMessage()</code>方法，来触发该窗口的<code>message</code>事件处理程序。</p></blockquote><h1 id="Node服务器端JavaScript"><a href="#Node服务器端JavaScript" class="headerlink" title="Node服务器端JavaScript"></a><code>Node</code>服务器端<code>JavaScript</code></h1><p><code>Node</code>是<code>Javascript</code>与底层操作系统绑定的结合，从而让<code>JavaScript</code>程序读写文件、执行子进程以及实现网络通信，让<code>JavaScript</code>成为一种通用的编程语言。<code>Node</code>的典型特点是其默认异步的<code>API</code>赋能的单线程基于事件的并发能力。</p><h2 id="Node程序的构成"><a href="#Node程序的构成" class="headerlink" title="Node程序的构成"></a><code>Node</code>程序的构成</h2><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p><code>console.log</code>是向标准输出流发送输出的主要方式</p><h3 id="命令行和环境变量"><a href="#命令行和环境变量" class="headerlink" title="命令行和环境变量"></a>命令行和环境变量</h3><p><code>Node</code>遵循<code>Unix</code>的惯例，程序的输入首先是从命令行参数获取，其次是从环境变量中获取，前者可以从字符串<code>process.argv</code>中获取，后者从<code>process.env</code>中获取</p><h3 id="程序的生命期"><a href="#程序的生命期" class="headerlink" title="程序的生命期"></a>程序的生命期</h3><p><code>Node</code>基本是自顶向下执行文件中的<code>Javascript</code>代码，很多<code>Node</code>程序会在执行完文件里的最后一行代码时退出，不过，也有很多会在此之后持续运行很长一段时间。<code>Node</code>程序<strong>通常是异步的，基于回调和事件处理程序，且在运行完初始文件、调用完所有回调、不再有未决之事之前不会退出。</strong></p><p>由于<code>Node</code>程序天生异步，发生在回调和事件处理程序中的异常必须局部处理。</p><h3 id="Node模块"><a href="#Node模块" class="headerlink" title="Node模块"></a><code>Node</code>模块</h3><p><code>Node</code>是在<code>JavaScript</code>有模块系统<strong>之前创造的，所以<code>Node</code>必须自己创造一个模块系统</strong>（也被称为<code>CommonJS</code>模块），使用<code>require() module.expxorts</code>来处理模块的值的导入&#x2F;导出。<code>Node 13</code>增加了对<code>ES6</code>模块的支持，但<code>ES6</code>模块和<code>CommonJS</code>模块并不完全兼容，故<code>Node</code>在加载模块之前，会通过文件拓展名、<code>package.json</code>文件等方式确定模块的类型。</p><h3 id="Node包管理器"><a href="#Node包管理器" class="headerlink" title="Node包管理器"></a><code>Node</code>包管理器</h3><p>一个名为<code>npm</code>的程序会随着<code>node</code>一并安装，这就是<code>Node</code>的包管理器，它通过位于程序根目录的<code>package.json</code>文件（同样是由<code>npm</code>创建的）帮助你下载和管理程序的依赖库</p><h2 id="异步api和并发风格"><a href="#异步api和并发风格" class="headerlink" title="异步api和并发风格"></a>异步<code>api</code>和并发风格</h2><p><code>Node</code><strong>不是通过线程来实现并发的</strong>，这一点与大多数编程语言不同。<code>Node</code>是针对<code>I/O</code>密集型程序（比如网络服务器）进行优化的，这一点和<code>Javascript</code>的通用性有所不同。</p><p><code>Node</code>通过让<strong>其<code>API</code>默认异步和非阻塞</strong>（当然也有同步的<code>api</code>，并带有<code>Sync</code>的字样）来实现高层次的并发，并同时保持单线程的编程模型。一般来说，你传给异步<code>Node</code>函数的最后一个参数始终是一个回调。除此之外，<code>Node</code>也有一些<code>API</code>使用基于事件的异步机制，通常用于处理流数据。</p><p>基于事件的并发的核心是<code>Node</code>用单线程是运行一个“事件循环”，有事件时工作没有则进入睡眠状态，如此循环。</p><h2 id="基本数据类型、缓冲区和流"><a href="#基本数据类型、缓冲区和流" class="headerlink" title="基本数据类型、缓冲区和流"></a>基本数据类型、缓冲区和流</h2><p><code>Node</code>中一个比较常用的数据类型<code>Buffer</code>，常用于从文件或网络数据中读取数据。<code>Buffer</code>类（或称为缓冲区），是<strong>字节序列</strong>，是设计用来操作<code>Javascript</code>字符串的，当然也常用于操作二进制数据。</p><p>在一般处理数据的算法中，会将要处理的所有数据读取到内存中，进行处理，再把数据写到某个地方。这种方式要求要有足够大的内存空间，还可能扛不住高并发的请求，在一个缺点就是不能<strong>在读旧文件之前就写新文件</strong>。解决这类问题的办法就是使用“流”，<code>Node</code>支持可读流、可写流、双工流和转换流。  </p><p>有时候需要从流中读取的数据写入另一个流，可以简单管道进行连接，必要时可以自定义一个流。</p><h2 id="操作文件系统"><a href="#操作文件系统" class="headerlink" title="操作文件系统"></a>操作文件系统</h2><p><code>Node</code>的<code>fs</code>模块是用于操作文件和目录的综合性<code>API</code>，<code>path</code>模块是<code>fs</code>模块的补充。<code>fs</code>模块中大多是对<code>Unix</code>系统调用（及其<code>Window</code>对应操作）的低级<strong>绑定</strong>，但也有很多高级函数，以及相应定义了大量变体，比如基于同步阻塞的变体、基于期约的异步变体。</p><h2 id="编写http客户端和服务端"><a href="#编写http客户端和服务端" class="headerlink" title="编写http客户端和服务端"></a>编写<code>http</code>客户端和服务端</h2><p><code>Node</code>的<code>http https http2</code>模块是功能完整但相对低级的<code>HTTP</code>协议的实现，定义了实现<code>HTTP</code>客户端和服务端的所有<code>API</code>，可以用来开发简单的服务器</p><h2 id="编写非http客户端和服务端"><a href="#编写非http客户端和服务端" class="headerlink" title="编写非http客户端和服务端"></a>编写非<code>http</code>客户端和服务端</h2><p><code>Node</code>完全支持其它类型的网络服务器和客户端，使用<code>net</code>模块就可以建立<code>tcp</code>服务器</p><h2 id="创建子线程和子线程通信"><a href="#创建子线程和子线程通信" class="headerlink" title="创建子线程和子线程通信"></a>创建子线程和子线程通信</h2><p><code>Node</code>同样非常适合编写执行其他程序的脚本，常用到<code>child_process</code>模块。</p><h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p><code>Node</code>的并发模型是基于单线程、基于事件的，但从第十版开始支持正真的多线程编程，提供了由浏览器定义的<code>Web Workers API</code>非常相似的一套<code>API</code>。<code>JavaScript</code>线程<strong>默认</strong>不共享内存，只能通过消息传递来通信。主要工作是处理工作线程和父线程之间的通信。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[ 2 ]: <a class="link"   href="https://book.douban.com/subject/35175321/" >https://book.douban.com/subject/35175321/<i class="fas fa-external-link-alt"></i></a>“JavaScript高级程序设计（第四版）”<br>[ 3 ]: <a class="link"   href="https://book.douban.com/subject/35396470/" >https://book.douban.com/subject/35396470/<i class="fas fa-external-link-alt"></i></a>“JavaScript权威指南（第七版）”<br>[ 4 ]: <a class="link"   href="https://www.bilibili.com/video/BV1Y84y1L7Nn" >https://www.bilibili.com/video/BV1Y84y1L7Nn<i class="fas fa-external-link-alt"></i></a> “黑马程序员前端JavaScript入门到精通”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hello-javascript&quot;&gt;&lt;a href=&quot;#hello-javascript&quot; class=&quot;headerlink&quot; title=&quot;hello,javascript!&quot;&gt;&lt;/a&gt;&lt;code&gt;hello,javascript!&lt;/code&gt;&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    <category term="学习记录" scheme="https://laihandong.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="https://laihandong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【工程实践】基于hexo搭建博客</title>
    <link href="https://laihandong.github.io/2023/06/05/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://laihandong.github.io/2023/06/05/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%91%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-06-05T04:23:04.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本着想把使用hexo搭建博客网站的过程做个记录，删删改改一大段发现，其实和官网的教程别无二致，索性贴上官网的链接，以备之后查询。</p><p><a class="link"   href="https://hexo.io/zh-cn/" >Hexo<i class="fas fa-external-link-alt"></i></a>官方文档</p><p><a class="link"   href="https://easyhexo.com/" >Easy Hexo 👨‍💻<i class="fas fa-external-link-alt"></i></a>是一个对小白友好的入门<code>hexo</code>教程，很赞！</p><p><a class="link"   href="https://keep-docs.xpoet.cn/" >Keep 主题使用指南 | Hexo 主题 Keep 官方文档 (xpoet.cn)<i class="fas fa-external-link-alt"></i></a>这是使用基于<code>hexo</code>的自定义主题的教程，同样很赞！</p><p><a class="link"   href="https://picx.xpoet.cn/#/upload" >上传图片 | PicX (xpoet.cn)<i class="fas fa-external-link-alt"></i></a>这是<strong>一款基于 GitHub API 开发的图床工具，提供图片上传托管、生成图片链接和常用图片工具箱服务</strong>，强烈推荐使用在博客网站图片资源配置中。</p><p><a class="link"   href="https://cloud.tencent.com/" >腾讯云 产业智变·云启未来 - 腾讯 (tencent.com)<i class="fas fa-external-link-alt"></i></a>，即使是静态网站，在接入评论板块时也不得不用到云服务来<strong>储存评论和文本过滤</strong>（在大陆地区使用还得是腾讯云这些国产服务靠谱）。</p><p>以上工作做完，得到一个网站项目（可以建立本地网络服务器进行预览和调试）。接着可以使用项目托管将网站上线，我用的是<code>Github Pages</code>，布置好之后就可以通过本地<code>git</code>推送完成博客在线更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本着想把使用hexo搭建博客网站的过程做个记录，删删改改一大段发现，其实和官网的教程别无二致，索性贴上官网的链接，以备之后查询。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://hexo.io/zh-cn/&quot; &gt;Hexo&lt;i class=&quot;fa</summary>
      
    
    
    
    <category term="工程实践" scheme="https://laihandong.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="hexo" scheme="https://laihandong.github.io/tags/hexo/"/>
    
    <category term="博客搭建" scheme="https://laihandong.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>【踩坑（解决）】hexo部署后页面资源加载失败</title>
    <link href="https://laihandong.github.io/2023/05/26/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91hexo%E9%83%A8%E7%BD%B2%E5%90%8E%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/"/>
    <id>https://laihandong.github.io/2023/05/26/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91hexo%E9%83%A8%E7%BD%B2%E5%90%8E%E9%A1%B5%E9%9D%A2%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/</id>
    <published>2023-05-26T17:21:41.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我修改了<code>hexo</code>项目根目录下的<code>_config.yml_</code>配置中的<code># Site</code> 和<code># URL</code>中的几个选项后，重新部署发现我的网站页面是如下这种效果：</p><p><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202305270124298.webp"                      alt="image-20230527012402957"                ></p><p>看样子是加载不到相应的静态资源导致的：</p><p><img                       lazyload                     alt="image"                     data-src="https://images-1258290850.cos.ap-guangzhou.myqcloud.com/blog/202305270137294.webp"                      alt="image-20230527013649947"                ></p><p>猜测是跟<code>url</code>相关的配置没有设置合理的值所导致的，我修改过的只有<code># URL</code>下的<code>url</code>这一个选项，如下：</p><p><code>url: &#39;https://github.com/laihandong/laihandong.github.io&#39;</code></p><p>问题显然，那么解决方案就是改为正确的地址，如下：</p><p><code>url: &#39;https://laihandong.github.io/&#39;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我修改了&lt;code&gt;hexo&lt;/code&gt;项目根目录下的&lt;code&gt;_config.yml_&lt;/code&gt;配置中的&lt;code&gt;# Site&lt;/code&gt; 和&lt;code&gt;# URL&lt;/code&gt;中的几个选项后，重新部署发现我的网站页面是如下这种效果：&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="踩坑记录" scheme="https://laihandong.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="hexo" scheme="https://laihandong.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【踩坑（解决）】Git提交时提示换行符转换问题</title>
    <link href="https://laihandong.github.io/2023/05/26/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91Git%E6%8F%90%E4%BA%A4%E6%97%B6%E6%8F%90%E7%A4%BA%E6%8D%A2%E8%A1%8C%E7%AC%A6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <id>https://laihandong.github.io/2023/05/26/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91Git%E6%8F%90%E4%BA%A4%E6%97%B6%E6%8F%90%E7%A4%BA%E6%8D%A2%E8%A1%8C%E7%AC%A6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-26T17:12:15.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我是使用<code>hexo d -g</code>部署博客时，在<code>INFO  Copying files from extend dirs...</code>这一步会弹出很多类似以下语句的警告：</p><p><code>warning: in the working copy of &#39;index.html&#39;, LF will be replaced by CRLF the next time Git touches it</code></p><p>这个意思是说，当git提交文档时，会根据目标平台的操作系统来决定是否要将<code>LF</code>换成<code>CRLF</code>（或者反过来）</p><p>至于<code>LF CRLF</code>是什么，可自行百度</p><p>我们可以通过设置<code>Git</code>的配置选项来告诉它是否在每次提交时进行转换：</p><p><code>git config --global core.autocrlf false</code></p><p><code>git config --global core.autocrlf true</code></p><p><code>git config --global core.autocrlf input</code></p><p>（根据自己的实际情况，三者选其一，能解决问题即可）</p><blockquote><p>相关讨论：<a class="link"   href="https://stackoverflow.com/questions/170961/whats-the-strategy-for-handling-crlf-carriage-return-line-feed-with-git" >cross platform - What’s the strategy for handling CRLF (carriage return, line feed) with Git? - Stack Overflow<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我是使用&lt;code&gt;hexo d -g&lt;/code&gt;部署博客时，在&lt;code&gt;INFO  Copying files from extend dirs...&lt;/code&gt;这一步会弹出很多类似以下语句的警告：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;warning: in the wor</summary>
      
    
    
    
    <category term="踩坑记录" scheme="https://laihandong.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="git" scheme="https://laihandong.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【入门】docker</title>
    <link href="https://laihandong.github.io/2023/05/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91docker/"/>
    <id>https://laihandong.github.io/2023/05/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91docker/</id>
    <published>2023-05-24T00:00:00.000Z</published>
    <updated>2024-10-23T16:29:22.068Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker</code>不是一项新技术，而是<strong>虚拟化</strong>技术发展中的一个产物，<code>Docker</code>是容器化技术中较为主流的一个方案，同时也是一种轻量级的虚拟化。 </p><p><code>Docker</code>中主要的三个概念分别是<code>dockerfile image container</code>，了解这三者的工作机制就能掌握<code>Docker</code>大部分知识。如果只是简单的（不严谨的）类比的话，可以将<code>dockerfile</code>理解为<strong>源代码</strong>，<code>image</code>是由源代码编译而来的<strong>可执行文件</strong>，<code>container</code>就是可执行文件运行起来的<strong>进程</strong>。所以，只有<strong>足够了解自己开发的项目</strong>的工作流程和需求，你才能编写出明确的<code>dockerfile</code>，从而流畅优雅地使用<code>docker</code>。</p><p>至于网络上有种说法，<code>build once, run everywhere</code>，这是不准确的的。<code>docker</code>的底层是建立在<code>linux kernel</code>提供的诸多特性上的，在非<code>linux</code>平台上工作时更是如此。所以只要我们的项目不涉及<code>docker</code>底层的工作机制，那么也可以相对来说是，<code>build once, run everywhere</code>。反之出现问题，大抵可以归咎于<code>docker</code>没有做好对各个操作系统的兼容性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;不是一项新技术，而是&lt;strong&gt;虚拟化&lt;/strong&gt;技术发展中的一个产物，&lt;code&gt;Docker&lt;/code&gt;是容器化技术中较为主流的一个方案，同时也是一种轻量级的虚拟化。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code</summary>
      
    
    
    
    <category term="学习记录" scheme="https://laihandong.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="docker" scheme="https://laihandong.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【踩坑（解决）】微信开发者工具--cli命令行进程“卡住”</title>
    <link href="https://laihandong.github.io/2023/05/18/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7--cli%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E7%A8%8B%E2%80%9C%E5%8D%A1%E4%BD%8F%E2%80%9D/"/>
    <id>https://laihandong.github.io/2023/05/18/%E3%80%90%E8%B8%A9%E5%9D%91%EF%BC%88%E8%A7%A3%E5%86%B3%EF%BC%89%E3%80%91%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7--cli%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E7%A8%8B%E2%80%9C%E5%8D%A1%E4%BD%8F%E2%80%9D/</id>
    <published>2023-05-18T00:00:00.000Z</published>
    <updated>2024-10-23T16:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>python</code>第三方库<code>subprocess</code> 调用微信开发者工具的命令行接口<code>cli login</code>时，进程疑似卡死，总会在<code>p.communicate</code>或者<code>p.wait</code><strong>卡住</strong></p><p>问题分析：</p><p>1.<code>cli login</code> 该命令属于<strong>需要交互的命令</strong>，即正常在<code>cmd</code>中运行时，它会先输出二维码，等待用户扫码，<strong>扫码确认登陆后进程才会结束</strong>。</p><p>2.微信开发者命令行工具 <code>cli </code>本质是启用<strong>集成在软件安装目录下的node环境调用js脚本来实现的</strong></p><p>3.<code>js</code>又默认把输出缓存在内存中，而<strong>不会立即把输出传回给调用调用命令的python脚本</strong>。导致<code>python</code>脚本<strong>捕捉不到</strong>包含二维码信息的<strong>输出</strong>，且<strong>一直等待用户登录，进程就不会结束</strong></p><p>4.通过任务管理器关闭 微信开发者工具 的进程，该命令的进程仍不会结束，依然卡住。猜测就是，使用命令行调起的进程，和双击 微信开发者工具 调起的进程，两者互不影响？</p><p>验证：同时启动<code> 微信开发者工具.exe</code> 和 <code>cli login</code>，两者都会弹出登录二维码。扫描登录后者的二维码进行登录，<code>cli login</code> 进程结束的同时，微信开发者工具也会跳转到项目配置页面。但是扫描前者的二维码进行登陆后，<code>cli login</code>仍然卡在<code>“\ waiting for scan and login”</code>，不会结束</p><p>事实证明：<strong>想将微信开发者工具集成到自己的测试工具中，不推荐使用类似cli login等需要交互的命令行</strong></p><p>其他尝试：</p><p>有尝试过新建两个<code>streamReader</code>，并为它们各自新建一个进程，实时读取<code>cli login</code>的输出，这样就不会等待该进程结束后才拿得到二维码</p><p>但是事实上发现拿到的二维码是不连续的，中间会被其它输出隔断。大致描述就是，输出一半的二维码，然后有几行字，再出现一半的二维码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;python&lt;/code&gt;第三方库&lt;code&gt;subprocess&lt;/code&gt; 调用微信开发者工具的命令行接口&lt;code&gt;cli login&lt;/code&gt;时，进程疑似卡死，总会在&lt;code&gt;p.communicate&lt;/code&gt;或者&lt;code&gt;p.wai</summary>
      
    
    
    
    <category term="踩坑记录" scheme="https://laihandong.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="微信开发者工具" scheme="https://laihandong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
