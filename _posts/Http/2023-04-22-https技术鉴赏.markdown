---
title: http（基本概念）
date: 2023-04-22 08:00:00
categories: 
- [计算机网络,http]
---



首先得明白上网冲浪，说白了就是从人家的服务器上拿取数据而已。在如何拿得安全这个问题上，就不得不提到https了。

假设一个场景，你在广州的某台电脑上，访问一个位于北京的服务器上的网站信息，中间大概率是要经过很多个路由的（可以理解为中转站）。我们都知道二手货的概念，类比一下，这些信息那就是经过多重中转的N手货了哈哈。

基于以上场景，这些信息如果是明文传输（可以理解为大白话，是个人就能看懂），那么在传输过程中就被人看光光了，这就会有监听、窃取、劫持甚至修改之类的风险。所以行业内有句话叫“关 皆 黑”（这就不多讲了）

1994年，当时的巨头网络公司网景实现了浏览器对https协议的支持，其中s代表安全（secure），该协议实现的方法当然是“加密”。把人能看得懂的大白话信息，加密成人看不懂只有机器看得懂的“密文”。服务器将信息加密再传输，人收到信息后进行解密即可。

即使攻击者在信息传输过程中拿到了密文，他不知道如何解密的话，也无可奈何。而当时世界上常用的加密算法有凯撒密码、恩格玛机、DES，这几个加密算法都有一个共同点，就是都需要一个“密钥”来对数据加密。
服务器用“密钥”把（大白话）明文加密成密文，接收人用**同样的密钥**将密文进行解密为明文。因为整个加解密过程使用相同的“密钥”，所以这也被称为“对称加密”。但这种类型的加密算法，用在互联网上，都会有一个大问题：就是成千上万的浏览器（也就是我们使用者）如何拿到这个服务器用来加密他的网站信息的密钥呢，先把密钥用明文发给我们还是跟服务器站长通个电话向他要呢？如果我们能拿到，那么攻击者也就一定能拿到。这也就回应了上个段落中的第一句话“*即使攻击者在信息传输过程中拿到了密文，他不知道如何解密的话，也无可奈何*”。

更实际的方法是结合“非对称加密”，也就是在整个信息的加解密过程中，用不同的密钥来加密，加密有加密的密钥，解密有解密的密钥，并且**它们总是成对出现**的，也就是说被公钥加密的数据只能用私钥进行解密，被私钥加密的数据只能用公钥进行解密，他们甚至不能解密由自己的加密的密文（像是一对傲娇宿敌的感觉哈哈）。  
基于“非对称加密”，服务器首先生成公钥，然后把公钥广播出去给到用户浏览器，浏览器生成一串随机数据，并用收到的公钥进行加密，再将**这个由公钥加密的随机数据**发送给服务器，服务器**用自己的私钥进行解密**，得到这个**随机数据**。也就是说，**服务器和用户两端都有了一份相同的随机数据**
，一份只能由服务器的私钥进行解密的数据，即使在传输过程中攻击者被劫持了，他拿不到服务器的私钥也无可奈何。从而，**这份随机数据就可以当成“对称加密”中的那个唯一密钥**，来进行加密通信。
综上，服务器和使用者使用“非对称加密”协商出一个随机密钥，作为“对称加密”的密钥进行正式通信，这就是https中s的大致原理。但它（https）本质上还是基于http流程，也被称为【安全套接字层】(Secure Sokect Layer，即SSL)，之前提到的协商密钥过程也叫做SSL握手。



自1994年，SSL就一直在不断发展和更新，1999年经相关国际组织标准化后，改名为TLS，其后续的发展中的部分核心工作都是对安全性进行升级。我们所讨论的安全性，其一是指，一旦该协议使用的加密算法被攻破后，它将逐渐丧失安全性；其二则是传输机制上信任问题，以下将详细讲解


非对称加密协商出的密钥，这在机制上就是几乎不可能直接拿到的(除非加密算法被破解)。但是有一种情况，仍是“非对称加密”没有考虑到的，就是**代理**。
攻击者通过劫持，拿到了服务器的公钥，并替换成自己的公钥发送给用户。用户并没有鉴定公钥是否真的为服务器的这样的能力，所以用户会使用这个经攻击者掉包后的公钥进行加密。攻击者只用在收到经自己的公钥加密后的用户数据，使用自己的私钥进行解密。这就在理论上取代了用户，即可以以明文形式获取用户发给服务器的任何信息，跟服务器进行SSl握手，拿到对称加密的密钥。综上，我们发现一个机制上的漏洞：**公钥并不能自己表明属于谁**
在弥补这个机制上的漏洞问题上，我们经历了以下几个“时代”：

第三方机构
服务器将自己的公钥跟一些服务器标志性的信息（比如使用者、机构、序列号等）整合为一个集合，将其发送给第三方机构。第三方机构（也有自己的公私钥对）会用自己的私钥对这个数据集合进行加密--被称为“签名”。之后，第三方机构将签名和原始的明文数据集合放在一起返回给服务器，这就是TLS证书。所提到的第三方机构就是CA，并不是谁都可以当第三方机构的，截至目前，所谓的CA都屈指可数，几乎所有系统以及浏览器都会内置这些机构。
此后，服务器发送给用户的就是包含公钥的TLS证书。用户收到后，则会先验证这个公钥是否真的为服务器，即验证公钥的合理性和正确性。验证方法就是，拿到CA机构的公钥对签名进行解密，和证书的明文数据进行对比，若一致则通过验证，并进行接下来的SSL握手和正式通；若不通过验证，浏览器会弹出“该网站有风险”、“您的连接不是私密链接”等提示。
至此，从机制上来讲，攻击者若进行公钥的替换则必然通过不了用户的验证，之前提到的攻击者恶意**代理**的问题也得到解决，但同时，它也带来了另一个问题。
假如攻击者自己也申请了一份TSL证书，同样以劫持和替换的方式发给用户，大部分情况也是行不通的。因为证书上的其他信息不能保证完全一致，最明显的就是服务器的域名或者ip。但此时如果CA错误的（甚至有意的）给攻击者颁布一个伪证书，就可以轻易地获取用户的信任。（这就涉及到社会交际层面的套路了，在此不多谈。用户浏览器、服务器、CA、攻击者有没有可能有时候会是同一个人/组织？）

证书透明Certificate Transparency(简称CT)
在加入CT的安全机制下，要求CA每次颁发一个证书时，都要向一个日志服务的角色提交该证书的详情，该日志服务在记录这次信息的同时，生成一个SCT数据与证书一并返回（可以理解为之前提到的”签名“）。CA将SCT数据加入证书的拓展中，作为最终颁发给服务器的证书。这样用户在TLS握手时不仅要验证CA还要验证SCT。
看上去所谓CT生成的SCT理论上也能造假，是CA机制的套娃，但”去中心化“的概念让CT的透明性得以保障。日志服务一般采用的区块链中【Merkle tree】（一个多重哈希值节点的树）来防止篡改。这样大家（一般指利益相关方，比如CA）就可以监督该日志有无被篡改来判断其下是否有非法颁发的证书。随着这么多年的努力，该CT机制也得到全球范围的推行。

但信息安全的路还远远不止
