---
title: 题解思路总结
date: 2023-04-30 08:00:00
categories: 
- [剑指offer,刷题总结]
---



1. 在数组里找有几种数字是重复的。

```c++
//遍历数组，把第一次遇到的数字push_back进准备好的vector，第二次遇到这个数时则一定会在这个准备好的vector中找到这个数。
```

2. 在数字都按行、列递增的矩阵中，找到某一个数是否存在

```c++
// 因为数是往下走增大，往右走增大的变化趋势，所以矩阵左下角的数开始找，不够大就往右走，不够小就往上走。
//这样做的话，每一次比较就能排除某一列（行）的元素是不符合的。
```

3. 将链表按从尾到头的顺序返回每个节点的值，规定传入的参数只有链表的头节点。

```c++
//写一个递归函数和一个调用该递归函数的接口函数即可，用来存储变量的数组需要定义在这两个函数之外。
```

4. 将字符串中所有空格都替换成'%20'

```c++
//遍历是肯定的，然后准备一个临时字符串，遇到空格则加上“%20”，最后返回这个临时字符串string类型
//当然，可以一个一个字符加到临时字符串里，也可以根据下标与长度，用string的函数substr复制子串一块一块加进去
```

5. 找到链表中倒数第k个节点

```c++
//用双指针法，一个快一个慢，快的那个指针先走k个节点，然后再同步走即可。
```

6. 求二叉树的最大深度（即高度）

```c++
//分治法，求左子树高度和右子树高度，取最大的然后再+1，就是以目前节点为根节点的子树的高度。
//递归，第一是要有终止条件，第二是要合理设置返回的数值。这两个地方都会有return，而且返回的数是有一定关系的。
```

7. 求连续子数组最大和

```c++
//首先要考虑动态规划，也就是以array[i]结尾的子数组（可以只包含array[i]一个元素）的和，是通过以array[i-1]结尾的子数组的和来确定的。是array[i]+前面的子数组（以array[i-1]）的和更大，还是array[i]自成一组的和更大，取最大的值作为以array[i]结尾的子数组的和。
//确定了每一个array[i]在以各自为结尾的子数组的最大和后，最大的那个值就是整个数组的最大值。
```

8. 求连续子数组最大和（二）

```c++
//在上一题的基础上，要求返回长度最大的子数组（当然，给子数组开辟的空间不计入空间复杂度）
//准备双指针用来形成滑动区间，这样既可以动态的确定每个以array[i]结尾的子数组，也可以很好的保存中间遇到的最长的且和最大的子数组（保存左右边界的下标）。当然要想好判断条件再去做状态转移赋值。
```

9. 最小的K个数

```c++
//一、先排序再取k个，这种时间复杂度为排序算法的时间复杂度，直接用库函数sort。
//二、用堆排序+队列，priority_queue在push新元素时，默认是大顶堆，自动按堆排序，所以只需要和pq.top()比较决定是否pop且push进行元素更新，从而留下最小的k个元素。priority_queue<int, vector<int>, greater<int> > c;  //这样就是小顶堆
//三、结合快排用分治法，确定应该在第k+1的位置上的元素，然后把它前面k个返回即可
```

10. 求1+2+....+n

```c++
//要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
//用递归+逻辑符号：
class Solution {
public:
    int Sum_Solution(int n) {
        bool x = n > 1 && (n += Sum_Solution(n-1)); // bool x只是为了不报错
        return n;
    }
};
```

11. 反转链表

```c++
//用双指针法，同时也需要临时的指针保存中间结果，但思路是将链表指针反向，即后一个结点指向前一个节点。
//严格说，是三个指针，pre、cur、temp
```

12. 合并两个排序的链表

```c++
//一、三指针法，两个同时遍历两个链表，值得运用的技巧就是，设一个虚拟头节点，用一个cur指针先指向虚拟头节点，然后其next每次指向更小的值的，每加入一个元素并将指针后移做一次更新，直到某个链表到尾部。循环结束再指向未遍历完的剩余链表头一个节点。然后返回这个虚拟头节点的next。
//二、用递归法，每次是传入两个链表（说是子链表）的头节点，然后返回更小值的那个，并将其next指向下次递归返回的节点。
class Solution {
public:
 ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
 {
     if (!pHead1) return pHead2;
     if (!pHead2) return pHead1;
     if (pHead1->val <= pHead2->val) {
         pHead1->next = Merge(pHead1->next, pHead2);
         return pHead1;
     }
     else {
         pHead2->next = Merge(pHead1, pHead2->next);
         return pHead2;
     }
 }
};
```

13. 两个链表的第一个公共结点（一定有的情况下）

```c++
//用到双指针，同步往下遍历，到了尾部就从另一个链表的头结点开始，遇到第一个公共结点时，两个指针走的路程一定是m+n（即两个链表的长度和）
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode *ta = pHead1, *tb = pHead2;
        while (ta != tb) {
            ta = ta ? ta->next : pHead2;
            tb = tb ? tb->next : pHead1;
        }
        return ta;
    }
};
```

14. 给定二叉树的前序、中序遍历结果，重建该二叉树并返回根节点。

```c++
//
```



# 基本算法

1. 快排

```c++
```

2. 动态规划经典问题

[csdn动态规划四个经典问题：台阶、矩阵左上角走到左下角最短、最长递增型子数组、最长公共子序列](https://blog.csdn.net/weixin_42182348/article/details/90814032?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_paycolumn_v3&utm_relevant_index=4)

动态规划：

它不是具体的代码，而是一种使用多阶段决策的优化通用方法。适应对象是由交叠的子问题所构成的问题，我们只需要解决同问题的更小子问题，并把求解结果记录到表中（即用空间换时间），这样既不用多次求解同一个子问题，就能从表中得到原始问题的解。

**关键词**：问题可以表现为多阶段决策、不重复求解、交叠子问题、无后效性 

3. 获取单链表是否有环？

快慢指针第一次相遇（即相同节点），则有环；然后根据a、b、c、L、r的关系推导，可以发现，让快指针放到头位置，慢指针仍在第一次相遇位置，两者同时开始，第一次相遇就是环入口。

3. Y型链表的第一个相同节点

   先求出两者的长度，再用双指针即可。

4. 鸡蛋几楼摔碎（共两个鸡蛋）

先用一个鸡蛋确定上界（二分法），直到破了为止，那层楼层作为上界；另一枚鸡蛋则从下界开始一层层（线性探测）丢。

